
// compressor utility for Commodore Plus/4 programs
// Copyright (C) 2007-2008 Istvan Varga <istvanv@users.sourceforge.net>
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// The Plus/4 program files generated by this utility are not covered by the
// GNU General Public License, and can be used, modified, and distributed
// without any restrictions.

#ifndef P4COMPRESS_COMPRESS_HPP
#define P4COMPRESS_COMPRESS_HPP

#include "plus4emu.hpp"
#include <vector>

namespace Plus4Compress {

  class Compressor {
   protected:
    std::vector< unsigned char >& outBuf;
    size_t  progressCnt;
    size_t  progressMax;
    bool    progressDisplayEnabled;
    int     prvProgressPercentage;
    void    (*progressMessageCallback)(void *userData, const char *msg);
    void    *progressMessageUserData;
    bool    (*progressPercentageCallback)(void *userData, int n);
    void    *progressPercentageUserData;
    // --------
    void progressMessage(const char *msg);
    bool setProgressPercentage(int n);
   public:
    Compressor(std::vector< unsigned char >& outBuf_);
    virtual ~Compressor();
    virtual void setCompressionLevel(int n);
    virtual void addZeroPageUpdate(unsigned int endAddr, bool isLastBlock);
    virtual bool compressData(
        const std::vector< unsigned char >& inBuf, unsigned int startAddr,
        bool isLastBlock, bool enableProgressDisplay = false) = 0;
    virtual void setProgressMessageCallback(
        void (*func)(void *userData, const char *msg), void *userData_);
    virtual void setProgressPercentageCallback(
        bool (*func)(void *userData, int n), void *userData_);
  };

  // --------------------------------------------------------------------------

  class Decompressor {
   public:
    Decompressor();
    virtual ~Decompressor();
    virtual void decompressData(
        std::vector< std::vector< unsigned char > >& outBuf,
        const std::vector< unsigned char >& inBuf) = 0;
  };

  // --------------------------------------------------------------------------

  Compressor * createCompressor(int compressionType,
                                std::vector< unsigned char >& outBuf);

  Decompressor * createDecompressor(int compressionType);

  // 'compressionType' can be negative to automatically detect compression type
  // returns the actual compression type used in 'inBuf'
  int decompressData(std::vector< std::vector< unsigned char > >& outBuf,
                     const std::vector< unsigned char >& inBuf,
                     int compressionType);
  // 'runAddr' can be the start address (0x0000 to 0xFFFF) of a machine code
  // program, or -1 for running a basic program, -2 to return to basic,
  // or -3 for monitor
  void getSFXModule(std::vector< unsigned char >& outBuf,
                    int compressionType = 0, int runAddr = -2,
                    bool c16Mode = false, bool noCRCCheck = false,
                    bool noReadBuffer = false, int borderEffectType = 2,
                    bool noBlankDisplay = false, bool noCleanup = false,
                    bool noROM = false, bool noCLI = false);

}       // namespace Plus4Compress

#endif  // P4COMPRESS_COMPRESS_HPP

