
// p4fliconv: high resolution interlaced FLI converter utility
// Copyright (C) 2007-2016 Istvan Varga <istvanv@users.sourceforge.net>
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// The Plus/4 program files generated by this utility are not covered by the
// GNU General Public License, and can be used, modified, and distributed
// without any restrictions.

#ifndef P4FLICONV_P4FLICONV_HPP
#define P4FLICONV_P4FLICONV_HPP

#include "plus4emu.hpp"
#include "fileio.hpp"
#include "cfg_db.hpp"
#include "system.hpp"
#include "ted.hpp"

#include <cmath>

#include <FL/Fl.H>
#include <FL/Fl_File_Chooser.H>

#ifndef DISABLE_OPENGL_DISPLAY
class Plus4FLIConvGUI;
class Plus4FLIConvGUI_Display;
class Plus4FLIConvGUI_TED7360;
#endif

#include "flicfg.hpp"
#ifndef DISABLE_OPENGL_DISPLAY
#  include "flidisp.hpp"
#endif
#include "imageconv.hpp"
#include "prgdata.hpp"

#ifndef DISABLE_OPENGL_DISPLAY
#  include "p4fliconv_fl.hpp"
#endif

namespace Plus4FLIConv {

  class FLIConverter {
   protected:
    void    (*progressMessageCallback)(void *userData, const char *msg);
    void    *progressMessageUserData;
    bool    (*progressPercentageCallback)(void *userData, int n);
    void    *progressPercentageUserData;
    int     prvProgressPercentage;
   public:
    static const float  defaultColorSaturation;
    FLIConverter();
    virtual ~FLIConverter();
    // the return value is false if the processing has been stopped
    virtual bool processImage(PRGData& prgData, unsigned int& prgEndAddr,
                              const char *infileName,
                              YUVImageConverter& imgConv,
                              Plus4Emu::ConfigurationDB& config);
    virtual void setProgressMessageCallback(void (*func)(void *userData,
                                                         const char *msg),
                                            void *userData_);
    virtual void setProgressPercentageCallback(bool (*func)(void *userData,
                                                            int n),
                                               void *userData_);
    static void convertPlus4Color(int c, float& y, float& u, float& v,
                                  double monitorGamma_ = 1.0);
   protected:
    virtual void progressMessage(const char *msg);
    virtual bool setProgressPercentage(int n);
  };

  // --------------------------------------------------------------------------

  static inline double calculateError(double a, double b)
  {
    return std::fabs(a - b);
  }

  static inline double calculateErrorSqr(double a, double b)
  {
    return ((a - b) * (a - b));
  }

  static inline double calculateYUVErrorSqr(double y1, double u1, double v1,
                                            double y2, double u2, double v2,
                                            double chromaErrorScale)
  {
    return (calculateErrorSqr(y1, y2)
            + (chromaErrorScale * (calculateErrorSqr(u1, u2)
                                   + calculateErrorSqr(v1, v2))));
  }

  static inline double calculateYUVErrorSqr(double y1, double u1, double v1,
                                            double y2, double u2, double v2,
                                            double lumaErrorScale,
                                            double chromaErrorScale)
  {
    return ((lumaErrorScale * calculateErrorSqr(y1, y2))
            + (chromaErrorScale * (calculateErrorSqr(u1, u2)
                                   + calculateErrorSqr(v1, v2))));
  }

  static inline void limitValue(int& x, int min_, int max_)
  {
    x = (x > min_ ? (x < max_ ? x : max_) : min_);
  }

  static inline void limitValue(float& x, float min_, float max_)
  {
    if (!(x >= min_ && x <= max_)) {
      if (x < min_)
        x = min_;
      else if (x > max_)
        x = max_;
      else
        x = (min_ + max_) * 0.5f;
    }
  }

  static inline void limitValue(double& x, double min_, double max_)
  {
    if (!(x >= min_ && x <= max_)) {
      if (x < min_)
        x = min_;
      else if (x > max_)
        x = max_;
      else
        x = (min_ + max_) * 0.5;
    }
  }

  static inline void limitRGBColor(float& r, float& g, float& b)
  {
    r = (r > 0.0f ? (r < 1.0f ? r : 1.0f) : 0.0f);
    g = (g > 0.0f ? (g < 1.0f ? g : 1.0f) : 0.0f);
    b = (b > 0.0f ? (b < 1.0f ? b : 1.0f) : 0.0f);
  }

  static inline void limitYUVColor(float& y, float& u, float& v)
  {
    y = (y > 0.0f ? (y < 1.0f ? y : 1.0f) : 0.0f);
    double  tmp = 1.0 / double(FLIConverter::defaultColorSaturation);
    double  uTmp = double(u) * tmp;
    double  vTmp = double(v) * tmp;
    double  c = (uTmp * uTmp) + (vTmp * vTmp);
    if (c > 1.0) {
      c = 1.0 / std::sqrt(c);
      u = float(double(u) * c);
      v = float(double(v) * c);
    }
  }

  static inline void rgbToYUV(float& y, float& u, float& v,
                              float r, float g, float b)
  {
    y = (0.299f * r) + (0.587f * g) + (0.114f * b);
    u = (b - y) * 0.492f;
    v = (r - y) * 0.877f;
  }

  static inline void yuvToRGB(float& r, float& g, float& b,
                              float y, float u, float v)
  {
    r = y + (v * float(1.0 / 0.877));
    g = y + (u * float(-0.114 / (0.492 * 0.587)))
          + (v * float(-0.299 / (0.877 * 0.587)));
    b = y + (u * float(1.0 / 0.492));
  }

  static inline uint8_t convertColorCode(int l, int c)
  {
    c = c & 15;
    return uint8_t((l == 0 || c == 0) ? 0 : ((((l - 1) & 7) << 4) | c));
  }

  static inline uint8_t colorCodeLuminance(int n)
  {
    return uint8_t((n & 15) == 0 ? 0 : (((n & 0x70) >> 4) + 1));
  }

  static inline uint8_t colorCodeColor(int n)
  {
    return uint8_t(n & 15);
  }

}       // namespace Plus4FLIConv

#ifndef DISABLE_OPENGL_DISPLAY
class Plus4FLIConvGUI_TED7360 : public Plus4::TED7360 {
 private:
  Plus4FLIConvGUI&  gui;
 public:
  Plus4FLIConvGUI_TED7360(Plus4FLIConvGUI& gui_);
  virtual ~Plus4FLIConvGUI_TED7360();
 protected:
  virtual void videoOutputCallback(const uint8_t *buf, size_t nBytes);
};
#endif

#endif  // P4FLICONV_P4FLICONV_HPP

