
// p4fliconv: high resolution interlaced FLI converter utility
// Copyright (C) 2007-2008 Istvan Varga <istvanv@users.sourceforge.net>
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// The Plus/4 program files generated by this utility are not covered by the
// GNU General Public License, and can be used, modified, and distributed
// without any restrictions.

#include "p4fliconv.hpp"
#include "flicfg.hpp"

namespace Plus4FLIConv {

  void FLIConfiguration::configChangeCallbackBoolean(void *userData_,
                                                     const std::string& name_,
                                                     bool value_)
  {
    (void) name_;
    (void) value_;
    reinterpret_cast<FLIConfiguration *>(userData_)->configChangeFlag = true;
  }

  void FLIConfiguration::configChangeCallbackInteger(void *userData_,
                                                     const std::string& name_,
                                                     int value_)
  {
    (void) name_;
    (void) value_;
    reinterpret_cast<FLIConfiguration *>(userData_)->configChangeFlag = true;
  }

  void FLIConfiguration::configChangeCallbackFloat(void *userData_,
                                                   const std::string& name_,
                                                   double value_)
  {
    (void) name_;
    (void) value_;
    reinterpret_cast<FLIConfiguration *>(userData_)->configChangeFlag = true;
  }

  void FLIConfiguration::configChangeCallbackVSize(void *userData_,
                                                   const std::string& name_,
                                                   int value_)
  {
    (void) name_;
    FLIConfiguration& this_ =
        *(reinterpret_cast<FLIConfiguration *>(userData_));
    if (value_ < 256) {
      value_ = (value_ > 128 ? (value_ < 248 ? value_ : 248) : 128);
      value_ = (value_ + 3) & (~(int(3)));
    }
    else {
      value_ = (value_ > 256 ? (value_ < 496 ? value_ : 496) : 256);
      value_ = (value_ + 7) & (~(int(7)));
    }
    this_.verticalSize = value_;
    this_.configChangeFlag = true;
  }

  FLIConfiguration::FLIConfiguration()
    : Plus4Emu::ConfigurationDB()
  {
    resetDefaultSettings();
    createKey("conversionType", conversionType);
    (*this)["conversionType"].setRange(0.0, 2.0);
    (*this)["conversionType"].setCallback(&configChangeCallbackInteger,
                                          (void *) this, true);
    createKey("yMin", yMin);
    (*this)["yMin"].setRange(-0.5, 1.0);
    (*this)["yMin"].setCallback(&configChangeCallbackFloat,
                                (void *) this, true);
    createKey("yMax", yMax);
    (*this)["yMax"].setRange(0.0, 2.0);
    (*this)["yMax"].setCallback(&configChangeCallbackFloat,
                                (void *) this, true);
    createKey("scaleX", scaleX);
    (*this)["scaleX"].setRange(0.1, 10.0);
    (*this)["scaleX"].setCallback(&configChangeCallbackFloat,
                                  (void *) this, true);
    createKey("scaleY", scaleY);
    (*this)["scaleY"].setRange(0.1, 10.0);
    (*this)["scaleY"].setCallback(&configChangeCallbackFloat,
                                  (void *) this, true);
    createKey("offsetX", offsetX);
    (*this)["offsetX"].setRange(-10000.0, 10000.0);
    (*this)["offsetX"].setCallback(&configChangeCallbackFloat,
                                   (void *) this, true);
    createKey("offsetY", offsetY);
    (*this)["offsetY"].setRange(-10000.0, 10000.0);
    (*this)["offsetY"].setCallback(&configChangeCallbackFloat,
                                   (void *) this, true);
    createKey("saturationMult", saturationMult);
    (*this)["saturationMult"].setRange(0.0, 8.0);
    (*this)["saturationMult"].setCallback(&configChangeCallbackFloat,
                                          (void *) this, true);
    createKey("saturationPow", saturationPow);
    (*this)["saturationPow"].setRange(0.1, 2.0);
    (*this)["saturationPow"].setCallback(&configChangeCallbackFloat,
                                         (void *) this, true);
    createKey("gammaCorrection", gammaCorrection);
    (*this)["gammaCorrection"].setRange(0.25, 4.0);
    (*this)["gammaCorrection"].setCallback(&configChangeCallbackFloat,
                                           (void *) this, true);
    createKey("monitorGamma", monitorGamma);
    (*this)["monitorGamma"].setRange(0.25, 4.0);
    (*this)["monitorGamma"].setCallback(&configChangeCallbackFloat,
                                        (void *) this, true);
    createKey("ditherMode", ditherMode);
    (*this)["ditherMode"].setRange(0.0, 3.0);
    (*this)["ditherMode"].setCallback(&configChangeCallbackInteger,
                                      (void *) this, true);
    createKey("ditherLimit", ditherLimit);
    (*this)["ditherLimit"].setRange(0.0, 1.0);
    (*this)["ditherLimit"].setCallback(&configChangeCallbackFloat,
                                       (void *) this, true);
    createKey("ditherDiffusion", ditherDiffusion);
    (*this)["ditherDiffusion"].setRange(0.0, 1.0);
    (*this)["ditherDiffusion"].setCallback(&configChangeCallbackFloat,
                                           (void *) this, true);
    createKey("enablePAL", enablePAL);
    (*this)["enablePAL"].setCallback(&configChangeCallbackBoolean,
                                     (void *) this, true);
    createKey("xShift0", xShift0);
    (*this)["xShift0"].setRange(-2.0, 7.0);
    (*this)["xShift0"].setCallback(&configChangeCallbackInteger,
                                   (void *) this, true);
    createKey("xShift1", xShift1);
    (*this)["xShift1"].setRange(-2.0, 7.0);
    (*this)["xShift1"].setCallback(&configChangeCallbackInteger,
                                   (void *) this, true);
    createKey("borderColor", borderColor);
    (*this)["borderColor"].setRange(0.0, 255.0);
    (*this)["borderColor"].setCallback(&configChangeCallbackInteger,
                                       (void *) this, true);
    createKey("verticalSize", verticalSize);
    (*this)["verticalSize"].setRange(128.0, 496.0);
    (*this)["verticalSize"].setCallback(&configChangeCallbackVSize,
                                        (void *) this, true);
    createKey("luminance1BitMode", luminance1BitMode);
    (*this)["luminance1BitMode"].setCallback(&configChangeCallbackBoolean,
                                             (void *) this, true);
    createKey("noLuminanceInterlace", noLuminanceInterlace);
    (*this)["noLuminanceInterlace"].setCallback(&configChangeCallbackBoolean,
                                                (void *) this, true);
    createKey("colorInterlaceMode", colorInterlaceMode);
    (*this)["colorInterlaceMode"].setRange(0.0, 2.0);
    (*this)["colorInterlaceMode"].setCallback(&configChangeCallbackInteger,
                                              (void *) this, true);
    createKey("luminanceSearchMode", luminanceSearchMode);
    (*this)["luminanceSearchMode"].setRange(0.0, 5.0);
    (*this)["luminanceSearchMode"].setCallback(&configChangeCallbackInteger,
                                               (void *) this, true);
    createKey("luminanceSearchModeParam", luminanceSearchModeParam);
    (*this)["luminanceSearchModeParam"].setRange(0.0, 16.0);
    (*this)["luminanceSearchModeParam"].setCallback(&configChangeCallbackFloat,
                                                    (void *) this, true);
    createKey("prgCompressionLevel", prgCompressionLevel);
    (*this)["prgCompressionLevel"].setRange(0.0, 9.0);
    createKey("rawPRGMode", rawPRGMode);
  }

  FLIConfiguration::~FLIConfiguration()
  {
  }

  void FLIConfiguration::resetDefaultSettings()
  {
    conversionType = 0;
    yMin = -0.02;
    yMax = 1.03;
    scaleX = 1.0;
    scaleY = 1.0;
    offsetX = 0.0;
    offsetY = 0.0;
    saturationMult = 1.0;
    saturationPow = 0.8;
    gammaCorrection = 1.0;
    monitorGamma = 1.33;
    ditherMode = 0;
    ditherLimit = 0.125;
    ditherDiffusion = 0.75;
    enablePAL = true;
    xShift0 = -1;
    xShift1 = -1;
    borderColor = 0x00;
    verticalSize = 464;
    luminance1BitMode = false;
    noLuminanceInterlace = false;
    colorInterlaceMode = 1;
    luminanceSearchMode = 2;
    luminanceSearchModeParam = 4.0;
    prgCompressionLevel = 0;
    rawPRGMode = false;
    configChangeFlag = true;
  }

}       // namespace Plus4FLIConv

