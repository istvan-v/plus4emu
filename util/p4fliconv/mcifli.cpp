
// p4fliconv: high resolution interlaced FLI converter utility
// Copyright (C) 2007-2008 Istvan Varga <istvanv@users.sourceforge.net>
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// The Plus/4 program files generated by this utility are not covered by the
// GNU General Public License, and can be used, modified, and distributed
// without any restrictions.

#include "p4fliconv.hpp"
#include "dither.hpp"
#include "imageconv.hpp"
#include "prgdata.hpp"
#include "mcifli.hpp"

namespace Plus4FLIConv {

  P4FLI_MultiColor::Line304::Line304()
  {
    buf = new float[304];
    for (size_t i = 0; i < 304; i++)
      buf[i] = 0.0f;
  }

  P4FLI_MultiColor::Line304::Line304(const Line304& r)
  {
    buf = new float[304];
    for (size_t i = 0; i < 304; i++)
      buf[i] = r.buf[i];
  }

  P4FLI_MultiColor::Line304::~Line304()
  {
    delete[] buf;
  }

  P4FLI_MultiColor::Line304&
      P4FLI_MultiColor::Line304::operator=(const Line304& r)
  {
    for (size_t i = 0; i < 304; i++)
      buf[i] = r.buf[i];
    return (*this);
  }

  void P4FLI_MultiColor::Line304::clear()
  {
    for (size_t i = 0; i < 304; i++)
      buf[i] = 0.0f;
  }

  // --------------------------------------------------------------------------

  P4FLI_MultiColor::Image304x248::Image304x248()
  {
    buf = new Line304[248];
  }

  P4FLI_MultiColor::Image304x248::Image304x248(const Image304x248& r)
  {
    buf = new Line304[248];
    for (size_t i = 0; i < 248; i++)
      buf[i] = r.buf[i];
  }

  P4FLI_MultiColor::Image304x248&
      P4FLI_MultiColor::Image304x248::operator=(const Image304x248& r)
  {
    for (size_t i = 0; i < 248; i++)
      buf[i] = r.buf[i];
    return (*this);
  }

  P4FLI_MultiColor::Image304x248::~Image304x248()
  {
    delete[] buf;
  }

  // --------------------------------------------------------------------------

  P4FLI_MultiColor::YUVImage304x248::YUVImage304x248()
  {
  }

  P4FLI_MultiColor::YUVImage304x248::YUVImage304x248(const YUVImage304x248& r)
    : imageY(r.imageY),
      imageU(r.imageU),
      imageV(r.imageV)
  {
  }

  P4FLI_MultiColor::YUVImage304x248::~YUVImage304x248()
  {
  }

  P4FLI_MultiColor::YUVImage304x248&
      P4FLI_MultiColor::YUVImage304x248::operator=(const YUVImage304x248& r)
  {
    imageY = r.imageY;
    imageU = r.imageU;
    imageV = r.imageV;
    return (*this);
  }

  // --------------------------------------------------------------------------

  P4FLI_MultiColor::P4FLI_MultiColor()
    : monitorGamma(2.2),
      ditherLimit(0.25),
      ditherScale(0.95),
      ditherMode(1),
      xShift0(-1),
      xShift1(-1),
      borderColor(0x00),
      nLines(232),
      conversionQuality(6),
      luminance1BitMode(false),
      ditheredImage((int *) 0),
      errorTable((double *) 0),
      xShiftTable((int *) 0),
      ditherPaletteY((float *) 0),
      ditherPaletteU((float *) 0),
      ditherPaletteV((float *) 0),
      errorPaletteY((float *) 0),
      errorPaletteU((float *) 0),
      errorPaletteV((float *) 0)
  {
    try {
      ditheredImage = new int[304 * 248];
      errorTable = new double[128 * 128];
      xShiftTable = new int[496];
      for (int i = 0; i < (304 * 248); i++)
        ditheredImage[i] = 0;
      for (int i = 0; i < (128 * 128); i++)
        errorTable[i] = 0.0;
      for (int i = 0; i < 496; i++)
        xShiftTable[i] = i & 1;
    }
    catch (...) {
      if (ditheredImage)
        delete[] ditheredImage;
      if (errorTable)
        delete[] errorTable;
      if (xShiftTable)
        delete[] xShiftTable;
      throw;
    }
  }

  P4FLI_MultiColor::~P4FLI_MultiColor()
  {
    delete[] ditheredImage;
    delete[] errorTable;
    delete[] xShiftTable;
    if (ditherPaletteY)         // NOTE: all palettes are allocated
      delete[] ditherPaletteY;  // as a single block of memory
  }

  void P4FLI_MultiColor::pixelStoreCallback(void *userData, int xc, int yc,
                                            float y, float u, float v)
  {
    P4FLI_MultiColor&  this_ =
        *(reinterpret_cast<P4FLI_MultiColor *>(userData));
    this_.resizedImage.y()[yc >> 1][xc >> 1] += (y * 0.25f);
    this_.resizedImage.u()[yc >> 1][xc >> 1] += (u * 0.25f);
    this_.resizedImage.v()[yc >> 1][xc >> 1] += (v * 0.25f);
  }

  void P4FLI_MultiColor::checkParameters()
  {
    limitValue(monitorGamma, 1.0, 4.0);
    limitValue(ditherLimit, 0.0, 2.0);
    limitValue(ditherScale, 0.0, 1.0);
    limitValue(ditherMode, 0, 5);
    limitValue(xShift0, -2, 7);
    limitValue(xShift1, -2, 7);
    borderColor = (borderColor & 0x7F) | 0x80;
    limitValue(nLines, 128, 248);
    nLines = (nLines + 3) & (~(int(3)));
    limitValue(conversionQuality, 1, 30);
  }

  P4FLI_MultiColor::FLIBlock4x2::FLIBlock4x2(const double *errorTable_,
                                             int& color0_0_, int& color0_1_,
                                             int& color3_0_, int& color3_1_)
    : errorTable(errorTable_),
      color0_0(color0_0_),
      color0_1(color0_1_),
      color3_0(color3_0_),
      color3_1(color3_1_),
      color1(0x00),
      color2(0x00),
      nColors(0),
      nColors_0(0),
      nColors_1(0)
  {
    for (int i = 0; i < 8; i++) {
      pixelColorCodes[i] = 0x00;
      pixelColorCounts[i] = 0;
    }
    for (int i = 0; i < 4; i++) {
      pixelColorCodes_0[i] = 0x00;
      pixelColorCounts_0[i] = 0;
      pixelColorCodes_1[i] = 0x00;
      pixelColorCounts_1[i] = 0;
    }
  }

  P4FLI_MultiColor::FLIBlock4x2::FLIBlock4x2(const FLIBlock4x2& r)
    : errorTable(r.errorTable),
      color0_0(r.color0_0),
      color0_1(r.color0_1),
      color3_0(r.color3_0),
      color3_1(r.color3_1),
      color1(r.color1),
      color2(r.color2),
      nColors(r.nColors),
      nColors_0(r.nColors_0),
      nColors_1(r.nColors_1)
  {
    for (int i = 0; i < 8; i++) {
      pixelColorCodes[i] = r.pixelColorCodes[i];
      pixelColorCounts[i] = r.pixelColorCounts[i];
    }
    for (int i = 0; i < 4; i++) {
      pixelColorCodes_0[i] = r.pixelColorCodes_0[i];
      pixelColorCounts_0[i] = r.pixelColorCounts_0[i];
      pixelColorCodes_1[i] = r.pixelColorCodes_1[i];
      pixelColorCounts_1[i] = r.pixelColorCounts_1[i];
    }
  }

  static void addPixel_(int& nColors,
                        int *pixelColorCodes, int *pixelColorCounts,
                        int c)
  {
    c = c & 0x7F;
    if ((c & 0x0F) == 0)
      c = 0x00;
    {
      int     i = 0;
      while (i < nColors) {
        if (pixelColorCodes[i] == c) {
          pixelColorCounts[i]++;
          break;
        }
        i++;
      }
      if (i >= nColors) {
        pixelColorCodes[nColors] = c;
        pixelColorCounts[nColors] = 1;
        nColors++;
      }
    }
    for (int i = 0; i < nColors; i++) {
      for (int j = i + 1; j < nColors; j++) {
        if (pixelColorCounts[j] > pixelColorCounts[i]) {
          int     tmp = pixelColorCodes[i];
          pixelColorCodes[i] = pixelColorCodes[j];
          pixelColorCodes[j] = tmp;
          tmp = pixelColorCounts[i];
          pixelColorCounts[i] = pixelColorCounts[j];
          pixelColorCounts[j] = tmp;
        }
      }
    }
  }

  void P4FLI_MultiColor::FLIBlock4x2::addPixel(int l, int c)
  {
    addPixel_(nColors, &(pixelColorCodes[0]), &(pixelColorCounts[0]), c);
    if (l == 0) {
      addPixel_(nColors_0, &(pixelColorCodes_0[0]), &(pixelColorCounts_0[0]),
                c);
    }
    else {
      addPixel_(nColors_1, &(pixelColorCodes_1[0]), &(pixelColorCounts_1[0]),
                c);
    }
  }

  inline double P4FLI_MultiColor::FLIBlock4x2::calculateError() const
  {
    double  totalErr = 0.0;
    for (int i = 0; i < nColors_0; i++) {
      int     c = pixelColorCodes_0[i];
      double  minErr = errorTable[(c << 7) | color0_0];
      double  err = errorTable[(c << 7) | color1];
      if (err < minErr)
        minErr = err;
      err = errorTable[(c << 7) | color2];
      if (err < minErr)
        minErr = err;
      err = errorTable[(c << 7) | color3_0];
      if (err < minErr)
        minErr = err;
      totalErr += (minErr * double(pixelColorCounts_0[i]));
    }
    for (int i = 0; i < nColors_1; i++) {
      int     c = pixelColorCodes_1[i];
      double  minErr = errorTable[(c << 7) | color0_1];
      double  err = errorTable[(c << 7) | color1];
      if (err < minErr)
        minErr = err;
      err = errorTable[(c << 7) | color2];
      if (err < minErr)
        minErr = err;
      err = errorTable[(c << 7) | color3_1];
      if (err < minErr)
        minErr = err;
      totalErr += (minErr * double(pixelColorCounts_1[i]));
    }
    return totalErr;
  }

  inline double P4FLI_MultiColor::FLIBlock4x2::calculateErrorLine0() const
  {
    double  totalErr = 0.0;
    for (int i = 0; i < nColors_0; i++) {
      int     c = pixelColorCodes_0[i];
      double  minErr = errorTable[(c << 7) | color0_0];
      double  err = errorTable[(c << 7) | color1];
      if (err < minErr)
        minErr = err;
      err = errorTable[(c << 7) | color2];
      if (err < minErr)
        minErr = err;
      err = errorTable[(c << 7) | color3_0];
      if (err < minErr)
        minErr = err;
      totalErr += (minErr * double(pixelColorCounts_0[i]));
    }
    return totalErr;
  }

  inline double P4FLI_MultiColor::FLIBlock4x2::calculateErrorLine1() const
  {
    double  totalErr = 0.0;
    for (int i = 0; i < nColors_1; i++) {
      int     c = pixelColorCodes_1[i];
      double  minErr = errorTable[(c << 7) | color0_1];
      double  err = errorTable[(c << 7) | color1];
      if (err < minErr)
        minErr = err;
      err = errorTable[(c << 7) | color2];
      if (err < minErr)
        minErr = err;
      err = errorTable[(c << 7) | color3_1];
      if (err < minErr)
        minErr = err;
      totalErr += (minErr * double(pixelColorCounts_1[i]));
    }
    return totalErr;
  }

  double P4FLI_MultiColor::FLIBlock4x2::optimizeColors(
      const std::vector< int >& colorTable_)
  {
    if (nColors <= 2) {
      color1 = pixelColorCodes[0];
      color2 = pixelColorCodes[1];
      return 0.0;
    }
    int     nColors_ = 0;
    int     nColors_0_ = 0;
    int     nColors_1_ = 0;
    int     pixelColorCodes_[8];
    int     pixelColorCounts_[8];
    int     pixelColorCodes_0_[4];
    int     pixelColorCounts_0_[4];
    int     pixelColorCodes_1_[4];
    int     pixelColorCounts_1_[4];
    for (int i = 0; i < nColors_0; i++) {
      int     c = pixelColorCodes_0[i];
      if (c == color0_0 || c == color3_0)
        continue;
      pixelColorCodes_0_[nColors_0_] = c;
      pixelColorCounts_0_[nColors_0_] = pixelColorCounts_0[i];
      nColors_0_++;
    }
    for (int i = 0; i < nColors_1; i++) {
      int     c = pixelColorCodes_1[i];
      if (c == color0_1 || c == color3_1)
        continue;
      pixelColorCodes_1_[nColors_1_] = c;
      pixelColorCounts_1_[nColors_1_] = pixelColorCounts_1[i];
      nColors_1_++;
    }
    for (int i = 0; i < nColors_0_; i++) {
      int     c = pixelColorCodes_0_[i];
      int     n = pixelColorCounts_0_[i];
      int     j = 0;
      while (j < nColors_) {
        if (pixelColorCodes_[j] == c) {
          pixelColorCounts_[j] += n;
          break;
        }
        j++;
      }
      if (j >= nColors_) {
        pixelColorCodes_[nColors_] = c;
        pixelColorCounts_[nColors_] = n;
        nColors_++;
      }
    }
    for (int i = 0; i < nColors_1_; i++) {
      int     c = pixelColorCodes_1_[i];
      int     n = pixelColorCounts_1_[i];
      int     j = 0;
      while (j < nColors_) {
        if (pixelColorCodes_[j] == c) {
          pixelColorCounts_[j] += n;
          break;
        }
        j++;
      }
      if (j >= nColors_) {
        pixelColorCodes_[nColors_] = c;
        pixelColorCounts_[nColors_] = n;
        nColors_++;
      }
    }
    if (nColors_ <= 2) {
      if (nColors_ >= 1)
        color1 = pixelColorCodes_[0];
      else
        color1 = 0x00;
      if (nColors_ >= 2)
        color2 = pixelColorCodes_[1];
      else
        color2 = 0x00;
      return 0.0;
    }
    double  minErr = 1000000.0;
    if (colorTable_.size() <= 48) {
      // color #1 and color #2
      int     bestColor1 = color1;
      int     bestColor2 = color2;
      for (size_t c1i = 0; c1i < colorTable_.size(); c1i++) {
        for (size_t c2i = c1i + 1; c2i < colorTable_.size(); c2i++) {
          color1 = colorTable_[c1i];
          color2 = colorTable_[c2i];
          double  err = 0.0;
          for (int i = 0; i < nColors_0_; i++) {
            int     c = pixelColorCodes_0_[i];
            double  minErr2 = errorTable[(c << 7) | color0_0];
            double  err2 = errorTable[(c << 7) | color1];
            if (err2 < minErr2)
              minErr2 = err2;
            err2 = errorTable[(c << 7) | color2];
            if (err2 < minErr2)
              minErr2 = err2;
            err2 = errorTable[(c << 7) | color3_0];
            if (err2 < minErr2)
              minErr2 = err2;
            err += (minErr2 * double(pixelColorCounts_0_[i]));
          }
          for (int i = 0; i < nColors_1_; i++) {
            int     c = pixelColorCodes_1_[i];
            double  minErr2 = errorTable[(c << 7) | color0_1];
            double  err2 = errorTable[(c << 7) | color1];
            if (err2 < minErr2)
              minErr2 = err2;
            err2 = errorTable[(c << 7) | color2];
            if (err2 < minErr2)
              minErr2 = err2;
            err2 = errorTable[(c << 7) | color3_1];
            if (err2 < minErr2)
              minErr2 = err2;
            err += (minErr2 * double(pixelColorCounts_1_[i]));
          }
          if (err < minErr) {
            bestColor1 = color1;
            bestColor2 = color2;
            minErr = err;
          }
        }
      }
      color1 = bestColor1;
      color2 = bestColor2;
    }
    else {
      // color #1
      int     bestColor = color1;
      for (size_t j = 0; j < colorTable_.size(); j++) {
        color1 = colorTable_[j];
        double  err = 0.0;
        for (int i = 0; i < nColors_0_; i++) {
          int     c = pixelColorCodes_0_[i];
          double  minErr2 = errorTable[(c << 7) | color0_0];
          double  err2 = errorTable[(c << 7) | color1];
          if (err2 < minErr2)
            minErr2 = err2;
          err2 = errorTable[(c << 7) | color2];
          if (err2 < minErr2)
            minErr2 = err2;
          err2 = errorTable[(c << 7) | color3_0];
          if (err2 < minErr2)
            minErr2 = err2;
          err += (minErr2 * double(pixelColorCounts_0_[i]));
        }
        for (int i = 0; i < nColors_1_; i++) {
          int     c = pixelColorCodes_1_[i];
          double  minErr2 = errorTable[(c << 7) | color0_1];
          double  err2 = errorTable[(c << 7) | color1];
          if (err2 < minErr2)
            minErr2 = err2;
          err2 = errorTable[(c << 7) | color2];
          if (err2 < minErr2)
            minErr2 = err2;
          err2 = errorTable[(c << 7) | color3_1];
          if (err2 < minErr2)
            minErr2 = err2;
          err += (minErr2 * double(pixelColorCounts_1_[i]));
        }
        if (err < minErr) {
          bestColor = color1;
          minErr = err;
        }
      }
      color1 = bestColor;
      // color #2
      minErr = 1000000.0;
      bestColor = color2;
      for (size_t j = 0; j < colorTable_.size(); j++) {
        color2 = colorTable_[j];
        double  err = 0.0;
        for (int i = 0; i < nColors_0_; i++) {
          int     c = pixelColorCodes_0_[i];
          double  minErr2 = errorTable[(c << 7) | color0_0];
          double  err2 = errorTable[(c << 7) | color1];
          if (err2 < minErr2)
            minErr2 = err2;
          err2 = errorTable[(c << 7) | color2];
          if (err2 < minErr2)
            minErr2 = err2;
          err2 = errorTable[(c << 7) | color3_0];
          if (err2 < minErr2)
            minErr2 = err2;
          err += (minErr2 * double(pixelColorCounts_0_[i]));
        }
        for (int i = 0; i < nColors_1_; i++) {
          int     c = pixelColorCodes_1_[i];
          double  minErr2 = errorTable[(c << 7) | color0_1];
          double  err2 = errorTable[(c << 7) | color1];
          if (err2 < minErr2)
            minErr2 = err2;
          err2 = errorTable[(c << 7) | color2];
          if (err2 < minErr2)
            minErr2 = err2;
          err2 = errorTable[(c << 7) | color3_1];
          if (err2 < minErr2)
            minErr2 = err2;
          err += (minErr2 * double(pixelColorCounts_1_[i]));
        }
        if (err < minErr) {
          bestColor = color2;
          minErr = err;
        }
      }
      color2 = bestColor;
    }
    return minErr;
  }

  void P4FLI_MultiColor::initializePalettes()
  {
    if (!ditherPaletteY) {
      ditherPaletteY = new float[768];
      ditherPaletteU = &(ditherPaletteY[128]);
      ditherPaletteV = &(ditherPaletteY[256]);
      errorPaletteY = &(ditherPaletteY[384]);
      errorPaletteU = &(ditherPaletteY[512]);
      errorPaletteV = &(ditherPaletteY[640]);
    }
    for (int i = 0; i < 128; i++) {
      FLIConverter::convertPlus4Color(i, ditherPaletteY[i], ditherPaletteU[i],
                                      ditherPaletteV[i], monitorGamma / 1.65);
      FLIConverter::convertPlus4Color(i, errorPaletteY[i], errorPaletteU[i],
                                      errorPaletteV[i], monitorGamma * 0.44);
    }
  }

  void P4FLI_MultiColor::createErrorTable(double colorErrorScale)
  {
    limitValue(colorErrorScale, 0.05, 1.0);
    for (int c0 = 0; c0 < 128; c0++) {
      for (int c1 = 0; c1 < 128; c1++) {
        errorTable[(c0 << 7) | c1] =
            calculateYUVErrorSqr(
                errorPaletteY[c0], errorPaletteU[c0], errorPaletteV[c0],
                errorPaletteY[c1], errorPaletteU[c1], errorPaletteV[c1],
                colorErrorScale);
      }
    }
  }

  int P4FLI_MultiColor::findNearestColor(
      float y, float u, float v,
      const float *paletteY, const float *paletteU, const float *paletteV)
  {
    int     l = 0;
    int     c = 0;
    if (!luminance1BitMode) {
      double  minErr = 1000000.0;
      for (int i = 0; i < 9; i++) {
        float   y_ = paletteY[(i != 0 ? (((i - 1) << 4) + 1) : 0)];
        double  err = calculateErrorSqr(y, y_);
        if (err < minErr) {
          l = i;
          minErr = err;
        }
      }
    }
    else {
      l = (y < 0.5f ? 0 : 8);
    }
    if (l != 0) {
      double  minErr = 1000000.0;
      for (int i = 1; i < 16; i++) {
        double  err = calculateErrorSqr(u, paletteU[i + 64])
                      + calculateErrorSqr(v, paletteV[i + 64]);
        if (err < minErr) {
          c = i;
          minErr = err;
        }
      }
    }
    return ((l != 0 ? ((l - 1) << 4) : 0) + c);
  }

  void P4FLI_MultiColor::ditherLine(long yc)
  {
    if (ditherMode < 2) {
      // ordered dithering
      float   luminanceTable[9];
      float   luminanceTable_[9];
      float   hueTable[15];
      int     hueIndexTable[15];
      for (int i = 0; i < 9; i++) {
        luminanceTable[i] = ditherPaletteY[(i == 0 ? 0 : (((i - 1) << 4) + 1))];
        luminanceTable_[i] = errorPaletteY[(i == 0 ? 0 : (((i - 1) << 4) + 1))];
      }
      for (int i = 0; i < 14; i++) {
        float   u = ditherPaletteU[66 + i];
        float   v = ditherPaletteV[66 + i];
        double  phs = std::atan2(double(v), double(u)) / (2.0 * 3.14159265);
        if (phs < 0.0)
          phs = phs + 1.0;
        hueTable[i] = float(phs);
        hueIndexTable[i] = i;
      }
      for (int i = 0; i < 14; i++) {
        for (int j = i + 1; j < 14; j++) {
          if (hueTable[j] < hueTable[i]) {
            {
              float   tmp = hueTable[i];
              hueTable[i] = hueTable[j];
              hueTable[j] = tmp;
            }
            {
              int     tmp = hueIndexTable[i];
              hueIndexTable[i] = hueIndexTable[j];
              hueIndexTable[j] = tmp;
            }
          }
        }
      }
      hueTable[14] = hueTable[0] + 1.0f;
      hueIndexTable[14] = hueIndexTable[0];
      const int *ditherTable_ = &(ditherTable[0]);
      if (ditherMode == 0)
        ditherTable_ = &(ditherTable_Bayer[0]);
      for (long xc = 0L; xc < 304L; xc++) {
        float   y = resizedImage.y()[yc].getPixel(xc);
        float   y_ = float(std::pow(double(y), 0.726));
        float   u = resizedImage.u()[yc].getPixel(xc);
        float   v = resizedImage.v()[yc].getPixel(xc);
        float   s = float(std::sqrt(double(u * u) + double(v * v)));
        float   h = float(std::atan2(double(v), double(u)));
        s = s / FLIConverter::defaultColorSaturation;
        h = h / (2.0f * 3.14159265f);
        if (h < 0.0f)
          h = h + 1.0f;
        int     li0 = 0;
        int     li1 = 8;
        if (!luminance1BitMode) {
          while (y > luminanceTable[li0 + 1] && li0 < 7)
            li0++;
          li1 = li0 + 1;
        }
        if (calculateError(calculateError(y_, luminanceTable_[li0]),
                           calculateError(y_, luminanceTable_[li1]))
            >= ditherLimit) {
          if (calculateError(y_, luminanceTable_[li0])
              > calculateError(y_, luminanceTable_[li1])) {
            li0 = li1;
          }
        }
        else {
          float   f = (y - luminanceTable[li0])
                      / (luminanceTable[li1] - luminanceTable[li0]);
          if (ditherPixelValue(xc, yc, f, ditherTable_))
            li0 = li1;
        }
        int     si = 0;
        if (ditherPixelValue(xc, yc, s, ditherTable_))
          si++;
        int     hi = 0;
        if (h < hueTable[0])    // special case for hue wrap-around
          h = h + 1.0f;
        while (h > hueTable[hi + 1] && hi < 13)
          hi++;
        float   f = (h - hueTable[hi]) / (hueTable[hi + 1] - hueTable[hi]);
        f = f * s;              // adjust value for saturation dithering
        if (ditherPixelValue(xc, yc, f, ditherTable_))
          hi++;
        hi = hueIndexTable[hi];
        ditheredImage[yc * 304L + xc] =
            (li0 == 0 ? 0 : ((si == 0 ? 1 : (hi + 2)) + ((li0 - 1) << 4)));
      }
      return;
    }
    // error diffusion dithering
    for (long xc = 0L; xc < 304L; xc++) {
      if (yc & 1L)
        xc = 303L - xc;
      // find the palette color nearest the original pixel
      float   y0 = resizedImage.y()[yc].getPixel(xc);
      float   y0_ = float(std::pow(double(y0), 0.726));
      float   u0 = resizedImage.u()[yc].getPixel(xc);
      float   v0 = resizedImage.v()[yc].getPixel(xc);
      int     c0 =
          findNearestColor(y0_, u0, v0,
                           errorPaletteY, errorPaletteU, errorPaletteV);
      // find the palette color nearest the original pixel with error added
      float   y = y0 + ditherErrorImage.y()[yc].getPixel(xc);
      float   u = u0 + ditherErrorImage.u()[yc].getPixel(xc);
      float   v = v0 + ditherErrorImage.v()[yc].getPixel(xc);
      y = (y > 0.0f ? (y < 1.0f ? y : 1.0f) : 0.0f);
      {
        float   tmp = float(std::sqrt(double(u * u) + double(v * v)));
        if (tmp > FLIConverter::defaultColorSaturation) {
          tmp = FLIConverter::defaultColorSaturation / tmp;
          u = u * tmp;
          v = v * tmp;
        }
      }
      int     c =
          findNearestColor(y, u, v,
                           ditherPaletteY, ditherPaletteU, ditherPaletteV);
      double  err0 = std::sqrt(calculateYUVErrorSqr(errorPaletteY[c0],
                                                    errorPaletteU[c0],
                                                    errorPaletteV[c0],
                                                    y0_, u0, v0, 0.125));
      double  err = std::sqrt(calculateYUVErrorSqr(errorPaletteY[c],
                                                   errorPaletteU[c],
                                                   errorPaletteV[c],
                                                   y0_, u0, v0, 0.125));
      ditheredImage[yc * 304L + xc] =
          (calculateError(err, err0) < ditherLimit ? c : c0);
      y = y0 + ((y - y0) * float(ditherScale));
      u = u0 + ((u - u0) * float(ditherScale));
      v = v0 + ((v - v0) * float(ditherScale));
      float   errY = y - ditherPaletteY[c];
      float   errU = u - ditherPaletteU[c];
      float   errV = v - ditherPaletteV[c];
      const int *errMultTbl = &(ditherTable_FloydSteinberg[0]);
      switch (ditherMode) {
      case 3:
        errMultTbl = &(ditherTable_Jarvis[0]);
        break;
      case 4:
        errMultTbl = &(ditherTable_Stucki[0]);
        break;
      case 5:
        errMultTbl = &(ditherTable_Sierra2[0]);
        break;
      }
      for (int i = 0; i < 12; i++) {
        if (errMultTbl[i + 1] == 0)
          continue;
        long    yc_ = yc + ((i + 3) / 5);
        long    xc_ = ((i + 3) % 5) - 2;
        xc_ = ((yc & 1L) == 0L ? (xc + xc_) : (xc - xc_));
        if (yc_ >= 0L && yc_ < long(nLines) && xc_ >= 0L && xc_ < 304L) {
          float   errMult = float(errMultTbl[i + 1]) / float(errMultTbl[0]);
          ditherErrorImage.y()[yc_].setPixel(
              xc_, ditherErrorImage.y()[yc_].getPixel(xc_) + (errY * errMult));
          ditherErrorImage.u()[yc_].setPixel(
              xc_, ditherErrorImage.u()[yc_].getPixel(xc_) + (errU * errMult));
          ditherErrorImage.v()[yc_].setPixel(
              xc_, ditherErrorImage.v()[yc_].getPixel(xc_) + (errV * errMult));
        }
      }
      if (yc & 1L)
        xc = 303L - xc;
    }
  }

  double P4FLI_MultiColor::convertTwoLines(PRGData& prgData,
                                           long yc, bool oddField)
  {
    int     color0_0 = 0;
    int     color0_1 = 0;
    int     color3_0 = 0;
    int     color3_1 = 0;
    // find the color indexes used in each attribute block area
    std::vector< FLIBlock4x2 >  attrBlocks(40, FLIBlock4x2(errorTable,
                                                           color0_0, color0_1,
                                                           color3_0, color3_1));
    int     xs[2];
    xs[0] = xShiftTable[((yc + 0) << 1) | long(oddField)];
    xs[1] = xShiftTable[((yc + 1) << 1) | long(oddField)];
    for (int i = 0; i < 2; i++) {
      if (oddField) {
        attrBlocks[(7 - xs[i]) >> 3].addPixel(i,
                                              ditheredImage[(yc + i) * 304L]);
      }
      for (int xc = int(oddField); xc < 304; xc += 2) {
        int     n = (xc + 8 - xs[i]) >> 3;
        attrBlocks[n].addPixel(i, ditheredImage[(yc + i) * 304L + xc]);
      }
    }
    bool    color0ChangeEnabled = (nLines <= 200 || xs[1] == xs[0]);
    // find the set of colors that needs to be searched for optimal conversion
    std::vector< int >  colorTable0;                    // for color #0 and #3
    std::vector< std::vector< int > >   colorTables;    // for color #1 and #2
    colorTables.resize(40);
    {
      float   minY0 = 1.0f;
      float   maxY0 = 0.0f;
      float   minU0 = 1.0f;
      float   maxU0 = -1.0f;
      float   minV0 = 1.0f;
      float   maxV0 = -1.0f;
      for (int i = 0; i < 40; i++) {
        float   minY = 1.0f;
        float   maxY = 0.0f;
        float   minU = 1.0f;
        float   maxU = -1.0f;
        float   minV = 1.0f;
        float   maxV = -1.0f;
        for (int j = 0; j < attrBlocks[i].nColors; j++) {
          float   y = errorPaletteY[attrBlocks[i].pixelColorCodes[j]];
          float   u = errorPaletteU[attrBlocks[i].pixelColorCodes[j]];
          float   v = errorPaletteV[attrBlocks[i].pixelColorCodes[j]];
          minY = (y < minY ? y : minY);
          maxY = (y > maxY ? y : maxY);
          minU = (u < minU ? u : minU);
          maxU = (u > maxU ? u : maxU);
          minV = (v < minV ? v : minV);
          maxV = (v > maxV ? v : maxV);
          if (attrBlocks[i].nColors > 2) {
            minY0 = (y < minY0 ? y : minY0);
            maxY0 = (y > maxY0 ? y : maxY0);
            minU0 = (u < minU0 ? u : minU0);
            maxU0 = (u > maxU0 ? u : maxU0);
            minV0 = (v < minV0 ? v : minV0);
            maxV0 = (v > maxV0 ? v : maxV0);
          }
        }
        if (minV < 0.0f && maxV > 0.0f) {
          if (minU < 0.0f)
            minU = -(FLIConverter::defaultColorSaturation);
          if (maxU > 0.0f)
            maxU = FLIConverter::defaultColorSaturation;
        }
        if (minU < 0.0f && maxU > 0.0f) {
          if (minV < 0.0f)
            minV = -(FLIConverter::defaultColorSaturation);
          if (maxV > 0.0f)
            maxV = FLIConverter::defaultColorSaturation;
        }
        minY = minY - 0.0001f;
        maxY = maxY + 0.0001f;
        minU = minU - 0.0001f;
        maxU = maxU + 0.0001f;
        minV = minV - 0.0001f;
        maxV = maxV + 0.0001f;
        for (int j = 0; j < 128; j++) {
          if (j > 0 && (j & 15) == 0)
            continue;
          float   y = errorPaletteY[j];
          float   u = errorPaletteU[j];
          float   v = errorPaletteV[j];
          if (y > minY && y < maxY &&
              ((j & 15) == 1 ||
               (u > minU && u < maxU && v > minV && v < maxV))) {
            colorTables[i].push_back(j);
          }
        }
      }
      if (minV0 < 0.0f && maxV0 > 0.0f) {
        if (minU0 < 0.0f)
          minU0 = -(FLIConverter::defaultColorSaturation);
        if (maxU0 > 0.0f)
          maxU0 = FLIConverter::defaultColorSaturation;
      }
      if (minU0 < 0.0f && maxU0 > 0.0f) {
        if (minV0 < 0.0f)
          minV0 = -(FLIConverter::defaultColorSaturation);
        if (maxV0 > 0.0f)
          maxV0 = FLIConverter::defaultColorSaturation;
      }
      minY0 = minY0 - 0.0001f;
      maxY0 = maxY0 + 0.0001f;
      minU0 = minU0 - 0.0001f;
      maxU0 = maxU0 + 0.0001f;
      minV0 = minV0 - 0.0001f;
      maxV0 = maxV0 + 0.0001f;
      for (int j = 0; j < 128; j++) {
        if (j > 0 && (j & 15) == 0)
          continue;
        float   y = errorPaletteY[j];
        float   u = errorPaletteU[j];
        float   v = errorPaletteV[j];
        if (y > minY0 && y < maxY0 &&
            ((j & 15) == 1 ||
             (u > minU0 && u < maxU0 && v > minV0 && v < maxV0))) {
          colorTable0.push_back(j);
        }
      }
    }
    double  bestErr = 1000000.0;
    std::vector< int >  bestColors(84);
    for (int i = 0; i < 80; i += 2) {
      bestColors[i + 0] = attrBlocks[i >> 1].color1;
      bestColors[i + 1] = attrBlocks[i >> 1].color2;
    }
    bestColors[80] = color0_0;
    bestColors[81] = color0_1;
    bestColors[82] = color3_0;
    bestColors[83] = color3_1;
    std::vector< int >  colorCnts(128);
    int     randomSeed = 0;
    Plus4Emu::setRandomSeed(randomSeed, 1U);
    for (int l = 0; l < conversionQuality; l++) {
      // set initial palette with different methods, and choose the one
      // that results in the least error after optimization
      for (int i = 0; i < 128; i++)
        colorCnts[i] = 0;
      for (int i = 0; i < 40; i++) {
        int     nColors = attrBlocks[i].nColors;
        if (nColors <= 2) {
          attrBlocks[i].color1 = attrBlocks[i].pixelColorCodes[0];
          attrBlocks[i].color2 = attrBlocks[i].pixelColorCodes[1];
        }
        else {
          switch (l) {
          case 0:
          case 6:
            attrBlocks[i].color1 = attrBlocks[i].pixelColorCodes[nColors - 1];
            attrBlocks[i].color2 = attrBlocks[i].pixelColorCodes[nColors - 2];
            break;
          case 1:
          case 7:
            attrBlocks[i].color1 = attrBlocks[i].pixelColorCodes[0];
            attrBlocks[i].color2 = attrBlocks[i].pixelColorCodes[1];
            break;
          case 2:
          case 8:
            attrBlocks[i].color1 = attrBlocks[i].pixelColorCodes[0];
            attrBlocks[i].color2 = attrBlocks[i].pixelColorCodes[nColors - 1];
            break;
          case 3:
          case 9:
            {
              attrBlocks[i].color1 = attrBlocks[i].pixelColorCodes[0];
              double  maxErr = 0.0;
              for (int j = 1; j < nColors; j++) {
                double  err = errorTable[(attrBlocks[i].color1 << 7)
                                         | (attrBlocks[i].pixelColorCodes[j])];
                if (err >= maxErr) {
                  attrBlocks[i].color2 = attrBlocks[i].pixelColorCodes[j];
                  maxErr = err;
                }
              }
            }
            break;
          case 4:
          case 10:
            attrBlocks[i].color1 = 0x00;
            attrBlocks[i].color2 = 0x00;
            break;
          case 5:
          case 11:
            attrBlocks[i].color1 = 0x71;
            attrBlocks[i].color2 = 0x71;
            break;
          default:
            attrBlocks[i].color1 =
                colorTables[i][Plus4Emu::getRandomNumber(randomSeed)
                               % int(colorTables[i].size())];
            attrBlocks[i].color2 =
                colorTables[i][Plus4Emu::getRandomNumber(randomSeed)
                               % int(colorTables[i].size())];
            break;
          }
          for (int j = 0; j < nColors; j++) {
            int     c = attrBlocks[i].pixelColorCodes[j];
            if (c != attrBlocks[i].color1 && c != attrBlocks[i].color2)
              colorCnts[c] = colorCnts[c] + attrBlocks[i].pixelColorCounts[j];
          }
        }
      }
      if (l == 4 || l == 10) {
        color0_0 = 0x71;
        color3_0 = 0x71;
      }
      else if (l == 5 || l == 11) {
        color0_0 = 0x00;
        color3_0 = 0x00;
      }
      else if (l < 12 || colorTable0.size() < 1) {
        int     maxCnt1 = 0;
        int     maxCnt2 = 0;
        for (int i = 0; i < 128; i++) {
          if (colorCnts[i] > maxCnt1) {
            maxCnt2 = maxCnt1;
            color3_0 = color0_0;
            maxCnt1 = colorCnts[i];
            color0_0 = i;
          }
          else if (colorCnts[i] > maxCnt2) {
            maxCnt2 = colorCnts[i];
            color3_0 = i;
          }
        }
      }
      else {
        color0_0 = colorTable0[Plus4Emu::getRandomNumber(randomSeed)
                               % int(colorTable0.size())];
        color3_0 = colorTable0[Plus4Emu::getRandomNumber(randomSeed)
                               % int(colorTable0.size())];
      }
      color0_1 = color0_0;
      color3_1 = color3_0;
      // optimize attributes and color registers
      double  prvErr = 1000000.0;
      for (int i = (l < 6 ? 7 : -1); i >= 0; i--) {
        // color #0 (FF15), line 0 and 1
        double  minErr = prvErr;
        int     bestColor = color0_0;
        for (size_t j = 0; j < colorTable0.size(); j++) {
          color0_0 = colorTable0[j];
          color0_1 = color0_0;
          double  err = 0.0;
          for (int k = 0; k < 40; k++) {
            if (attrBlocks[k].nColors <= 2)
              continue;
            err += attrBlocks[k].calculateError();
            if (err > (minErr * 1.000001))
              break;
          }
          if (err < minErr) {
            bestColor = color0_0;
            minErr = err;
          }
        }
        color0_0 = bestColor;
        color0_1 = color0_0;
        // color #3 (FF16), line 0 and 1
        bestColor = color3_0;
        for (size_t j = 0; j < colorTable0.size(); j++) {
          color3_0 = colorTable0[j];
          color3_1 = color3_0;
          double  err = 0.0;
          for (int k = 0; k < 40; k++) {
            if (attrBlocks[k].nColors <= 2)
              continue;
            err += attrBlocks[k].calculateError();
            if (err > (minErr * 1.000001))
              break;
          }
          if (err < minErr) {
            bestColor = color3_0;
            minErr = err;
          }
        }
        color3_0 = bestColor;
        color3_1 = color3_0;
        // color #1 and color #2
        double  err = 0.0;
        for (int k = 0; k < 40; k++)
          err += attrBlocks[k].optimizeColors(colorTables[k]);
        // quit the optimization loop earlier if the error could not be reduced
        if (err >= (prvErr * 0.99999999)) {
          prvErr = err;
          break;
        }
        prvErr = err;
      }
      for (int i = 7; i >= 0; i--) {
        // color #0 (FF15), line 0
        double  minErr = 0.0;
        if (color0ChangeEnabled) {
          for (int k = 0; k < 40; k++) {
            if (attrBlocks[k].nColors <= 2)
              continue;
            minErr += attrBlocks[k].calculateErrorLine0();
          }
        }
        else
          minErr = prvErr;
        int     bestColor = color0_0;
        for (size_t j = 0; j < colorTable0.size(); j++) {
          color0_0 = colorTable0[j];
          if (!color0ChangeEnabled)
            color0_1 = color0_0;
          double  err = 0.0;
          for (int k = 0; k < 40; k++) {
            if (attrBlocks[k].nColors <= 2)
              continue;
            if (color0ChangeEnabled)
              err += attrBlocks[k].calculateErrorLine0();
            else
              err += attrBlocks[k].calculateError();
            if (err > (minErr * 1.000001))
              break;
          }
          if (err < minErr) {
            bestColor = color0_0;
            minErr = err;
          }
        }
        color0_0 = bestColor;
        if (!color0ChangeEnabled)
          color0_1 = color0_0;
        // color #0 (FF15), line 1
        if (color0ChangeEnabled) {
          minErr = 0.0;
          for (int k = 0; k < 40; k++) {
            if (attrBlocks[k].nColors <= 2)
              continue;
            minErr += attrBlocks[k].calculateErrorLine1();
          }
          bestColor = color0_1;
          for (size_t j = 0; j < colorTable0.size(); j++) {
            color0_1 = colorTable0[j];
            double  err = 0.0;
            for (int k = 0; k < 40; k++) {
              if (attrBlocks[k].nColors <= 2)
                continue;
              err += attrBlocks[k].calculateErrorLine1();
              if (err > (minErr * 1.000001))
                break;
            }
            if (err < minErr) {
              bestColor = color0_1;
              minErr = err;
            }
          }
          color0_1 = bestColor;
        }
        // color #3 (FF16), line 0
        minErr = 0.0;
        for (int k = 0; k < 40; k++) {
          if (attrBlocks[k].nColors <= 2)
            continue;
          minErr += attrBlocks[k].calculateErrorLine0();
        }
        bestColor = color3_0;
        for (size_t j = 0; j < colorTable0.size(); j++) {
          color3_0 = colorTable0[j];
          double  err = 0.0;
          for (int k = 0; k < 40; k++) {
            if (attrBlocks[k].nColors <= 2)
              continue;
            err += attrBlocks[k].calculateErrorLine0();
            if (err > (minErr * 1.000001))
              break;
          }
          if (err < minErr) {
            bestColor = color3_0;
            minErr = err;
          }
        }
        color3_0 = bestColor;
        // color #3 (FF16), line 1
        minErr = 0.0;
        for (int k = 0; k < 40; k++) {
          if (attrBlocks[k].nColors <= 2)
            continue;
          minErr += attrBlocks[k].calculateErrorLine1();
        }
        bestColor = color3_1;
        for (size_t j = 0; j < colorTable0.size(); j++) {
          color3_1 = colorTable0[j];
          double  err = 0.0;
          for (int k = 0; k < 40; k++) {
            if (attrBlocks[k].nColors <= 2)
              continue;
            err += attrBlocks[k].calculateErrorLine1();
            if (err > (minErr * 1.000001))
              break;
          }
          if (err < minErr) {
            bestColor = color3_1;
            minErr = err;
          }
        }
        color3_1 = bestColor;
        // color #1 and color #2
        double  err = 0.0;
        for (int k = 0; k < 40; k++)
          err += attrBlocks[k].optimizeColors(colorTables[k]);
        // quit the optimization loop earlier if the error could not be reduced
        if (err >= (prvErr * 0.99999999)) {
          prvErr = err;
          break;
        }
        prvErr = err;
      }
      if (prvErr < bestErr) {
        for (int i = 0; i < 80; i += 2) {
          bestColors[i + 0] = attrBlocks[i >> 1].color1;
          bestColors[i + 1] = attrBlocks[i >> 1].color2;
        }
        bestColors[80] = color0_0;
        bestColors[81] = color0_1;
        bestColors[82] = color3_0;
        bestColors[83] = color3_1;
        bestErr = prvErr;
      }
    }
    for (int i = 0; i < 80; i += 2) {
      attrBlocks[i >> 1].color1 = bestColors[i + 0];
      attrBlocks[i >> 1].color2 = bestColors[i + 1];
    }
    color0_0 = bestColors[80];
    color0_1 = bestColors[81];
    color3_0 = bestColors[82];
    color3_1 = bestColors[83];
    // store the attributes and color registers
    prgData.lineColor0((yc << 1) | long(oddField)) =
        (unsigned char) color0_0;
    prgData.lineColor0((yc << 1) | 2L | long(oddField)) =
        (unsigned char) color0_1;
    prgData.lineColor3((yc << 1) | long(oddField)) =
        (unsigned char) color3_0;
    prgData.lineColor3((yc << 1) | 2L | long(oddField)) =
        (unsigned char) color3_1;
    for (int i = 0; i < 40; i++) {
      int     l0 = (attrBlocks[i].color2 >> 4) & 0x07;
      int     l1 = (attrBlocks[i].color1 >> 4) & 0x07;
      int     c0 = attrBlocks[i].color2 & 0x0F;
      int     c1 = attrBlocks[i].color1 & 0x0F;
      if (c0 == 0)
        l0 = 0;
      else
        l0++;
      if (c1 == 0)
        l1 = 0;
      else
        l1++;
      prgData.l0(i << 3, (yc << 1) | long(oddField)) = l0;
      prgData.l1(i << 3, (yc << 1) | long(oddField)) = l1;
      prgData.c0(i << 3, (yc << 1) | long(oddField)) = c0;
      prgData.c1(i << 3, (yc << 1) | long(oddField)) = c1;
    }
    // generate bitmaps
    for (int i = 0; i < 2; i++) {
      for (int j = -(int(oddField)); j < 304; j += 2) {
        int     xc = j + 8 - xShiftTable[((yc + i) << 1) | long(oddField)];
        int     n = xc >> 3;
        int     c = ditheredImage[(yc + i) * 304L + (j >= 0 ? j : 0)];
        int     ci = 0;
        double  minErr = errorTable[(c << 7) | (i == 0 ? color0_0 : color0_1)];
        double  err = errorTable[(c << 7) | attrBlocks[n].color1];
        if (err < minErr) {
          ci = 1;
          minErr = err;
        }
        err = errorTable[(c << 7) | attrBlocks[n].color2];
        if (err < minErr) {
          ci = 2;
          minErr = err;
        }
        err = errorTable[(c << 7) | (i == 0 ? color3_0 : color3_1)];
        if (err < minErr)
          ci = 3;
        prgData.setPixel(xc & (~(int(1))), ((yc + i) << 1) | long(oddField),
                         bool(ci & 2));
        prgData.setPixel(xc | 1, ((yc + i) << 1) | long(oddField),
                         bool(ci & 1));
      }
    }
    // return the total amount of error
    return bestErr;
  }

  bool P4FLI_MultiColor::processImage(PRGData& prgData,
                                      unsigned int& prgEndAddr,
                                      const char *infileName,
                                      YUVImageConverter& imgConv,
                                      Plus4Emu::ConfigurationDB& config)
  {
    try {
      monitorGamma = config["monitorGamma"];
      ditherLimit = config["ditherLimit"];
      ditherScale = config["ditherDiffusion"];
      ditherMode = config["ditherMode"];
      xShift0 = config["xShift0"];
      xShift1 = config["xShift1"];
      borderColor = config["borderColor"];
      nLines = config["verticalSize"];
      if (nLines >= 256)
        nLines = nLines >> 1;
      conversionQuality = config["multiColorQuality"];
      luminance1BitMode = config["luminance1BitMode"];
      checkParameters();
      initializePalettes();
      createErrorTable(double(config["mcColorErrorScale"]));
      prgData.setConversionType(1);
      prgData.clear();
      prgData.borderColor() = (unsigned char) borderColor;
      prgData.setVerticalSize(nLines);
      for (int yc = 0; yc < 248; yc++) {
        resizedImage.y()[yc].clear();
        resizedImage.u()[yc].clear();
        resizedImage.v()[yc].clear();
        ditherErrorImage.y()[yc].clear();
        ditherErrorImage.u()[yc].clear();
        ditherErrorImage.v()[yc].clear();
      }
      imgConv.setImageSize(608, nLines * 2);
      imgConv.setPixelAspectRatio(1.0f);
      imgConv.setGammaCorrection(float(double(config["gammaCorrection"])),
                                 float(double(config["monitorGamma"]) / 1.65));
      imgConv.setPixelStoreCallback(&pixelStoreCallback, (void *) this);
      imgConv.convertImageFile(infileName);
      for (int yc = 0; yc < nLines; yc++) {
        for (int xc = 0; xc < 304; xc++) {
          limitYUVColor(resizedImage.y()[yc][xc],
                        resizedImage.u()[yc][xc],
                        resizedImage.v()[yc][xc]);
        }
      }
      // initialize horizontal scroll table
      int     randomSeed = 0;
      Plus4Emu::setRandomSeed(randomSeed,
                              Plus4Emu::Timer::getRandomSeedFromTime());
      for (int i = 0; i < (nLines << 1); i++) {
        int     xShift_ = (!(i & 1) ? xShift0 : xShift1);
        if (xShift_ == -2)
          xShift_ = Plus4Emu::getRandomNumber(randomSeed) & 7;
        else if (xShift_ == -1)
          xShift_ = 0;
        xShiftTable[i] = (xShift_ & 6) | (i & 1);
      }
      // convert input image to 121 colors with dithering
      progressMessage("Calculating FLI data");
      for (int yc = 0; yc < nLines; yc++) {
        if (!setProgressPercentage(yc * 20 / nLines)) {
          prgData[0] = 0x01;
          prgData[1] = 0x10;
          prgData[2] = 0x00;
          prgData[3] = 0x00;
          prgEndAddr = 0x1003U;
          progressMessage("");
          return false;
        }
        ditherLine(yc);
      }
      // generate FLI data
      double  totalError = 0.0;
      for (int yc = 0; yc < nLines; yc += 2) {
        // field 0 (x = 0, 2, 4, ...)
        if (!setProgressPercentage((yc * 40 / nLines) + 20)) {
          prgData[0] = 0x01;
          prgData[1] = 0x10;
          prgData[2] = 0x00;
          prgData[3] = 0x00;
          prgEndAddr = 0x1003U;
          progressMessage("");
          return false;
        }
        int     bestXShift0 = xShiftTable[(yc << 1) + 0];
        int     bestXShift1 = xShiftTable[(yc << 1) + 2];
        if (xShift0 == -1) {
          // find optimal horizontal shifts
          double  minErr = 1000000.0;
          for (int xs0 = 0; xs0 < 8; xs0 += 2) {
            for (int xs1 = 0; xs1 < 8; xs1 += 2) {
              xShiftTable[(yc << 1) + 0] = xs0;
              xShiftTable[(yc << 1) + 2] = xs1;
              double  err = convertTwoLines(prgData, yc, false);
              if (err < minErr) {
                bestXShift0 = xs0;
                bestXShift1 = xs1;
                minErr = err;
              }
            }
          }
        }
        xShiftTable[(yc << 1) + 0] = bestXShift0;
        xShiftTable[(yc << 1) + 2] = bestXShift1;
        totalError += convertTwoLines(prgData, yc, false);
      }
      for (int yc = 0; yc < nLines; yc += 2) {
        // field 1 (x = 1, 3, 5, ...)
        if (!setProgressPercentage((yc * 40 / nLines) + 60)) {
          prgData[0] = 0x01;
          prgData[1] = 0x10;
          prgData[2] = 0x00;
          prgData[3] = 0x00;
          prgEndAddr = 0x1003U;
          progressMessage("");
          return false;
        }
        int     bestXShift0 = xShiftTable[(yc << 1) + 1];
        int     bestXShift1 = xShiftTable[(yc << 1) + 3];
        if (xShift1 == -1) {
          // find optimal horizontal shifts
          double  minErr = 1000000.0;
          for (int xs0 = 1; xs0 < 8; xs0 += 2) {
            for (int xs1 = 1; xs1 < 8; xs1 += 2) {
              xShiftTable[(yc << 1) + 1] = xs0;
              xShiftTable[(yc << 1) + 3] = xs1;
              double  err = convertTwoLines(prgData, yc, true);
              if (err < minErr) {
                bestXShift0 = xs0;
                bestXShift1 = xs1;
                minErr = err;
              }
            }
          }
        }
        xShiftTable[(yc << 1) + 1] = bestXShift0;
        xShiftTable[(yc << 1) + 3] = bestXShift1;
        totalError += convertTwoLines(prgData, yc, true);
      }
      setProgressPercentage(100);
      progressMessage("");
      {
        char    tmpBuf[64];
        totalError = std::sqrt(totalError / double(nLines * 304));
        std::sprintf(&(tmpBuf[0]), "Done, RMS error = %.4f", totalError);
        progressMessage(&(tmpBuf[0]));
      }
      // write PRG output
      for (int yc = 0; yc < nLines; yc++) {
        int     xs0 = (xShiftTable[(yc << 1) + 0] & 0x06) | 0x10;
        int     xs1 = (xShiftTable[(yc << 1) + 1] & 0x06) | 0x11;
        prgData.lineXShift((yc << 1) + 0) = (unsigned char) xs0;
        prgData.lineXShift((yc << 1) + 1) = (unsigned char) xs1;
      }
      prgData.convertImageData();
      prgEndAddr = prgData.getImageDataEndAddress();
    }
    catch (...) {
      prgData[0] = 0x01;
      prgData[1] = 0x10;
      prgData[2] = 0x00;
      prgData[3] = 0x00;
      prgEndAddr = 0x1003U;
      progressMessage("");
      throw;
    }
    return true;
  }

}       // namespace Plus4FLIConv

