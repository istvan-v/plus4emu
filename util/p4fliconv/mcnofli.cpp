
// p4fliconv: high resolution interlaced FLI converter utility
// Copyright (C) 2007-2008 Istvan Varga <istvanv@users.sourceforge.net>
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// The Plus/4 program files generated by this utility are not covered by the
// GNU General Public License, and can be used, modified, and distributed
// without any restrictions.

#include "p4fliconv.hpp"
#include "dither.hpp"
#include "imageconv.hpp"
#include "prgdata.hpp"
#include "mcnofli.hpp"

namespace Plus4FLIConv {

  P4FLI_MultiColorNoFLI::Line160::Line160()
  {
    buf = new float[160];
    for (size_t i = 0; i < 160; i++)
      buf[i] = 0.0f;
  }

  P4FLI_MultiColorNoFLI::Line160::Line160(const Line160& r)
  {
    buf = new float[160];
    for (size_t i = 0; i < 160; i++)
      buf[i] = r.buf[i];
  }

  P4FLI_MultiColorNoFLI::Line160::~Line160()
  {
    delete[] buf;
  }

  P4FLI_MultiColorNoFLI::Line160&
      P4FLI_MultiColorNoFLI::Line160::operator=(const Line160& r)
  {
    for (size_t i = 0; i < 160; i++)
      buf[i] = r.buf[i];
    return (*this);
  }

  void P4FLI_MultiColorNoFLI::Line160::clear()
  {
    for (size_t i = 0; i < 160; i++)
      buf[i] = 0.0f;
  }

  // --------------------------------------------------------------------------

  P4FLI_MultiColorNoFLI::Image160x200::Image160x200()
  {
    buf = new Line160[200];
  }

  P4FLI_MultiColorNoFLI::Image160x200::Image160x200(const Image160x200& r)
  {
    buf = new Line160[200];
    for (size_t i = 0; i < 200; i++)
      buf[i] = r.buf[i];
  }

  P4FLI_MultiColorNoFLI::Image160x200&
      P4FLI_MultiColorNoFLI::Image160x200::operator=(const Image160x200& r)
  {
    for (size_t i = 0; i < 200; i++)
      buf[i] = r.buf[i];
    return (*this);
  }

  P4FLI_MultiColorNoFLI::Image160x200::~Image160x200()
  {
    delete[] buf;
  }

  // --------------------------------------------------------------------------

  P4FLI_MultiColorNoFLI::YUVImage160x200::YUVImage160x200()
  {
  }

  P4FLI_MultiColorNoFLI::YUVImage160x200::YUVImage160x200(
      const YUVImage160x200& r)
    : imageY(r.imageY),
      imageU(r.imageU),
      imageV(r.imageV)
  {
  }

  P4FLI_MultiColorNoFLI::YUVImage160x200::~YUVImage160x200()
  {
  }

  P4FLI_MultiColorNoFLI::YUVImage160x200&
      P4FLI_MultiColorNoFLI::YUVImage160x200::operator=(
          const YUVImage160x200& r)
  {
    imageY = r.imageY;
    imageU = r.imageU;
    imageV = r.imageV;
    return (*this);
  }

  // --------------------------------------------------------------------------

  P4FLI_MultiColorNoFLI::P4FLI_MultiColorNoFLI()
    : monitorGamma(2.2),
      ditherLimit(0.25),
      ditherScale(0.95),
      ditherMode(1),
      borderColor(0x00),
      conversionQuality(6),
      luminance1BitMode(false),
      ditheredImage((int *) 0),
      errorTable((double *) 0),
      ditherPaletteY((float *) 0),
      ditherPaletteU((float *) 0),
      ditherPaletteV((float *) 0),
      errorPaletteY((float *) 0),
      errorPaletteU((float *) 0),
      errorPaletteV((float *) 0)
  {
    try {
      ditheredImage = new int[160 * 200];
      errorTable = new double[128 * 128];
      for (int i = 0; i < (160 * 200); i++)
        ditheredImage[i] = 0;
      for (int i = 0; i < (128 * 128); i++)
        errorTable[i] = 0.0;
    }
    catch (...) {
      if (ditheredImage)
        delete[] ditheredImage;
      if (errorTable)
        delete[] errorTable;
      throw;
    }
  }

  P4FLI_MultiColorNoFLI::~P4FLI_MultiColorNoFLI()
  {
    delete[] ditheredImage;
    delete[] errorTable;
    if (ditherPaletteY)         // NOTE: all palettes are allocated
      delete[] ditherPaletteY;  // as a single block of memory
  }

  void P4FLI_MultiColorNoFLI::pixelStoreCallback(void *userData, int xc, int yc,
                                                 float y, float u, float v)
  {
    P4FLI_MultiColorNoFLI&  this_ =
        *(reinterpret_cast<P4FLI_MultiColorNoFLI *>(userData));
    this_.resizedImage.y()[yc >> 1][xc >> 2] += (y * 0.125f);
    this_.resizedImage.u()[yc >> 1][xc >> 2] += (u * 0.125f);
    this_.resizedImage.v()[yc >> 1][xc >> 2] += (v * 0.125f);
  }

  void P4FLI_MultiColorNoFLI::checkParameters()
  {
    limitValue(monitorGamma, 1.0, 4.0);
    limitValue(ditherLimit, 0.0, 2.0);
    limitValue(ditherScale, 0.0, 1.0);
    limitValue(ditherMode, 0, 5);
    borderColor = (borderColor & 0x7F) | 0x80;
    limitValue(conversionQuality, 1, 30);
  }

  P4FLI_MultiColorNoFLI::AttrBlock4x8::AttrBlock4x8(const double *errorTable_,
                                                    int& color0_, int& color3_)
    : errorTable(errorTable_),
      color0(color0_),
      color3(color3_),
      color1(0x00),
      color2(0x00),
      nColors(0)
  {
    for (int i = 0; i < 32; i++) {
      pixelColorCodes[i] = 0x00;
      pixelColorCounts[i] = 0;
    }
  }

  P4FLI_MultiColorNoFLI::AttrBlock4x8::AttrBlock4x8(const AttrBlock4x8& r)
    : errorTable(r.errorTable),
      color0(r.color0),
      color3(r.color3),
      color1(r.color1),
      color2(r.color2),
      nColors(r.nColors)
  {
    for (int i = 0; i < 32; i++) {
      pixelColorCodes[i] = r.pixelColorCodes[i];
      pixelColorCounts[i] = r.pixelColorCounts[i];
    }
  }

  void P4FLI_MultiColorNoFLI::AttrBlock4x8::addPixel(int c)
  {
    c = c & 0x7F;
    if ((c & 0x0F) == 0)
      c = 0x00;
    {
      int     i = 0;
      while (i < nColors) {
        if (pixelColorCodes[i] == c) {
          pixelColorCounts[i]++;
          break;
        }
        i++;
      }
      if (i >= nColors) {
        pixelColorCodes[nColors] = c;
        pixelColorCounts[nColors] = 1;
        nColors++;
      }
    }
    for (int i = 0; i < nColors; i++) {
      for (int j = i + 1; j < nColors; j++) {
        if (pixelColorCounts[j] > pixelColorCounts[i]) {
          int     tmp = pixelColorCodes[i];
          pixelColorCodes[i] = pixelColorCodes[j];
          pixelColorCodes[j] = tmp;
          tmp = pixelColorCounts[i];
          pixelColorCounts[i] = pixelColorCounts[j];
          pixelColorCounts[j] = tmp;
        }
      }
    }
  }

  inline double P4FLI_MultiColorNoFLI::AttrBlock4x8::calculateError() const
  {
    double  totalErr = 0.0;
    for (int i = 0; i < nColors; i++) {
      int     c = pixelColorCodes[i];
      double  minErr = errorTable[(c << 7) | color0];
      double  err = errorTable[(c << 7) | color1];
      if (err < minErr)
        minErr = err;
      err = errorTable[(c << 7) | color2];
      if (err < minErr)
        minErr = err;
      err = errorTable[(c << 7) | color3];
      if (err < minErr)
        minErr = err;
      totalErr += (minErr * double(pixelColorCounts[i]));
    }
    return totalErr;
  }

  void P4FLI_MultiColorNoFLI::initializePalettes()
  {
    if (!ditherPaletteY) {
      ditherPaletteY = new float[768];
      ditherPaletteU = &(ditherPaletteY[128]);
      ditherPaletteV = &(ditherPaletteY[256]);
      errorPaletteY = &(ditherPaletteY[384]);
      errorPaletteU = &(ditherPaletteY[512]);
      errorPaletteV = &(ditherPaletteY[640]);
    }
    for (int i = 0; i < 128; i++) {
      FLIConverter::convertPlus4Color(i, ditherPaletteY[i], ditherPaletteU[i],
                                      ditherPaletteV[i], monitorGamma * 0.625);
      FLIConverter::convertPlus4Color(i, errorPaletteY[i], errorPaletteU[i],
                                      errorPaletteV[i], monitorGamma * 0.44);
    }
  }

  void P4FLI_MultiColorNoFLI::createErrorTable(double colorErrorScale)
  {
    limitValue(colorErrorScale, 0.05, 1.0);
    for (int c0 = 0; c0 < 128; c0++) {
      for (int c1 = 0; c1 < 128; c1++) {
        errorTable[(c0 << 7) | c1] =
            calculateYUVErrorSqr(
                errorPaletteY[c0], errorPaletteU[c0], errorPaletteV[c0],
                errorPaletteY[c1], errorPaletteU[c1], errorPaletteV[c1],
                colorErrorScale);
      }
    }
  }

  int P4FLI_MultiColorNoFLI::findNearestColor(
      float y, float u, float v,
      const float *paletteY, const float *paletteU, const float *paletteV)
  {
    int     l = 0;
    int     c = 0;
    if (!luminance1BitMode) {
      double  minErr = 1000000.0;
      for (int i = 0; i < 9; i++) {
        float   y_ = paletteY[(i != 0 ? (((i - 1) << 4) + 1) : 0)];
        double  err = calculateErrorSqr(y, y_);
        if (err < minErr) {
          l = i;
          minErr = err;
        }
      }
    }
    else {
      l = (y < 0.5f ? 0 : 8);
    }
    if (l != 0) {
      double  minErr = 1000000.0;
      for (int i = 1; i < 16; i++) {
        double  err = calculateErrorSqr(u, paletteU[i + 64])
                      + calculateErrorSqr(v, paletteV[i + 64]);
        if (err < minErr) {
          c = i;
          minErr = err;
        }
      }
    }
    return ((l != 0 ? ((l - 1) << 4) : 0) + c);
  }

  void P4FLI_MultiColorNoFLI::ditherLine(long yc)
  {
    if (ditherMode < 2) {
      // ordered dithering
      float   luminanceTable[9];
      float   luminanceTable_[9];
      float   hueTable[15];
      int     hueIndexTable[15];
      for (int i = 0; i < 9; i++) {
        luminanceTable[i] = ditherPaletteY[(i == 0 ? 0 : (((i - 1) << 4) + 1))];
        luminanceTable_[i] = errorPaletteY[(i == 0 ? 0 : (((i - 1) << 4) + 1))];
      }
      for (int i = 0; i < 14; i++) {
        float   u = ditherPaletteU[66 + i];
        float   v = ditherPaletteV[66 + i];
        double  phs = std::atan2(double(v), double(u)) / (2.0 * 3.14159265);
        if (phs < 0.0)
          phs = phs + 1.0;
        hueTable[i] = float(phs);
        hueIndexTable[i] = i;
      }
      for (int i = 0; i < 14; i++) {
        for (int j = i + 1; j < 14; j++) {
          if (hueTable[j] < hueTable[i]) {
            {
              float   tmp = hueTable[i];
              hueTable[i] = hueTable[j];
              hueTable[j] = tmp;
            }
            {
              int     tmp = hueIndexTable[i];
              hueIndexTable[i] = hueIndexTable[j];
              hueIndexTable[j] = tmp;
            }
          }
        }
      }
      hueTable[14] = hueTable[0] + 1.0f;
      hueIndexTable[14] = hueIndexTable[0];
      const int *ditherTable_ = &(ditherTable[0]);
      if (ditherMode == 0)
        ditherTable_ = &(ditherTable_Bayer[0]);
      for (long xc = 0L; xc < 160L; xc++) {
        float   y = resizedImage.y()[yc].getPixel(xc);
        float   y_ = float(std::pow(double(y), 0.704));
        float   u = resizedImage.u()[yc].getPixel(xc);
        float   v = resizedImage.v()[yc].getPixel(xc);
        float   s = float(std::sqrt(double(u * u) + double(v * v)));
        float   h = float(std::atan2(double(v), double(u)));
        s = s / FLIConverter::defaultColorSaturation;
        h = h / (2.0f * 3.14159265f);
        if (h < 0.0f)
          h = h + 1.0f;
        int     li0 = 0;
        int     li1 = 8;
        if (!luminance1BitMode) {
          while (y > luminanceTable[li0 + 1] && li0 < 7)
            li0++;
          li1 = li0 + 1;
        }
        if (calculateError(calculateError(y_, luminanceTable_[li0]),
                           calculateError(y_, luminanceTable_[li1]))
            >= ditherLimit) {
          if (calculateError(y_, luminanceTable_[li0])
              > calculateError(y_, luminanceTable_[li1])) {
            li0 = li1;
          }
        }
        else {
          float   f = (y - luminanceTable[li0])
                      / (luminanceTable[li1] - luminanceTable[li0]);
          if (ditherPixelValue(xc, yc, f, ditherTable_))
            li0 = li1;
        }
        int     si = 0;
        if (ditherPixelValue(xc, yc, s, ditherTable_))
          si++;
        int     hi = 0;
        if (h < hueTable[0])    // special case for hue wrap-around
          h = h + 1.0f;
        while (h > hueTable[hi + 1] && hi < 13)
          hi++;
        float   f = (h - hueTable[hi]) / (hueTable[hi + 1] - hueTable[hi]);
        f = f * s;              // adjust value for saturation dithering
        if (ditherPixelValue(xc, yc, f, ditherTable_))
          hi++;
        hi = hueIndexTable[hi];
        ditheredImage[yc * 160L + xc] =
            (li0 == 0 ? 0 : ((si == 0 ? 1 : (hi + 2)) + ((li0 - 1) << 4)));
      }
      return;
    }
    // error diffusion dithering
    for (long xc = 0L; xc < 160L; xc++) {
      if (yc & 1L)
        xc = 159L - xc;
      // find the palette color nearest the original pixel
      float   y0 = resizedImage.y()[yc].getPixel(xc);
      float   y0_ = float(std::pow(double(y0), 0.704));
      float   u0 = resizedImage.u()[yc].getPixel(xc);
      float   v0 = resizedImage.v()[yc].getPixel(xc);
      int     c0 =
          findNearestColor(y0_, u0, v0,
                           errorPaletteY, errorPaletteU, errorPaletteV);
      // find the palette color nearest the original pixel with error added
      float   y = y0 + ditherErrorImage.y()[yc].getPixel(xc);
      float   u = u0 + ditherErrorImage.u()[yc].getPixel(xc);
      float   v = v0 + ditherErrorImage.v()[yc].getPixel(xc);
      y = (y > 0.0f ? (y < 1.0f ? y : 1.0f) : 0.0f);
      {
        float   tmp = float(std::sqrt(double(u * u) + double(v * v)));
        if (tmp > FLIConverter::defaultColorSaturation) {
          tmp = FLIConverter::defaultColorSaturation / tmp;
          u = u * tmp;
          v = v * tmp;
        }
      }
      int     c =
          findNearestColor(y, u, v,
                           ditherPaletteY, ditherPaletteU, ditherPaletteV);
      double  err0 = std::sqrt(calculateYUVErrorSqr(errorPaletteY[c0],
                                                    errorPaletteU[c0],
                                                    errorPaletteV[c0],
                                                    y0_, u0, v0, 0.125));
      double  err = std::sqrt(calculateYUVErrorSqr(errorPaletteY[c],
                                                   errorPaletteU[c],
                                                   errorPaletteV[c],
                                                   y0_, u0, v0, 0.125));
      ditheredImage[yc * 160L + xc] =
          (calculateError(err, err0) < ditherLimit ? c : c0);
      y = y0 + ((y - y0) * float(ditherScale));
      u = u0 + ((u - u0) * float(ditherScale));
      v = v0 + ((v - v0) * float(ditherScale));
      float   errY = y - ditherPaletteY[c];
      float   errU = u - ditherPaletteU[c];
      float   errV = v - ditherPaletteV[c];
      const int *errMultTbl = &(ditherTable_FloydSteinberg[0]);
      switch (ditherMode) {
      case 3:
        errMultTbl = &(ditherTable_Jarvis[0]);
        break;
      case 4:
        errMultTbl = &(ditherTable_Stucki[0]);
        break;
      case 5:
        errMultTbl = &(ditherTable_Sierra2[0]);
        break;
      }
      for (int i = 0; i < 12; i++) {
        if (errMultTbl[i + 1] == 0)
          continue;
        long    yc_ = yc + ((i + 3) / 5);
        long    xc_ = ((i + 3) % 5) - 2;
        xc_ = ((yc & 1L) == 0L ? (xc + xc_) : (xc - xc_));
        if (yc_ >= 0L && yc_ < 200L && xc_ >= 0L && xc_ < 160L) {
          float   errMult = float(errMultTbl[i + 1]) / float(errMultTbl[0]);
          ditherErrorImage.y()[yc_].setPixel(
              xc_, ditherErrorImage.y()[yc_].getPixel(xc_) + (errY * errMult));
          ditherErrorImage.u()[yc_].setPixel(
              xc_, ditherErrorImage.u()[yc_].getPixel(xc_) + (errU * errMult));
          ditherErrorImage.v()[yc_].setPixel(
              xc_, ditherErrorImage.v()[yc_].getPixel(xc_) + (errV * errMult));
        }
      }
      if (yc & 1L)
        xc = 159L - xc;
    }
  }

  bool P4FLI_MultiColorNoFLI::convertImage(PRGData& prgData, double& totalError)
  {
    totalError = 0.0;
    int     color0 = 0x00;
    int     color3 = 0x71;
    // find the color indexes used in each attribute block area
    std::vector< AttrBlock4x8 >
        attrBlocks(1000, AttrBlock4x8(errorTable, color0, color3));
    for (int yc = 0; yc < 200; yc++) {
      for (int xc = 0; xc < 160; xc++) {
        int     n = ((yc >> 3) * 40) + (xc >> 2);
        attrBlocks[n].addPixel(ditheredImage[yc * 160 + xc]);
      }
    }
    // find the set of colors that needs to be searched for optimal conversion
    std::vector< int >  colorTable0;                    // for color #0 and #3
    std::vector< std::vector< int > >   colorTables;    // for color #1 and #2
    colorTables.resize(1000);
    {
      float   minY0 = 1.0f;
      float   maxY0 = 0.0f;
      float   minU0 = 1.0f;
      float   maxU0 = -1.0f;
      float   minV0 = 1.0f;
      float   maxV0 = -1.0f;
      for (int i = 0; i < 1000; i++) {
        float   minY = 1.0f;
        float   maxY = 0.0f;
        float   minU = 1.0f;
        float   maxU = -1.0f;
        float   minV = 1.0f;
        float   maxV = -1.0f;
        for (int j = 0; j < attrBlocks[i].nColors; j++) {
          float   y = errorPaletteY[attrBlocks[i].pixelColorCodes[j]];
          float   u = errorPaletteU[attrBlocks[i].pixelColorCodes[j]];
          float   v = errorPaletteV[attrBlocks[i].pixelColorCodes[j]];
          minY = (y < minY ? y : minY);
          maxY = (y > maxY ? y : maxY);
          minU = (u < minU ? u : minU);
          maxU = (u > maxU ? u : maxU);
          minV = (v < minV ? v : minV);
          maxV = (v > maxV ? v : maxV);
          if (attrBlocks[i].nColors > 2) {
            minY0 = (y < minY0 ? y : minY0);
            maxY0 = (y > maxY0 ? y : maxY0);
            minU0 = (u < minU0 ? u : minU0);
            maxU0 = (u > maxU0 ? u : maxU0);
            minV0 = (v < minV0 ? v : minV0);
            maxV0 = (v > maxV0 ? v : maxV0);
          }
        }
        if (minV < 0.0f && maxV > 0.0f) {
          if (minU < 0.0f)
            minU = -(FLIConverter::defaultColorSaturation);
          if (maxU > 0.0f)
            maxU = FLIConverter::defaultColorSaturation;
        }
        if (minU < 0.0f && maxU > 0.0f) {
          if (minV < 0.0f)
            minV = -(FLIConverter::defaultColorSaturation);
          if (maxV > 0.0f)
            maxV = FLIConverter::defaultColorSaturation;
        }
        minY = minY - 0.0001f;
        maxY = maxY + 0.0001f;
        minU = minU - 0.0001f;
        maxU = maxU + 0.0001f;
        minV = minV - 0.0001f;
        maxV = maxV + 0.0001f;
        for (int j = 0; j < 128; j++) {
          if (j > 0 && (j & 15) == 0)
            continue;
          float   y = errorPaletteY[j];
          float   u = errorPaletteU[j];
          float   v = errorPaletteV[j];
          if (y > minY && y < maxY &&
              ((j & 15) == 1 ||
               (u > minU && u < maxU && v > minV && v < maxV))) {
            colorTables[i].push_back(j);
          }
        }
      }
      if (minV0 < 0.0f && maxV0 > 0.0f) {
        if (minU0 < 0.0f)
          minU0 = -(FLIConverter::defaultColorSaturation);
        if (maxU0 > 0.0f)
          maxU0 = FLIConverter::defaultColorSaturation;
      }
      if (minU0 < 0.0f && maxU0 > 0.0f) {
        if (minV0 < 0.0f)
          minV0 = -(FLIConverter::defaultColorSaturation);
        if (maxV0 > 0.0f)
          maxV0 = FLIConverter::defaultColorSaturation;
      }
      minY0 = minY0 - 0.0001f;
      maxY0 = maxY0 + 0.0001f;
      minU0 = minU0 - 0.0001f;
      maxU0 = maxU0 + 0.0001f;
      minV0 = minV0 - 0.0001f;
      maxV0 = maxV0 + 0.0001f;
      for (int j = 0; j < 128; j++) {
        if (j > 0 && (j & 15) == 0)
          continue;
        float   y = errorPaletteY[j];
        float   u = errorPaletteU[j];
        float   v = errorPaletteV[j];
        if (y > minY0 && y < maxY0 &&
            ((j & 15) == 1 ||
             (u > minU0 && u < maxU0 && v > minV0 && v < maxV0))) {
          colorTable0.push_back(j);
        }
      }
    }
    // optimize attributes and color registers
    for (int i = 0; i < 1000; i++) {
      attrBlocks[i].color1 = attrBlocks[i].pixelColorCodes[0];
      attrBlocks[i].color2 = attrBlocks[i].pixelColorCodes[1];
    }
    std::vector< int >  colorCnts(128);
    if (conversionQuality < 16) {
      double  bestErr = 1000000.0;
      int     bestColors[2];
      bestColors[0] = color0;
      bestColors[1] = color3;
      int     randomSeed = 0;
      Plus4Emu::setRandomSeed(randomSeed, 1U);
      for (int l = 0; l < (conversionQuality * 2); l++) {
        if (!setProgressPercentage(((l * 80) / (conversionQuality * 2)) + 20))
          return false;
        // set initial palette with different methods, and choose the one
        // that results in the least error after optimization
        for (int i = 0; i < 128; i++)
          colorCnts[i] = 0;
        for (int i = 0; i < 1000; i++) {
          int     nColors = attrBlocks[i].nColors;
          if (nColors <= 2) {
            attrBlocks[i].color1 = attrBlocks[i].pixelColorCodes[0];
            attrBlocks[i].color2 = attrBlocks[i].pixelColorCodes[1];
          }
          else {
            switch (l) {
            case 0:
              attrBlocks[i].color1 = attrBlocks[i].pixelColorCodes[nColors - 1];
              attrBlocks[i].color2 = attrBlocks[i].pixelColorCodes[nColors - 2];
              break;
            case 1:
              attrBlocks[i].color1 = attrBlocks[i].pixelColorCodes[0];
              attrBlocks[i].color2 = attrBlocks[i].pixelColorCodes[1];
              break;
            case 2:
              attrBlocks[i].color1 = attrBlocks[i].pixelColorCodes[0];
              attrBlocks[i].color2 = attrBlocks[i].pixelColorCodes[nColors - 1];
              break;
            case 3:
              {
                attrBlocks[i].color1 = attrBlocks[i].pixelColorCodes[0];
                double  maxErr = 0.0;
                for (int j = 1; j < nColors; j++) {
                  double  err =
                      errorTable[(attrBlocks[i].color1 << 7)
                                 | (attrBlocks[i].pixelColorCodes[j])];
                  if (err >= maxErr) {
                    attrBlocks[i].color2 = attrBlocks[i].pixelColorCodes[j];
                    maxErr = err;
                  }
                }
              }
              break;
            case 4:
              attrBlocks[i].color1 = 0x00;
              attrBlocks[i].color2 = 0x00;
              break;
            case 5:
              attrBlocks[i].color1 = 0x71;
              attrBlocks[i].color2 = 0x71;
              break;
            default:
              attrBlocks[i].color1 =
                  colorTables[i][Plus4Emu::getRandomNumber(randomSeed)
                                 % int(colorTables[i].size())];
              attrBlocks[i].color2 =
                  colorTables[i][Plus4Emu::getRandomNumber(randomSeed)
                                 % int(colorTables[i].size())];
              break;
            }
            for (int j = 0; j < nColors; j++) {
              int     c = attrBlocks[i].pixelColorCodes[j];
              if (c != attrBlocks[i].color1 && c != attrBlocks[i].color2)
                colorCnts[c] = colorCnts[c] + attrBlocks[i].pixelColorCounts[j];
            }
          }
        }
        if (l == 4) {
          color0 = 0x71;
          color3 = 0x71;
        }
        else if (l == 5) {
          color0 = 0x00;
          color3 = 0x00;
        }
        else if (l < 6 || colorTable0.size() < 1) {
          int     maxCnt1 = 0;
          int     maxCnt2 = 0;
          for (int i = 0; i < 128; i++) {
            if (colorCnts[i] > maxCnt1) {
              maxCnt2 = maxCnt1;
              color3 = color0;
              maxCnt1 = colorCnts[i];
              color0 = i;
            }
            else if (colorCnts[i] > maxCnt2) {
              maxCnt2 = colorCnts[i];
              color3 = i;
            }
          }
        }
        else {
          color0 = colorTable0[Plus4Emu::getRandomNumber(randomSeed)
                               % int(colorTable0.size())];
          color3 = colorTable0[Plus4Emu::getRandomNumber(randomSeed)
                               % int(colorTable0.size())];
        }
        // optimize attributes and color registers
        double  prvErr = 1000000.0;
        for (int i = 7; i >= 0; i--) {
          // color #0 (FF15)
          double  minErr = prvErr;
          int     bestColor = color0;
          for (size_t j = 0; j < colorTable0.size(); j++) {
            color0 = colorTable0[j];
            double  err = 0.0;
            for (int k = 0; k < 1000; k++) {
              if (attrBlocks[k].nColors <= 2)
                continue;
              err += attrBlocks[k].calculateError();
              if (err > (minErr * 1.000001))
                break;
            }
            if (err < minErr) {
              bestColor = color0;
              minErr = err;
            }
          }
          color0 = bestColor;
          // color #3 (FF16)
          bestColor = color3;
          for (size_t j = 0; j < colorTable0.size(); j++) {
            color3 = colorTable0[j];
            double  err = 0.0;
            for (int k = 0; k < 1000; k++) {
              if (attrBlocks[k].nColors <= 2)
                continue;
              err += attrBlocks[k].calculateError();
              if (err > (minErr * 1.000001))
                break;
            }
            if (err < minErr) {
              bestColor = color3;
              minErr = err;
            }
          }
          color3 = bestColor;
          // color #1 and color #2
          double  err = 0.0;
          for (int k = 0; k < 1000; k++) {
            if (attrBlocks[k].nColors <= 2)
              continue;
            // color #1 and color #2
            double  minErr2 = 1000000.0;
            int     bestColor1 = attrBlocks[k].color1;
            int     bestColor2 = attrBlocks[k].color2;
            for (size_t c1i = 0; c1i < colorTables[k].size(); c1i++) {
              for (size_t c2i = c1i + 1; c2i < colorTables[k].size(); c2i++) {
                attrBlocks[k].color1 = colorTables[k][c1i];
                attrBlocks[k].color2 = colorTables[k][c2i];
                double  err2 = attrBlocks[k].calculateError();
                if (err2 < minErr2) {
                  bestColor1 = attrBlocks[k].color1;
                  bestColor2 = attrBlocks[k].color2;
                  minErr2 = err2;
                }
              }
            }
            attrBlocks[k].color1 = bestColor1;
            attrBlocks[k].color2 = bestColor2;
            err += minErr2;
          }
          // quit the optimization loop earlier
          // if the error could not be reduced
          if (err >= (prvErr * 0.99999999)) {
            prvErr = err;
            break;
          }
          prvErr = err;
        }
        if (prvErr < bestErr) {
          bestColors[0] = color0;
          bestColors[1] = color3;
          bestErr = prvErr;
        }
      }
      color0 = bestColors[0];
      color3 = bestColors[1];
    }
    else {
      // optimize attributes and color registers
      for (int i = 0; i < 128; i++)
        colorCnts[i] = 0;
      for (int i = 0; i < 1000; i++) {
        if (attrBlocks[i].nColors <= 2)
          continue;
        for (int j = 0; j < attrBlocks[i].nColors; j++)
          colorCnts[attrBlocks[i].pixelColorCodes[j]]++;
      }
      int     maxCnt = 0;
      for (int i = 0; i < 128; i++) {
        if (colorCnts[i] > maxCnt) {
          color3 = i;
          maxCnt = colorCnts[i];
        }
      }
      int     progressCnt = int(colorTable0.size());
      int     progressMax = int(colorTable0.size()) * 5;
      if (!setProgressPercentage(20))
        return false;
      for (int i = 0; i < 2; i++) {
        // color #0 (FF15)
        double  minErr = 1000000.0;
        int     bestColor0 = color0;
        for (size_t c0i = 0; c0i < colorTable0.size(); c0i++) {
          if (!setProgressPercentage(progressCnt * 100 / progressMax))
            return false;
          progressCnt++;
          color0 = colorTable0[c0i];
          double  err = 0.0;
          for (int k = 0; k < 1000; k++) {
            if (attrBlocks[k].nColors <= 2)
              continue;
            // color #1 and color #2
            double  minErr2 = 1000000.0;
            int     bestColor1 = attrBlocks[k].color1;
            int     bestColor2 = attrBlocks[k].color2;
            for (size_t c1i = 0; c1i < colorTables[k].size(); c1i++) {
              for (size_t c2i = c1i + 1; c2i < colorTables[k].size(); c2i++) {
                attrBlocks[k].color1 = colorTables[k][c1i];
                attrBlocks[k].color2 = colorTables[k][c2i];
                double  err2 = attrBlocks[k].calculateError();
                if (err2 < minErr2) {
                  bestColor1 = attrBlocks[k].color1;
                  bestColor2 = attrBlocks[k].color2;
                  minErr2 = err2;
                }
              }
            }
            attrBlocks[k].color1 = bestColor1;
            attrBlocks[k].color2 = bestColor2;
            err = err + minErr2;
            if (err > (minErr * 1.000001))
              break;
          }
          if (err < minErr) {
            bestColor0 = color0;
            minErr = err;
          }
        }
        color0 = bestColor0;
        // color #3 (FF16)
        minErr = 1000000.0;
        int     bestColor3 = color3;
        for (size_t c3i = 0; c3i < colorTable0.size(); c3i++) {
          if (!setProgressPercentage(progressCnt * 100 / progressMax))
            return false;
          progressCnt++;
          color3 = colorTable0[c3i];
          double  err = 0.0;
          for (int k = 0; k < 1000; k++) {
            if (attrBlocks[k].nColors <= 2)
              continue;
            // color #1 and color #2
            double  minErr2 = 1000000.0;
            int     bestColor1 = attrBlocks[k].color1;
            int     bestColor2 = attrBlocks[k].color2;
            for (size_t c1i = 0; c1i < colorTables[k].size(); c1i++) {
              for (size_t c2i = c1i + 1; c2i < colorTables[k].size(); c2i++) {
                attrBlocks[k].color1 = colorTables[k][c1i];
                attrBlocks[k].color2 = colorTables[k][c2i];
                double  err2 = attrBlocks[k].calculateError();
                if (err2 < minErr2) {
                  bestColor1 = attrBlocks[k].color1;
                  bestColor2 = attrBlocks[k].color2;
                  minErr2 = err2;
                }
              }
            }
            attrBlocks[k].color1 = bestColor1;
            attrBlocks[k].color2 = bestColor2;
            err = err + minErr2;
            if (err > (minErr * 1.000001))
              break;
          }
          if (err < minErr) {
            bestColor3 = color3;
            minErr = err;
          }
        }
        color3 = bestColor3;
      }
    }
    for (int k = 0; k < 1000; k++) {
      if (attrBlocks[k].nColors <= 2)
        continue;
      // color #1 and color #2
      double  minErr = 1000000.0;
      int     bestColor1 = attrBlocks[k].color1;
      int     bestColor2 = attrBlocks[k].color2;
      for (size_t c1i = 0; c1i < colorTables[k].size(); c1i++) {
        for (size_t c2i = c1i + 1; c2i < colorTables[k].size(); c2i++) {
          attrBlocks[k].color1 = colorTables[k][c1i];
          attrBlocks[k].color2 = colorTables[k][c2i];
          double  err = attrBlocks[k].calculateError();
          if (err < minErr) {
            bestColor1 = attrBlocks[k].color1;
            bestColor2 = attrBlocks[k].color2;
            minErr = err;
          }
        }
      }
      attrBlocks[k].color1 = bestColor1;
      attrBlocks[k].color2 = bestColor2;
    }
    // store the attributes and color registers
    prgData[0x7BFE - 0x0FFF] =
        (unsigned char) (((color3 & 0x70) >> 4) | ((color3 & 0x0F) << 4));
    prgData[0x7BFF - 0x0FFF] =
        (unsigned char) (((color0 & 0x70) >> 4) | ((color0 & 0x0F) << 4));
    for (int i = 0; i < 1000; i++) {
      int     l0 = (attrBlocks[i].color2 >> 4) & 0x07;
      int     l1 = (attrBlocks[i].color1 >> 4) & 0x07;
      int     c0 = attrBlocks[i].color2 & 0x0F;
      int     c1 = attrBlocks[i].color1 & 0x0F;
      if (c0 != 0)
        l0++;
      else
        l0 = 0;
      if (c1 != 0)
        l1++;
      else
        l1 = 0;
      prgData.l0((i % 40) * 8, (i / 40) * 16) = l0;
      prgData.c0((i % 40) * 8, (i / 40) * 16) = c0;
      prgData.l1((i % 40) * 8, (i / 40) * 16) = l1;
      prgData.c1((i % 40) * 8, (i / 40) * 16) = c1;
    }
    // generate bitmaps
    for (int yc = 0; yc < 200; yc++) {
      for (int xc = 0; xc < 160; xc++) {
        int     n = ((yc >> 3) * 40) + (xc >> 2);
        int     c = ditheredImage[yc * 160 + xc];
        int     ci = 0;
        double  minErr = errorTable[(c << 7) | color0];
        double  err = errorTable[(c << 7) | attrBlocks[n].color1];
        if (err < minErr) {
          ci = 1;
          minErr = err;
        }
        err = errorTable[(c << 7) | attrBlocks[n].color2];
        if (err < minErr) {
          ci = 2;
          minErr = err;
        }
        err = errorTable[(c << 7) | color3];
        if (err < minErr)
          ci = 3;
        prgData.setPixel((xc << 1) + 0, yc << 1, bool(ci & 2));
        prgData.setPixel((xc << 1) + 1, yc << 1, bool(ci & 1));
      }
    }
    // return the total amount of error
    for (int i = 0; i < 1000; i++)
      totalError += attrBlocks[i].calculateError();
    return true;
  }

  void P4FLI_MultiColorNoFLI::optimizeAttributes(PRGData& prgData)
  {
    bool    mcFlag =
        prgData[0x7BFA - 0x0FFF] == 0x4D && prgData[0x7BFB - 0x0FFF] == 0x55 &&
        prgData[0x7BFC - 0x0FFF] == 0x4C && prgData[0x7BFD - 0x0FFF] == 0x54;
    for (int k = 0; k < 2; k++) {
      for (int yc = 0; yc < 25; yc++) {
        for (int xc = 0; xc < 40; xc++) {
          // make the use of attribute values more consistent for easier
          // editing of the output file
          if (k != 0) {
            // scan backwards on second pass
            xc = 39 - xc;
            yc = 24 - yc;
          }
          int     addr = ((yc * 40) + xc) + (0x7800 - 0x0FFF);
          int     l = prgData[addr];
          int     c = prgData[addr + 0x0400];
          int     c0 = (l & 0x70) | (c & 0x0F);
          int     c1 = ((l & 0x07) << 4) | ((c & 0xF0) >> 4);
          int     c00Cnt = 0;
          int     c01Cnt = 0;
          int     c10Cnt = 0;
          int     c11Cnt = 0;
          for (int i = 0; i < 4; i++) {
            int     xc_ = (i % 3) - 1;
            int     yc_ = (i / 3) - 1;
            if (k == 0) {
              xc_ = xc + xc_;
              yc_ = yc + yc_;
            }
            else {
              xc_ = xc - xc_;
              yc_ = yc - yc_;
            }
            if (xc_ >= 0 && xc_ < 40 && yc_ >= 0 && yc_ < 25) {
              int     addr_ = ((yc_ * 40) + xc_) + (0x7800 - 0x0FFF);
              int     l_ = prgData[addr_];
              int     c_ = prgData[addr_ + 0x0400];
              int     c0_ = (l_ & 0x70) | (c_ & 0x0F);
              int     c1_ = ((l_ & 0x07) << 4) | ((c_ & 0xF0) >> 4);
              if (c0 == c0_)
                c00Cnt++;
              if (c0 == c1_)
                c01Cnt++;
              if (c1 == c0_)
                c10Cnt++;
              if (c1 == c1_)
                c11Cnt++;
            }
          }
          if (((c01Cnt - c00Cnt) + (c10Cnt - c11Cnt)) > 0) {
            // swap colors
            prgData[addr] =
                (unsigned char) (((l & 0x07) << 4) | ((l & 0x70) >> 4));
            prgData[addr + 0x0400] =
                (unsigned char) (((c & 0x0F) << 4) | ((c & 0xF0) >> 4));
            for (int i = 0; i < 8; i++) {
              unsigned char&  b = prgData[((addr - (0x7800 - 0x0FFF)) << 3) + i
                                          + (0x8000 - 0x0FFF)];
              if (mcFlag)
                b = ((b & 0x55) << 1) | ((b & 0xAA) >> 1);
              else
                b = b ^ 0xFF;
            }
          }
          if (k != 0) {
            xc = 39 - xc;
            yc = 24 - yc;
          }
        }
      }
    }
  }

  bool P4FLI_MultiColorNoFLI::processImage(PRGData& prgData,
                                           unsigned int& prgEndAddr,
                                           const char *infileName,
                                           YUVImageConverter& imgConv,
                                           Plus4Emu::ConfigurationDB& config)
  {
    try {
      monitorGamma = config["monitorGamma"];
      ditherLimit = config["ditherLimit"];
      ditherScale = config["ditherDiffusion"];
      ditherMode = config["ditherMode"];
      borderColor = config["borderColor"];
      conversionQuality = config["multiColorQuality"];
      luminance1BitMode = config["luminance1BitMode"];
      checkParameters();
      initializePalettes();
      createErrorTable(double(config["mcColorErrorScale"]));
      prgData.setConversionType(7);
      prgData.clear();
      prgData.borderColor() = (unsigned char) borderColor;
      for (int yc = 0; yc < 200; yc++) {
        resizedImage.y()[yc].clear();
        resizedImage.u()[yc].clear();
        resizedImage.v()[yc].clear();
        ditherErrorImage.y()[yc].clear();
        ditherErrorImage.u()[yc].clear();
        ditherErrorImage.v()[yc].clear();
      }
      imgConv.setImageSize(640, 400);
      imgConv.setPixelAspectRatio(1.0f);
      imgConv.setPixelStoreCallback(&pixelStoreCallback, (void *) this);
      imgConv.convertImageFile(infileName);
      for (int yc = 0; yc < 200; yc++) {
        for (int xc = 0; xc < 160; xc++) {
          limitYUVColor(resizedImage.y()[yc][xc],
                        resizedImage.u()[yc][xc],
                        resizedImage.v()[yc][xc]);
        }
      }
      // convert input image to 121 colors with dithering
      progressMessage("Calculating FLI data");
      for (int yc = 0; yc < 200; yc++) {
        if (!setProgressPercentage(yc * 20 / 200)) {
          prgData[0] = 0x01;
          prgData[1] = 0x10;
          prgData[2] = 0x00;
          prgData[3] = 0x00;
          prgEndAddr = 0x1003U;
          progressMessage("");
          return false;
        }
        ditherLine(yc);
      }
      // generate FLI data
      double  totalError = 0.0;
      if (!convertImage(prgData, totalError)) {
        prgData[0] = 0x01;
        prgData[1] = 0x10;
        prgData[2] = 0x00;
        prgData[3] = 0x00;
        prgEndAddr = 0x1003U;
        progressMessage("");
        return false;
      }
      setProgressPercentage(100);
      progressMessage("");
      {
        char    tmpBuf[64];
        totalError = std::sqrt(totalError / double(160 * 200));
        std::sprintf(&(tmpBuf[0]), "Done, RMS error = %.4f", totalError);
        progressMessage(&(tmpBuf[0]));
      }
      // write PRG output
      prgData.convertImageData();
      optimizeAttributes(prgData);
      prgEndAddr = prgData.getImageDataEndAddress();
    }
    catch (...) {
      prgData[0] = 0x01;
      prgData[1] = 0x10;
      prgData[2] = 0x00;
      prgData[3] = 0x00;
      prgEndAddr = 0x1003U;
      progressMessage("");
      throw;
    }
    return true;
  }

}       // namespace Plus4FLIConv

