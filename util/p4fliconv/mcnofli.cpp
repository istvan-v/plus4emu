
// p4fliconv: high resolution interlaced FLI converter utility
// Copyright (C) 2007-2008 Istvan Varga <istvanv@users.sourceforge.net>
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// The Plus/4 program files generated by this utility are not covered by the
// GNU General Public License, and can be used, modified, and distributed
// without any restrictions.

#include "p4fliconv.hpp"
#include "dither.hpp"
#include "imageconv.hpp"
#include "prgdata.hpp"
#include "mcnofli.hpp"

static const unsigned char prgHeader_160x200[0x00C1] = {
  0x01, 0x10, 0x0C, 0x10, 0x0A, 0x00, 0x9E, 0x20, 0x34, 0x31, 0x31, 0x32,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0xD8, 0xA2, 0xFF, 0x9A, 0x8D, 0x3E,
  0xFF, 0x8D, 0xD0, 0xFD, 0x20, 0x9D, 0x10, 0x20, 0x84, 0xFF, 0xAD, 0xF9,
  0x7B, 0x8D, 0x19, 0xFF, 0xA9, 0x3B, 0x8D, 0x06, 0xFF, 0xAD, 0x07, 0xFF,
  0x29, 0x40, 0x09, 0x18, 0x8D, 0x07, 0xFF, 0xA9, 0xE0, 0x8D, 0x12, 0xFF,
  0xA9, 0x78, 0x8D, 0x14, 0xFF, 0xAD, 0xFF, 0x7B, 0x4A, 0x4A, 0x4A, 0x4A,
  0x8D, 0x15, 0xFF, 0xAD, 0xFF, 0x7B, 0x0A, 0x0A, 0x0A, 0x0A, 0x0D, 0x15,
  0xFF, 0x8D, 0x15, 0xFF, 0xAD, 0xFE, 0x7B, 0x4A, 0x4A, 0x4A, 0x4A, 0x8D,
  0x16, 0xFF, 0xAD, 0xFE, 0x7B, 0x0A, 0x0A, 0x0A, 0x0A, 0x0D, 0x16, 0xFF,
  0x8D, 0x16, 0xFF, 0x20, 0xB2, 0x10, 0x78, 0xA2, 0x00, 0x20, 0x9D, 0x10,
  0x8A, 0x48, 0x20, 0xB5, 0x10, 0x68, 0xAA, 0xA9, 0x7F, 0x8D, 0x30, 0xFD,
  0x8D, 0x08, 0xFF, 0xAD, 0x08, 0xFF, 0x29, 0x10, 0xF0, 0x03, 0xAA, 0xD0,
  0xE4, 0x8A, 0xF0, 0xE1, 0x78, 0x8D, 0x3E, 0xFF, 0x8D, 0xD0, 0xFD, 0x6C,
  0xBE, 0x10, 0x2C, 0x07, 0xFF, 0x70, 0x03, 0xA9, 0xFA, 0x2C, 0xA9, 0xE1,
  0xCD, 0x1D, 0xFF, 0xD0, 0xFB, 0xCD, 0x1D, 0xFF, 0xF0, 0xFB, 0x60, 0x6C,
  0xBA, 0x10, 0x6C, 0xBC, 0x10, 0x00, 0x00, 0xAC, 0x10, 0xAC, 0x10, 0x10,
  0x10
};

namespace Plus4FLIConv {

  P4FLI_MultiColorNoFLI::Line160::Line160()
  {
    buf = new float[192];
    for (size_t i = 0; i < 192; i++)
      buf[i] = 0.0f;
  }

  P4FLI_MultiColorNoFLI::Line160::Line160(const Line160& r)
  {
    buf = new float[192];
    for (size_t i = 0; i < 192; i++)
      buf[i] = r.buf[i];
  }

  P4FLI_MultiColorNoFLI::Line160::~Line160()
  {
    delete[] buf;
  }

  P4FLI_MultiColorNoFLI::Line160&
      P4FLI_MultiColorNoFLI::Line160::operator=(const Line160& r)
  {
    for (size_t i = 0; i < 192; i++)
      buf[i] = r.buf[i];
    return (*this);
  }

  void P4FLI_MultiColorNoFLI::Line160::clear()
  {
    for (size_t i = 16; i < 176; i++)
      buf[i] = 0.0f;
  }

  void P4FLI_MultiColorNoFLI::Line160::setBorderColor(float c)
  {
    for (size_t i = 0; i < 16; i++) {
      buf[i] = c;
      buf[i + 176] = c;
    }
  }

  // --------------------------------------------------------------------------

  P4FLI_MultiColorNoFLI::Image160x200::Image160x200()
  {
    buf = new Line160[200];
  }

  P4FLI_MultiColorNoFLI::Image160x200::Image160x200(const Image160x200& r)
  {
    buf = new Line160[200];
    for (size_t i = 0; i < 200; i++)
      buf[i] = r.buf[i];
  }

  P4FLI_MultiColorNoFLI::Image160x200&
      P4FLI_MultiColorNoFLI::Image160x200::operator=(const Image160x200& r)
  {
    for (size_t i = 0; i < 200; i++)
      buf[i] = r.buf[i];
    return (*this);
  }

  P4FLI_MultiColorNoFLI::Image160x200::~Image160x200()
  {
    delete[] buf;
  }

  // --------------------------------------------------------------------------

  P4FLI_MultiColorNoFLI::YUVImage160x200::YUVImage160x200()
  {
  }

  P4FLI_MultiColorNoFLI::YUVImage160x200::YUVImage160x200(
      const YUVImage160x200& r)
    : imageY(r.imageY),
      imageU(r.imageU),
      imageV(r.imageV)
  {
  }

  P4FLI_MultiColorNoFLI::YUVImage160x200::~YUVImage160x200()
  {
  }

  P4FLI_MultiColorNoFLI::YUVImage160x200&
      P4FLI_MultiColorNoFLI::YUVImage160x200::operator=(
          const YUVImage160x200& r)
  {
    imageY = r.imageY;
    imageU = r.imageU;
    imageV = r.imageV;
    return (*this);
  }

  // --------------------------------------------------------------------------

  P4FLI_MultiColorNoFLI::P4FLI_MultiColorNoFLI()
    : monitorGamma(1.33),
      ditherLimit(0.125),
      ditherScale(0.75),
      ditherMode(0),
      borderColor(0x00),
      conversionQuality(6),
      luminance1BitMode(false),
      ditheredImage((int *) 0),
      errorTable((double *) 0)
  {
    try {
      ditheredImage = new int[160 * 200];
      errorTable = new double[128 * 128];
      for (int i = 0; i < (160 * 200); i++)
        ditheredImage[i] = 0;
      for (int i = 0; i < (128 * 128); i++)
        errorTable[i] = 0.0;
    }
    catch (...) {
      if (ditheredImage)
        delete[] ditheredImage;
      if (errorTable)
        delete[] errorTable;
      throw;
    }
  }

  P4FLI_MultiColorNoFLI::~P4FLI_MultiColorNoFLI()
  {
    delete[] ditheredImage;
    delete[] errorTable;
  }

  void P4FLI_MultiColorNoFLI::pixelStoreCallback(void *userData, int xc, int yc,
                                                 float y, float u, float v)
  {
    P4FLI_MultiColorNoFLI&  this_ =
        *(reinterpret_cast<P4FLI_MultiColorNoFLI *>(userData));
    float   c = float(std::sqrt(double(u * u) + double(v * v)));
    if (c > FLIConverter::defaultColorSaturation) {
      u = u * FLIConverter::defaultColorSaturation / c;
      v = v * FLIConverter::defaultColorSaturation / c;
    }
    this_.resizedImage.y()[yc >> 1][xc >> 2] += (y * 0.125f);
    this_.resizedImage.u()[yc >> 1][xc >> 2] += (u * 0.125f);
    this_.resizedImage.v()[yc >> 1][xc >> 2] += (v * 0.125f);
  }

  void P4FLI_MultiColorNoFLI::checkParameters()
  {
    limitValue(monitorGamma, 0.25, 4.0);
    limitValue(ditherLimit, 0.0, 2.0);
    limitValue(ditherScale, 0.0, 1.0);
    limitValue(ditherMode, 0, 3);
    borderColor = (borderColor & 0x7F) | 0x80;
    limitValue(conversionQuality, 1, 20);
  }

  P4FLI_MultiColorNoFLI::AttrBlock4x8::AttrBlock4x8(const double *errorTable_,
                                                    int& color0_, int& color3_)
    : errorTable(errorTable_),
      color0(color0_),
      color3(color3_),
      color1(0x00),
      color2(0x00),
      nColors(0)
  {
    for (int i = 0; i < 32; i++) {
      pixelColorCodes[i] = 0x00;
      pixelColorCounts[i] = 0;
    }
  }

  P4FLI_MultiColorNoFLI::AttrBlock4x8::AttrBlock4x8(const AttrBlock4x8& r)
    : errorTable(r.errorTable),
      color0(r.color0),
      color3(r.color3),
      color1(r.color1),
      color2(r.color2),
      nColors(r.nColors)
  {
    for (int i = 0; i < 32; i++) {
      pixelColorCodes[i] = r.pixelColorCodes[i];
      pixelColorCounts[i] = r.pixelColorCounts[i];
    }
  }

  void P4FLI_MultiColorNoFLI::AttrBlock4x8::addPixel(int c)
  {
    c = c & 0x7F;
    if ((c & 0x0F) == 0)
      c = 0x00;
    {
      int     i = 0;
      while (i < nColors) {
        if (pixelColorCodes[i] == c) {
          pixelColorCounts[i]++;
          break;
        }
        i++;
      }
      if (i >= nColors) {
        pixelColorCodes[nColors] = c;
        pixelColorCounts[nColors] = 1;
        nColors++;
      }
    }
    for (int i = 0; i < nColors; i++) {
      for (int j = i + 1; j < nColors; j++) {
        if (pixelColorCounts[j] > pixelColorCounts[i]) {
          int     tmp = pixelColorCodes[i];
          pixelColorCodes[i] = pixelColorCodes[j];
          pixelColorCodes[j] = tmp;
          tmp = pixelColorCounts[i];
          pixelColorCounts[i] = pixelColorCounts[j];
          pixelColorCounts[j] = tmp;
        }
      }
    }
  }

  inline double P4FLI_MultiColorNoFLI::AttrBlock4x8::calculateError() const
  {
    double  totalErr = 0.0;
    for (int i = 0; i < nColors; i++) {
      int     c = pixelColorCodes[i];
      double  minErr = errorTable[(c << 7) | color0];
      double  err = errorTable[(c << 7) | color1];
      if (err < minErr)
        minErr = err;
      err = errorTable[(c << 7) | color2];
      if (err < minErr)
        minErr = err;
      err = errorTable[(c << 7) | color3];
      if (err < minErr)
        minErr = err;
      totalErr += (minErr * double(pixelColorCounts[i]));
    }
    return totalErr;
  }

  void P4FLI_MultiColorNoFLI::createErrorTable(double colorErrorScale)
  {
    limitValue(colorErrorScale, 0.05, 1.0);
    for (int c0 = 0; c0 < 128; c0++) {
      float   c0y = 0.0f;
      float   c0u = 0.0f;
      float   c0v = 0.0f;
      FLIConverter::convertPlus4Color(c0, c0y, c0u, c0v, monitorGamma);
      for (int c1 = 0; c1 < 128; c1++) {
        float   c1y = 0.0f;
        float   c1u = 0.0f;
        float   c1v = 0.0f;
        FLIConverter::convertPlus4Color(c1, c1y, c1u, c1v, monitorGamma);
        errorTable[(c0 << 7) | c1] =
            calculateErrorSqr(c0y, c1y)
            + (calculateErrorSqr(c0u, c1u) * colorErrorScale)
            + (calculateErrorSqr(c0v, c1v) * colorErrorScale);
      }
    }
  }

  void P4FLI_MultiColorNoFLI::ditherLine(long yc)
  {
    float   paletteY[128];
    float   paletteU[128];
    float   paletteV[128];
    for (int i = 0; i < 128; i++) {
      FLIConverter::convertPlus4Color(i, paletteY[i], paletteU[i], paletteV[i],
                                      monitorGamma);
    }
    if (ditherMode == 0) {
      // ordered dithering
      float   luminanceTable[9];
      float   hueTable[15];
      int     hueIndexTable[15];
      for (int i = 0; i < 9; i++)
        luminanceTable[i] = paletteY[(i == 0 ? 0 : (((i - 1) << 4) + 1))];
      for (int i = 0; i < 14; i++) {
        float   u = paletteU[66 + i];
        float   v = paletteV[66 + i];
        double  phs = std::atan2(double(v), double(u)) / (2.0 * 3.14159265);
        if (phs < 0.0)
          phs = phs + 1.0;
        hueTable[i] = float(phs);
        hueIndexTable[i] = i;
      }
      for (int i = 0; i < 14; i++) {
        for (int j = i + 1; j < 14; j++) {
          if (hueTable[j] < hueTable[i]) {
            {
              float   tmp = hueTable[i];
              hueTable[i] = hueTable[j];
              hueTable[j] = tmp;
            }
            {
              int     tmp = hueIndexTable[i];
              hueIndexTable[i] = hueIndexTable[j];
              hueIndexTable[j] = tmp;
            }
          }
        }
      }
      hueTable[14] = hueTable[0] + 1.0f;
      hueIndexTable[14] = hueIndexTable[0];
      for (long xc = 0L; xc < 160L; xc++) {
        float   y = resizedImage.y()[yc].getPixel(xc);
        float   u = resizedImage.u()[yc].getPixel(xc);
        float   v = resizedImage.v()[yc].getPixel(xc);
        float   s = float(std::sqrt(double(u * u) + double(v * v)));
        float   h = float(std::atan2(double(v), double(u)));
        h = h / (2.0f * 3.14159265f);
        if (h < 0.0f)
          h = h + 1.0f;
        int     li0 = 0;
        int     li1 = 8;
        if (!luminance1BitMode) {
          while (y > luminanceTable[li0 + 1] && li0 < 7)
            li0++;
          li1 = li0 + 1;
        }
        if (calculateError(calculateError(y, luminanceTable[li0]),
                           calculateError(y, luminanceTable[li1]))
            >= ditherLimit) {
          if (calculateError(y, luminanceTable[li0])
              > calculateError(y, luminanceTable[li1])) {
            li0 = li1;
          }
        }
        else {
          float   f = (y - luminanceTable[li0])
                      / (luminanceTable[li1] - luminanceTable[li0]);
          if (ditherPixelValue(xc, yc, f))
            li0 = li1;
        }
        int     si = 0;
        if (ditherPixelValue(xc, yc, s / FLIConverter::defaultColorSaturation))
          si++;
        int     hi = 0;
        if (h < hueTable[0])    // special case for hue wrap-around
          h = h + 1.0f;
        while (h > hueTable[hi + 1] && hi < 13)
          hi++;
        float   f = (h - hueTable[hi]) / (hueTable[hi + 1] - hueTable[hi]);
        if (ditherPixelValue(xc, yc, f))
          hi++;
        hi = hueIndexTable[hi];
        ditheredImage[yc * 160L + xc] =
            (li0 == 0 ? 0 : ((si == 0 ? 1 : (hi + 2)) + ((li0 - 1) << 4)));
      }
      return;
    }
    // error diffusion dithering
    for (long xc = 0L; xc < 160L; xc++) {
      if (yc & 1L)
        xc = 159L - xc;
      // find the palette color nearest the original pixel
      float   y0 = resizedImage.y()[yc].getPixel(xc);
      float   u0 = resizedImage.u()[yc].getPixel(xc);
      float   v0 = resizedImage.v()[yc].getPixel(xc);
      int     c0 = 0;
      double  minErr0 = 1000000.0;
      for (int i = (luminance1BitMode ? 112 : 0); i < 128; i++) {
        double  err = calculateErrorSqr(paletteY[i], y0)
                      + (calculateErrorSqr(paletteU[i], u0) * 0.0625)
                      + (calculateErrorSqr(paletteV[i], v0) * 0.0625);
        if (err < minErr0) {
          c0 = i;
          minErr0 = err;
        }
      }
      // find the palette color nearest the original pixel with error added
      float   y = y0 + ditherErrorImage.y()[yc].getPixel(xc);
      float   u = u0 + ditherErrorImage.u()[yc].getPixel(xc);
      float   v = v0 + ditherErrorImage.v()[yc].getPixel(xc);
      y = (y > 0.0f ? (y < 1.0f ? y : 1.0f) : 0.0f);
      {
        float   tmp = float(std::sqrt(double(u * u) + double(v * v)));
        if (tmp > FLIConverter::defaultColorSaturation) {
          tmp = FLIConverter::defaultColorSaturation / tmp;
          u = u * tmp;
          v = v * tmp;
        }
      }
      int     c = 0;
      double  minErr = 1000000.0;
      for (int i = (luminance1BitMode ? 112 : 0); i < 128; i++) {
        double  err = calculateErrorSqr(paletteY[i], y)
                      + (calculateErrorSqr(paletteU[i], u) * 0.0625)
                      + (calculateErrorSqr(paletteV[i], v) * 0.0625);
        if (err < minErr) {
          c = i;
          minErr = err;
        }
      }
      if (calculateError(
              std::sqrt(minErr0),
              std::sqrt(calculateErrorSqr(paletteY[c], y0)
                        + (calculateErrorSqr(paletteU[c], u0) * 0.0625)
                        + (calculateErrorSqr(paletteV[c], v0) * 0.0625)))
          < ditherLimit) {
        ditheredImage[yc * 160L + xc] = c;
      }
      else {
        ditheredImage[yc * 160L + xc] = c0;
      }
      y = y0 + ((y - y0) * float(ditherScale));
      u = u0 + ((u - u0) * float(ditherScale));
      v = v0 + ((v - v0) * float(ditherScale));
      float   errY = y - paletteY[c];
      float   errU = u - paletteU[c];
      float   errV = v - paletteV[c];
      if (ditherMode == 1) {
        // Floyd-Steinberg dithering
        static const int    xOffsTbl[4] = { 1, -1, 0, 1 };
        static const int    yOffsTbl[4] = { 0, 1, 1, 1 };
        static const float  errMultTbl[4] = {
          0.4375f, 0.1875f, 0.3125f, 0.0625f
        };
        for (int i = 0; i < 4; i++) {
          long    yc_ = yc + yOffsTbl[i];
          long    xc_ = xOffsTbl[i];
          xc_ = ((yc & 1L) == 0L ? (xc + xc_) : (xc - xc_));
          if (yc_ >= 0L && yc_ < 200L && xc_ >= 0L && xc_ < 160L) {
            float   errMult = errMultTbl[i];
            ditherErrorImage.y()[yc_].setPixel(
                xc_,
                ditherErrorImage.y()[yc_].getPixel(xc_) + (errY * errMult));
            ditherErrorImage.u()[yc_].setPixel(
                xc_,
                ditherErrorImage.u()[yc_].getPixel(xc_) + (errU * errMult));
            ditherErrorImage.v()[yc_].setPixel(
                xc_,
                ditherErrorImage.v()[yc_].getPixel(xc_) + (errV * errMult));
          }
        }
      }
      else if (ditherMode == 2) {
        // Jarvis dithering
        for (int i = 0; i < 3; i++) {
          for (int j = (i == 0 ? 1 : -2); j < 3; j++) {
            if (yc & 1L)
              j = (-j);
            long    yc_ = yc + i;
            long    xc_ = xc + j;
            if (yc_ >= 0L && yc_ < 200L && xc_ >= 0L && xc_ < 160L) {
              float   errMult = (4.5f - float(i + (j >= 0 ? j : (-j)))) / 24.0f;
              ditherErrorImage.y()[yc_].setPixel(
                  xc_,
                  ditherErrorImage.y()[yc_].getPixel(xc_) + (errY * errMult));
              ditherErrorImage.u()[yc_].setPixel(
                  xc_,
                  ditherErrorImage.u()[yc_].getPixel(xc_) + (errU * errMult));
              ditherErrorImage.v()[yc_].setPixel(
                  xc_,
                  ditherErrorImage.v()[yc_].getPixel(xc_) + (errV * errMult));
            }
            if (yc & 1L)
              j = (-j);
          }
        }
      }
      else {
        // Stucki dithering
        for (int i = 0; i < 3; i++) {
          for (int j = (i == 0 ? 1 : -2); j < 3; j++) {
            if (yc & 1L)
              j = (-j);
            long    yc_ = yc + i;
            long    xc_ = xc + j;
            if (yc_ >= 0L && yc_ < 200L && xc_ >= 0L && xc_ < 160L) {
              float   errMult = float(16 >> (i + (j >= 0 ? j : (-j)))) / 42.0f;
              ditherErrorImage.y()[yc_].setPixel(
                  xc_,
                  ditherErrorImage.y()[yc_].getPixel(xc_) + (errY * errMult));
              ditherErrorImage.u()[yc_].setPixel(
                  xc_,
                  ditherErrorImage.u()[yc_].getPixel(xc_) + (errU * errMult));
              ditherErrorImage.v()[yc_].setPixel(
                  xc_,
                  ditherErrorImage.v()[yc_].getPixel(xc_) + (errV * errMult));
            }
            if (yc & 1L)
              j = (-j);
          }
        }
      }
      if (yc & 1L)
        xc = 159L - xc;
    }
  }

  bool P4FLI_MultiColorNoFLI::convertImage(PRGData& prgData, double& totalError)
  {
    totalError = 0.0;
    // clear PRG data
    for (size_t i = 0x0000; i < 0x00C1; i++)
      prgData[i] = prgHeader_160x200[i];
    for (size_t i = 0x00C1; i < 0x8F41; i++)
      prgData[i] = 0x00;
    int     color0 = 0x00;
    int     color3 = 0x71;
    // find the color indexes used in each attribute block area
    std::vector< AttrBlock4x8 >
        attrBlocks(1000, AttrBlock4x8(errorTable, color0, color3));
    for (int yc = 0; yc < 200; yc++) {
      for (int xc = 0; xc < 160; xc++) {
        int     n = ((yc >> 3) * 40) + (xc >> 2);
        attrBlocks[n].addPixel(ditheredImage[yc * 160 + xc]);
      }
    }
    std::vector< float >  paletteY(128);
    std::vector< float >  paletteU(128);
    std::vector< float >  paletteV(128);
    for (int i = 0; i < 128; i++) {
      FLIConverter::convertPlus4Color(i, paletteY[i], paletteU[i], paletteV[i],
                                      monitorGamma);
    }
    // find the set of colors that needs to be searched for optimal conversion
    std::vector< int >  colorTable0;                    // for color #0 and #3
    std::vector< std::vector< int > >   colorTables;    // for color #1 and #2
    colorTables.resize(1000);
    {
      float   minY0 = 1.0f;
      float   maxY0 = 0.0f;
      float   minU0 = 1.0f;
      float   maxU0 = -1.0f;
      float   minV0 = 1.0f;
      float   maxV0 = -1.0f;
      for (int i = 0; i < 1000; i++) {
        float   minY = 1.0f;
        float   maxY = 0.0f;
        float   minU = 1.0f;
        float   maxU = -1.0f;
        float   minV = 1.0f;
        float   maxV = -1.0f;
        for (int j = 0; j < attrBlocks[i].nColors; j++) {
          float   y = paletteY[attrBlocks[i].pixelColorCodes[j]];
          float   u = paletteU[attrBlocks[i].pixelColorCodes[j]];
          float   v = paletteV[attrBlocks[i].pixelColorCodes[j]];
          minY = (y < minY ? y : minY);
          maxY = (y > maxY ? y : maxY);
          minU = (u < minU ? u : minU);
          maxU = (u > maxU ? u : maxU);
          minV = (v < minV ? v : minV);
          maxV = (v > maxV ? v : maxV);
          if (attrBlocks[i].nColors > 2) {
            minY0 = (y < minY0 ? y : minY0);
            maxY0 = (y > maxY0 ? y : maxY0);
            minU0 = (u < minU0 ? u : minU0);
            maxU0 = (u > maxU0 ? u : maxU0);
            minV0 = (v < minV0 ? v : minV0);
            maxV0 = (v > maxV0 ? v : maxV0);
          }
        }
        if (minV < 0.0f && maxV > 0.0f) {
          if (minU < 0.0f)
            minU = -(FLIConverter::defaultColorSaturation);
          if (maxU > 0.0f)
            maxU = FLIConverter::defaultColorSaturation;
        }
        if (minU < 0.0f && maxU > 0.0f) {
          if (minV < 0.0f)
            minV = -(FLIConverter::defaultColorSaturation);
          if (maxV > 0.0f)
            maxV = FLIConverter::defaultColorSaturation;
        }
        minY = minY - 0.0001f;
        maxY = maxY + 0.0001f;
        minU = minU - 0.0001f;
        maxU = maxU + 0.0001f;
        minV = minV - 0.0001f;
        maxV = maxV + 0.0001f;
        for (int j = 0; j < 128; j++) {
          if (j > 0 && (j & 15) == 0)
            continue;
          float   y = paletteY[j];
          float   u = paletteU[j];
          float   v = paletteV[j];
          if (y > minY && y < maxY &&
              u > minU && u < maxU &&
              v > minV && v < maxV) {
            colorTables[i].push_back(j);
          }
        }
      }
      if (minV0 < 0.0f && maxV0 > 0.0f) {
        if (minU0 < 0.0f)
          minU0 = -(FLIConverter::defaultColorSaturation);
        if (maxU0 > 0.0f)
          maxU0 = FLIConverter::defaultColorSaturation;
      }
      if (minU0 < 0.0f && maxU0 > 0.0f) {
        if (minV0 < 0.0f)
          minV0 = -(FLIConverter::defaultColorSaturation);
        if (maxV0 > 0.0f)
          maxV0 = FLIConverter::defaultColorSaturation;
      }
      minY0 = minY0 - 0.0001f;
      maxY0 = maxY0 + 0.0001f;
      minU0 = minU0 - 0.0001f;
      maxU0 = maxU0 + 0.0001f;
      minV0 = minV0 - 0.0001f;
      maxV0 = maxV0 + 0.0001f;
      for (int j = 0; j < 128; j++) {
        if (j > 0 && (j & 15) == 0)
          continue;
        float   y = paletteY[j];
        float   u = paletteU[j];
        float   v = paletteV[j];
        if (y > minY0 && y < maxY0 &&
            u > minU0 && u < maxU0 &&
            v > minV0 && v < maxV0) {
          colorTable0.push_back(j);
        }
      }
    }
    // optimize attributes and color registers
    for (int i = 0; i < 1000; i++) {
      attrBlocks[i].color1 = attrBlocks[i].pixelColorCodes[0];
      attrBlocks[i].color2 = attrBlocks[i].pixelColorCodes[1];
    }
    std::vector< int >  colorCnts(128);
    if (conversionQuality < 10) {
      double  bestErr = 1000000.0;
      int     bestColors[2];
      bestColors[0] = color0;
      bestColors[1] = color3;
      int     randomSeed = 0;
      Plus4Emu::setRandomSeed(randomSeed, 1U);
      for (int l = 0; l < (conversionQuality * 2); l++) {
        if (!setProgressPercentage(((l * 80) / (conversionQuality * 2)) + 20))
          return false;
        // set initial palette with different methods, and choose the one
        // that results in the least error after optimization
        for (int i = 0; i < 128; i++)
          colorCnts[i] = 0;
        for (int i = 0; i < 1000; i++) {
          int     nColors = attrBlocks[i].nColors;
          if (nColors <= 2) {
            attrBlocks[i].color1 = attrBlocks[i].pixelColorCodes[0];
            attrBlocks[i].color2 = attrBlocks[i].pixelColorCodes[1];
          }
          else {
            switch (l) {
            case 0:
              attrBlocks[i].color1 = attrBlocks[i].pixelColorCodes[nColors - 1];
              attrBlocks[i].color2 = attrBlocks[i].pixelColorCodes[nColors - 2];
              break;
            case 1:
              attrBlocks[i].color1 = attrBlocks[i].pixelColorCodes[0];
              attrBlocks[i].color2 = attrBlocks[i].pixelColorCodes[1];
              break;
            case 2:
              attrBlocks[i].color1 = attrBlocks[i].pixelColorCodes[0];
              attrBlocks[i].color2 = attrBlocks[i].pixelColorCodes[nColors - 1];
              break;
            case 3:
              {
                attrBlocks[i].color1 = attrBlocks[i].pixelColorCodes[0];
                double  maxErr = 0.0;
                for (int j = 1; j < nColors; j++) {
                  double  err =
                      errorTable[(attrBlocks[i].color1 << 7)
                                 | (attrBlocks[i].pixelColorCodes[j])];
                  if (err >= maxErr) {
                    attrBlocks[i].color2 = attrBlocks[i].pixelColorCodes[j];
                    maxErr = err;
                  }
                }
              }
              break;
            case 4:
              attrBlocks[i].color1 = 0x00;
              attrBlocks[i].color2 = 0x00;
              break;
            case 5:
              attrBlocks[i].color1 = 0x71;
              attrBlocks[i].color2 = 0x71;
              break;
            default:
              attrBlocks[i].color1 =
                  colorTables[i][Plus4Emu::getRandomNumber(randomSeed)
                                 % int(colorTables[i].size())];
              attrBlocks[i].color2 =
                  colorTables[i][Plus4Emu::getRandomNumber(randomSeed)
                                 % int(colorTables[i].size())];
              break;
            }
            for (int j = 0; j < nColors; j++) {
              int     c = attrBlocks[i].pixelColorCodes[j];
              if (c != attrBlocks[i].color1 && c != attrBlocks[i].color2)
                colorCnts[c] = colorCnts[c] + attrBlocks[i].pixelColorCounts[j];
            }
          }
        }
        if (l == 4) {
          color0 = 0x71;
          color3 = 0x71;
        }
        else if (l == 5) {
          color0 = 0x00;
          color3 = 0x00;
        }
        else if (l < 6 || colorTable0.size() < 1) {
          int     maxCnt1 = 0;
          int     maxCnt2 = 0;
          for (int i = 0; i < 128; i++) {
            if (colorCnts[i] > maxCnt1) {
              maxCnt2 = maxCnt1;
              color3 = color0;
              maxCnt1 = colorCnts[i];
              color0 = i;
            }
            else if (colorCnts[i] > maxCnt2) {
              maxCnt2 = colorCnts[i];
              color3 = i;
            }
          }
        }
        else {
          color0 = colorTable0[Plus4Emu::getRandomNumber(randomSeed)
                               % int(colorTable0.size())];
          color3 = colorTable0[Plus4Emu::getRandomNumber(randomSeed)
                               % int(colorTable0.size())];
        }
        // optimize attributes and color registers
        double  prvErr = 1000000.0;
        for (int i = 7; i >= 0; i--) {
          // color #0 (FF15)
          double  minErr = 1000000.0;
          int     bestColor = color0;
          for (size_t j = 0; j < colorTable0.size(); j++) {
            color0 = colorTable0[j];
            double  err = 0.0;
            for (int k = 0; k < 1000; k++) {
              if (attrBlocks[k].nColors <= 2)
                continue;
              err += attrBlocks[k].calculateError();
              if (err > (minErr * 1.000001))
                break;
            }
            if (err < minErr) {
              bestColor = color0;
              minErr = err;
            }
          }
          color0 = bestColor;
          // color #3 (FF16)
          minErr = 1000000.0;
          bestColor = color3;
          for (size_t j = 0; j < colorTable0.size(); j++) {
            color3 = colorTable0[j];
            double  err = 0.0;
            for (int k = 0; k < 1000; k++) {
              if (attrBlocks[k].nColors <= 2)
                continue;
              err += attrBlocks[k].calculateError();
              if (err > (minErr * 1.000001))
                break;
            }
            if (err < minErr) {
              bestColor = color3;
              minErr = err;
            }
          }
          color3 = bestColor;
          // color #1 and color #2
          double  err = 0.0;
          for (int k = 0; k < 1000; k++) {
            if (attrBlocks[k].nColors <= 2)
              continue;
            // color #1 and color #2
            double  minErr2 = 1000000.0;
            int     bestColor1 = attrBlocks[k].color1;
            int     bestColor2 = attrBlocks[k].color2;
            for (size_t c1i = 0; c1i < colorTables[k].size(); c1i++) {
              for (size_t c2i = c1i + 1; c2i < colorTables[k].size(); c2i++) {
                attrBlocks[k].color1 = colorTables[k][c1i];
                attrBlocks[k].color2 = colorTables[k][c2i];
                double  err2 = attrBlocks[k].calculateError();
                if (err2 < minErr2) {
                  bestColor1 = attrBlocks[k].color1;
                  bestColor2 = attrBlocks[k].color2;
                  minErr2 = err2;
                }
              }
            }
            attrBlocks[k].color1 = bestColor1;
            attrBlocks[k].color2 = bestColor2;
            err += minErr2;
          }
          // quit the optimization loop earlier
          // if the error could not be reduced
          if (err >= (prvErr * 0.99999999)) {
            prvErr = err;
            break;
          }
          prvErr = err;
        }
        if (prvErr < bestErr) {
          bestColors[0] = color0;
          bestColors[1] = color3;
          bestErr = prvErr;
        }
      }
      color0 = bestColors[0];
      color3 = bestColors[1];
    }
    else {
      // optimize attributes and color registers
      for (int i = 0; i < 128; i++)
        colorCnts[i] = 0;
      for (int i = 0; i < 1000; i++) {
        if (attrBlocks[i].nColors <= 2)
          continue;
        for (int j = 0; j < attrBlocks[i].nColors; j++)
          colorCnts[attrBlocks[i].pixelColorCodes[j]]++;
      }
      int     maxCnt = 0;
      for (int i = 0; i < 128; i++) {
        if (colorCnts[i] > maxCnt) {
          color3 = i;
          maxCnt = colorCnts[i];
        }
      }
      int     progressCnt = int(colorTable0.size());
      int     progressMax = int(colorTable0.size()) * 5;
      if (!setProgressPercentage(20))
        return false;
      for (int i = 0; i < 2; i++) {
        // color #0 (FF15)
        double  minErr = 1000000.0;
        int     bestColor0 = color0;
        for (size_t c0i = 0; c0i < colorTable0.size(); c0i++) {
          if (!setProgressPercentage(progressCnt * 100 / progressMax))
            return false;
          progressCnt++;
          color0 = colorTable0[c0i];
          double  err = 0.0;
          for (int k = 0; k < 1000; k++) {
            if (attrBlocks[k].nColors <= 2)
              continue;
            // color #1 and color #2
            double  minErr2 = 1000000.0;
            int     bestColor1 = attrBlocks[k].color1;
            int     bestColor2 = attrBlocks[k].color2;
            for (size_t c1i = 0; c1i < colorTables[k].size(); c1i++) {
              for (size_t c2i = c1i + 1; c2i < colorTables[k].size(); c2i++) {
                attrBlocks[k].color1 = colorTables[k][c1i];
                attrBlocks[k].color2 = colorTables[k][c2i];
                double  err2 = attrBlocks[k].calculateError();
                if (err2 < minErr2) {
                  bestColor1 = attrBlocks[k].color1;
                  bestColor2 = attrBlocks[k].color2;
                  minErr2 = err2;
                }
              }
            }
            attrBlocks[k].color1 = bestColor1;
            attrBlocks[k].color2 = bestColor2;
            err = err + minErr2;
            if (err > (minErr * 1.000001))
              break;
          }
          if (err < minErr) {
            bestColor0 = color0;
            minErr = err;
          }
        }
        color0 = bestColor0;
        // color #3 (FF16)
        minErr = 1000000.0;
        int     bestColor3 = color3;
        for (size_t c3i = 0; c3i < colorTable0.size(); c3i++) {
          if (!setProgressPercentage(progressCnt * 100 / progressMax))
            return false;
          progressCnt++;
          color3 = colorTable0[c3i];
          double  err = 0.0;
          for (int k = 0; k < 1000; k++) {
            if (attrBlocks[k].nColors <= 2)
              continue;
            // color #1 and color #2
            double  minErr2 = 1000000.0;
            int     bestColor1 = attrBlocks[k].color1;
            int     bestColor2 = attrBlocks[k].color2;
            for (size_t c1i = 0; c1i < colorTables[k].size(); c1i++) {
              for (size_t c2i = c1i + 1; c2i < colorTables[k].size(); c2i++) {
                attrBlocks[k].color1 = colorTables[k][c1i];
                attrBlocks[k].color2 = colorTables[k][c2i];
                double  err2 = attrBlocks[k].calculateError();
                if (err2 < minErr2) {
                  bestColor1 = attrBlocks[k].color1;
                  bestColor2 = attrBlocks[k].color2;
                  minErr2 = err2;
                }
              }
            }
            attrBlocks[k].color1 = bestColor1;
            attrBlocks[k].color2 = bestColor2;
            err = err + minErr2;
            if (err > (minErr * 1.000001))
              break;
          }
          if (err < minErr) {
            bestColor3 = color3;
            minErr = err;
          }
        }
        color3 = bestColor3;
      }
    }
    for (int k = 0; k < 1000; k++) {
      if (attrBlocks[k].nColors <= 2)
        continue;
      // color #1 and color #2
      double  minErr = 1000000.0;
      int     bestColor1 = attrBlocks[k].color1;
      int     bestColor2 = attrBlocks[k].color2;
      for (size_t c1i = 0; c1i < colorTables[k].size(); c1i++) {
        for (size_t c2i = c1i + 1; c2i < colorTables[k].size(); c2i++) {
          attrBlocks[k].color1 = colorTables[k][c1i];
          attrBlocks[k].color2 = colorTables[k][c2i];
          double  err = attrBlocks[k].calculateError();
          if (err < minErr) {
            bestColor1 = attrBlocks[k].color1;
            bestColor2 = attrBlocks[k].color2;
            minErr = err;
          }
        }
      }
      attrBlocks[k].color1 = bestColor1;
      attrBlocks[k].color2 = bestColor2;
    }
    // store the attributes and color registers
    prgData[0x7BF9 - 0x0FFF] = (unsigned char) borderColor;
    prgData[0x7BFA - 0x0FFF] = 0x4D;    // 'M'
    prgData[0x7BFB - 0x0FFF] = 0x55;    // 'U'
    prgData[0x7BFC - 0x0FFF] = 0x4C;    // 'L'
    prgData[0x7BFD - 0x0FFF] = 0x54;    // 'T'
    prgData[0x7BFE - 0x0FFF] =
        (unsigned char) (((color3 & 0x70) >> 4) | ((color3 & 0x0F) << 4));
    prgData[0x7BFF - 0x0FFF] =
        (unsigned char) (((color0 & 0x70) >> 4) | ((color0 & 0x0F) << 4));
    for (int i = 0; i < 1000; i++) {
      int     l0 = (attrBlocks[i].color2 >> 4) & 0x07;
      int     l1 = (attrBlocks[i].color1 >> 4) & 0x07;
      int     c0 = attrBlocks[i].color2 & 0x0F;
      int     c1 = attrBlocks[i].color1 & 0x0F;
      prgData[(0x7800 | i) - 0x0FFF] = (unsigned char) ((l0 << 4) | l1);
      prgData[(0x7C00 | i) - 0x0FFF] = (unsigned char) (c0 | (c1 << 4));
    }
    // generate bitmaps
    for (int yc = 0; yc < 200; yc++) {
      for (int xc = 0; xc < 160; xc++) {
        int     n = ((yc >> 3) * 40) + (xc >> 2);
        int     c = ditheredImage[yc * 160 + xc];
        int     ci = 0;
        double  minErr = errorTable[(c << 7) | color0];
        double  err = errorTable[(c << 7) | attrBlocks[n].color1];
        if (err < minErr) {
          ci = 1;
          minErr = err;
        }
        err = errorTable[(c << 7) | attrBlocks[n].color2];
        if (err < minErr) {
          ci = 2;
          minErr = err;
        }
        err = errorTable[(c << 7) | color3];
        if (err < minErr)
          ci = 3;
        n = ((n << 3) | (yc & 7) | 0x8000) - 0x0FFF;
        prgData[n] &= (unsigned char) ((3 << ((3 - (xc & 3)) << 1)) ^ 0xFF);
        prgData[n] |= (unsigned char) (ci << ((3 - (xc & 3)) << 1));
      }
    }
    // return the total amount of error
    for (int i = 0; i < 1000; i++)
      totalError += attrBlocks[i].calculateError();
    return true;
  }

  void P4FLI_MultiColorNoFLI::optimizeAttributes(PRGData& prgData)
  {
    bool    mcFlag =
        prgData[0x7BFA - 0x0FFF] == 0x4D && prgData[0x7BFB - 0x0FFF] == 0x55 &&
        prgData[0x7BFC - 0x0FFF] == 0x4C && prgData[0x7BFD - 0x0FFF] == 0x54;
    for (int k = 0; k < 2; k++) {
      for (int yc = 0; yc < 25; yc++) {
        for (int xc = 0; xc < 40; xc++) {
          // make the use of attribute values more consistent for easier
          // editing of the output file
          if (k != 0) {
            // scan backwards on second pass
            xc = 39 - xc;
            yc = 24 - yc;
          }
          int     addr = ((yc * 40) + xc) + (0x7800 - 0x0FFF);
          int     l = prgData[addr];
          int     c = prgData[addr + 0x0400];
          int     c0 = (l & 0x70) | (c & 0x0F);
          int     c1 = ((l & 0x07) << 4) | ((c & 0xF0) >> 4);
          int     c00Cnt = 0;
          int     c01Cnt = 0;
          int     c10Cnt = 0;
          int     c11Cnt = 0;
          for (int i = 0; i < 4; i++) {
            int     xc_ = (i % 3) - 1;
            int     yc_ = (i / 3) - 1;
            if (k == 0) {
              xc_ = xc + xc_;
              yc_ = yc + yc_;
            }
            else {
              xc_ = xc - xc_;
              yc_ = yc - yc_;
            }
            if (xc_ >= 0 && xc_ < 40 && yc_ >= 0 && yc_ < 25) {
              int     addr_ = ((yc_ * 40) + xc_) + (0x7800 - 0x0FFF);
              int     l_ = prgData[addr_];
              int     c_ = prgData[addr_ + 0x0400];
              int     c0_ = (l_ & 0x70) | (c_ & 0x0F);
              int     c1_ = ((l_ & 0x07) << 4) | ((c_ & 0xF0) >> 4);
              if (c0 == c0_)
                c00Cnt++;
              if (c0 == c1_)
                c01Cnt++;
              if (c1 == c0_)
                c10Cnt++;
              if (c1 == c1_)
                c11Cnt++;
            }
          }
          if (((c01Cnt - c00Cnt) + (c10Cnt - c11Cnt)) > 0) {
            // swap colors
            prgData[addr] =
                (unsigned char) (((l & 0x07) << 4) | ((l & 0x70) >> 4));
            prgData[addr + 0x0400] =
                (unsigned char) (((c & 0x0F) << 4) | ((c & 0xF0) >> 4));
            for (int i = 0; i < 8; i++) {
              unsigned char&  b = prgData[((addr - (0x7800 - 0x0FFF)) << 3) + i
                                          + (0x8000 - 0x0FFF)];
              if (mcFlag)
                b = ((b & 0x55) << 1) | ((b & 0xAA) >> 1);
              else
                b = b ^ 0xFF;
            }
          }
          if (k != 0) {
            xc = 39 - xc;
            yc = 24 - yc;
          }
        }
      }
    }
  }

  bool P4FLI_MultiColorNoFLI::processImage(PRGData& prgData,
                                           unsigned int& prgEndAddr,
                                           const char *infileName,
                                           YUVImageConverter& imgConv,
                                           Plus4Emu::ConfigurationDB& config)
  {
    try {
      monitorGamma = config["monitorGamma"];
      ditherLimit = config["ditherLimit"];
      ditherScale = config["ditherDiffusion"];
      ditherMode = config["ditherMode"];
      borderColor = config["borderColor"];
      conversionQuality = config["multiColorQuality"];
      luminance1BitMode = config["luminance1BitMode"];
      checkParameters();
      createErrorTable(double(config["mcColorErrorScale"]));
      float   borderY = 0.0f;
      float   borderU = 0.0f;
      float   borderV = 0.0f;
      FLIConverter::convertPlus4Color(borderColor, borderY, borderU, borderV,
                                      monitorGamma);
      prgData.clear();
      prgData.borderColor() = (unsigned char) borderColor;
      prgData.setVerticalSize(200);
      prgData.interlaceFlags() = 0x00;
      for (int yc = 0; yc < 200; yc++) {
        resizedImage.y()[yc].clear();
        resizedImage.y()[yc].setBorderColor(borderY);
        resizedImage.u()[yc].clear();
        resizedImage.u()[yc].setBorderColor(borderU);
        resizedImage.v()[yc].clear();
        resizedImage.v()[yc].setBorderColor(borderV);
        ditherErrorImage.y()[yc].clear();
        ditherErrorImage.u()[yc].clear();
        ditherErrorImage.v()[yc].clear();
      }
      imgConv.setImageSize(640, 400);
      imgConv.setPixelAspectRatio(1.0f);
      imgConv.setPixelStoreCallback(&pixelStoreCallback, (void *) this);
      imgConv.convertImageFile(infileName);
      // convert input image to 121 colors with dithering
      progressMessage("Calculating FLI data");
      for (int yc = 0; yc < 200; yc++) {
        if (!setProgressPercentage(yc * 20 / 200)) {
          prgData[0] = 0x01;
          prgData[1] = 0x10;
          prgData[2] = 0x00;
          prgData[3] = 0x00;
          prgEndAddr = 0x1003U;
          progressMessage("");
          return false;
        }
        ditherLine(yc);
      }
      // generate FLI data
      double  totalError = 0.0;
      if (!convertImage(prgData, totalError)) {
        prgData[0] = 0x01;
        prgData[1] = 0x10;
        prgData[2] = 0x00;
        prgData[3] = 0x00;
        prgEndAddr = 0x1003U;
        progressMessage("");
        return false;
      }
      setProgressPercentage(100);
      progressMessage("");
      {
        char    tmpBuf[64];
        totalError = std::sqrt(totalError / double(160 * 200));
        std::sprintf(&(tmpBuf[0]), "Done, RMS error = %.4f", totalError);
        progressMessage(&(tmpBuf[0]));
      }
      // write PRG output
      optimizeAttributes(prgData);
      prgEndAddr = 0x9F40U;
    }
    catch (...) {
      prgData[0] = 0x01;
      prgData[1] = 0x10;
      prgData[2] = 0x00;
      prgData[3] = 0x00;
      prgEndAddr = 0x1003U;
      progressMessage("");
      throw;
    }
    return true;
  }

}       // namespace Plus4FLIConv

