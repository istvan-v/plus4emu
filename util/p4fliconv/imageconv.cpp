
// p4fliconv: high resolution interlaced FLI converter utility
// Copyright (C) 2007-2008 Istvan Varga <istvanv@users.sourceforge.net>
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// The Plus/4 program files generated by this utility are not covered by the
// GNU General Public License, and can be used, modified, and distributed
// without any restrictions.

#include "p4fliconv.hpp"
#include "imageconv.hpp"

#include <FL/Fl.H>
#include <FL/Fl_Image.H>
#include <FL/Fl_Shared_Image.H>

static void defaultProgressMessageCb(void *userData, const char *msg)
{
  (void) userData;
  if (msg != (char *) 0 && msg[0] != '\0')
    std::fprintf(stderr, "%s\n", msg);
}

static bool defaultProgressPercentageCb(void *userData, int n)
{
  (void) userData;
  if (n != 100)
    std::fprintf(stderr, "\r  %3d%%    ", n);
  else
    std::fprintf(stderr, "\r  %3d%%    \n", n);
  return true;
}

namespace Plus4FLIConv {

  void YUVImageConverter::defaultStorePixelFunc(void *userData, int xc, int yc,
                                                float y, float u, float v)
  {
    (void) userData;
    (void) xc;
    (void) yc;
    float   r = (v / 0.877f) + y;
    float   b = (u / 0.492f) + y;
    float   g = (y - ((r * 0.299f) + (b * 0.114f))) / 0.587f;
    r = (r > 0.0f ? (r < 1.0f ? r : 1.0f) : 0.0f);
    g = (g > 0.0f ? (g < 1.0f ? g : 1.0f) : 0.0f);
    b = (b > 0.0f ? (b < 1.0f ? b : 1.0f) : 0.0f);
    std::fputc(int(r * 255.0f + 0.5f), stdout);
    std::fputc(int(g * 255.0f + 0.5f), stdout);
    std::fputc(int(b * 255.0f + 0.5f), stdout);
  }

  YUVImageConverter::YUVImageConverter()
    : width(640),
      height(400),
      pixelAspectRatio(1.0f),
      scaleX(1.0f),
      scaleY(1.0f),
      offsetX(0.0f),
      offsetY(0.0f),
      yGamma(1.0f),
      yMin(0.0f),
      yMax(1.0f),
      colorSaturationMult(1.0f),
      colorSaturationPow(1.0f),
      borderColorY(0.0f),
      borderColorU(0.0f),
      borderColorV(0.0f),
      storePixelFunc(&defaultStorePixelFunc),
      storePixelFuncUserData((void *) 0),
      progressMessageCallback(&defaultProgressMessageCb),
      progressMessageUserData((void *) 0),
      progressPercentageCallback(&defaultProgressPercentageCb),
      progressPercentageUserData((void *) 0),
      prvProgressPercentage(-1)
  {
  }

  YUVImageConverter::~YUVImageConverter()
  {
  }

  bool YUVImageConverter::convertImageFile(const char *fileName)
  {
    if (fileName == (char *) 0 || fileName[0] == '\0')
      throw Plus4Emu::Exception("invalid image file name");
    float     *windowX = (float *) 0;
    float     *windowY = (float *) 0;
    float     *inputImage = (float *) 0;
    Fl_Shared_Image *f = Fl_Shared_Image::get(fileName);
    if (!f)
      throw Plus4Emu::Exception("error opening image file");
    try {
      int     cnt = f->count();
      int     d = f->d();
      size_t  w = size_t(f->w());
      size_t  h = size_t(f->h());
      const char  *p = (char *) 0;
      if (cnt == 1)
        p = f->data()[0];
      if ((d < 1 || d > 4) || (w < 32 || w > 8192) || (h < 32 || h > 6144) ||
          p == (char *) 0) {
        throw Plus4Emu::Exception("image format is not supported");
      }
      // read input image, and convert it to YUV format
      progressMessage("Resizing image");
      inputImage = new float[w * h * 3];
      bool    haveAlpha = !(d & 1);
      for (size_t yc = 0; yc < h; yc++) {
        if (!setProgressPercentage(int(yc) * 50 / int(h))) {
          for (int tmpY = 0; tmpY < height; tmpY++) {
            for (int tmpX = 0; tmpX < width; tmpX++) {
              storePixelFunc(storePixelFuncUserData, tmpX, tmpY,
                             borderColorY, borderColorU, borderColorV);
            }
          }
          delete[] inputImage;
          progressMessage("");
          return false;
        }
        for (size_t xc = 0; xc < w; xc++) {
          float   r = 0.0f;
          float   g = 0.0f;
          float   b = 0.0f;
          const char  *pixelPtr = &(p[((yc * w) + xc) * size_t(d)]);
          if (d < 3) {
            r = float((unsigned char) pixelPtr[0]) * (1.0f / 255.0f);
            g = r;
            b = r;
          }
          else {
            r = float((unsigned char) pixelPtr[0]) * (1.0f / 255.0f);
            g = float((unsigned char) pixelPtr[1]) * (1.0f / 255.0f);
            b = float((unsigned char) pixelPtr[2]) * (1.0f / 255.0f);
          }
          r = (r * (yMax - yMin)) + yMin;
          g = (g * (yMax - yMin)) + yMin;
          b = (b * (yMax - yMin)) + yMin;
          r = (r > 0.0f ? (r < 1.0f ? r : 1.0f) : 0.0f);
          g = (g > 0.0f ? (g < 1.0f ? g : 1.0f) : 0.0f);
          b = (b > 0.0f ? (b < 1.0f ? b : 1.0f) : 0.0f);
          float   y = (r * 0.299f) + (g * 0.587f) + (b * 0.114f);
          float   u = (b - y) * 0.492f * colorSaturationMult;
          float   v = (r - y) * 0.877f * colorSaturationMult;
          y = float(std::pow(y, yGamma));
          double  c = std::sqrt((u * u) + (v * v));
          if (c > 0.000001) {
            c = c * (1.0 / 0.19);
            c = std::pow(c, double(colorSaturationPow)) / c;
            u = float(c * u);
            v = float(c * v);
          }
          if (haveAlpha) {
            float   a =
                float((unsigned char) pixelPtr[d - 1]) * (1.0f / 255.0f);
            y = (y * a) + (borderColorY * (1.0f - a));
            u = (u * a) + (borderColorU * (1.0f - a));
            v = (v * a) + (borderColorV * (1.0f - a));
          }
          float   *ptr = &(inputImage[((yc * w) + xc) * 3]);
          ptr[0] = y;
          ptr[1] = u;
          ptr[2] = v;
        }
      }
      f->release();
      f = (Fl_Shared_Image *) 0;
      // initialize interpolation window
      float   aspectScale = (float(width) * pixelAspectRatio / float(height))
                            / (float(int(w)) / float(int(h)));
      float   xScale = float(int(w)) / float(width);
      float   yScale = float(int(h)) / float(height);
      if (aspectScale < 1.0f)
        yScale = yScale / aspectScale;
      else
        xScale = xScale * aspectScale;
      xScale = xScale / scaleX;
      yScale = yScale / scaleY;
      float   xOffs = (float(int(w)) * 0.5f) - (float(width) * 0.5f * xScale);
      float   yOffs = (float(int(h)) * 0.5f) - (float(height) * 0.5f * yScale);
      xOffs = xOffs - (offsetX * xScale);
      yOffs = yOffs - (offsetY * yScale);
      windowX = new float[1025];
      windowY = new float[1025];
      for (int x = 0; x < 1025; x++) {
        double  xf = double(x - 512) * (3.14159265 / 1024.0);
        double  wx = std::cos(xf);
        wx = wx * wx;
        float   xs = (xScale <= 1.0f ? 1.0f : (1.0f / xScale));
        xs = (xs > 0.2f ? xs : 0.2f);
        xf = xf * 16.0 * xs;
        if (xf < -0.000001 || xf > 0.000001)
          wx = wx * std::sin(xf) / xf;
        windowX[x] = float(wx * xs);
      }
      for (int y = 0; y < 1025; y++) {
        double  yf = double(y - 512) * (3.14159265 / 1024.0);
        double  wy = std::cos(yf);
        wy = wy * wy;
        float   ys = (yScale <= 1.0f ? 1.0f : (1.0f / yScale));
        ys = (ys > 0.2f ? ys : 0.2f);
        yf = yf * 16.0 * ys;
        if (yf < -0.000001 || yf > 0.000001)
          wy = wy * std::sin(yf) / yf;
        windowY[y] = float(wy * ys);
      }
      // scale image to the specified width and height
      for (int yc = 0; yc < height; yc++) {
        if (!setProgressPercentage((yc * 50 / height) + 50)) {
          for (int tmpY = 0; tmpY < height; tmpY++) {
            for (int tmpX = 0; tmpX < width; tmpX++) {
              storePixelFunc(storePixelFuncUserData, tmpX, tmpY,
                             borderColorY, borderColorU, borderColorV);
            }
          }
          delete[] windowX;
          delete[] windowY;
          delete[] inputImage;
          progressMessage("");
          return false;
        }
        double  yf = double(yc) * yScale + yOffs;
        int     yi = int(yf);
        yf = yf - double(yi);
        if (yf < 0.0) {
          yf += 1.0;
          yi--;
        }
        for (int xc = 0; xc < width; xc++) {
          double  xf = double(xc) * xScale + xOffs;
          int     xi = int(xf);
          xf = xf - double(xi);
          if (xf < 0.0) {
            xf += 1.0;
            xi--;
          }
          double  wxf = 63.999999 * (1.0 - xf);
          double  wyf = 63.999999 * (1.0 - yf);
          int     wxi = int(wxf);
          wxf = wxf - double(wxi);
          int     wyi = int(wyf);
          wyf = wyf - double(wyi);
          float   xs0 = float(1.0 - wxf);
          float   xs1 = float(wxf);
          float   ys0 = float(1.0 - wyf);
          float   ys1 = float(wyf);
          float   y = 0.0f;
          float   u = 0.0f;
          float   v = 0.0f;
          if (xi >= 7 && xi < int(w - 8) && yi >= 7 && yi < int(h - 8)) {
            // faster code for the case when no pixels are clipped
            float   *ptr = &(inputImage[(((yi - 7) * int(w)) + (xi - 7)) * 3]);
            for (int wy = -7; wy <= 8; wy++) {
              float   wsy = (windowY[wyi] * ys0) + (windowY[wyi + 1] * ys1);
              for (int wx = -7; wx <= 8; wx++) {
                float   wsx = (windowX[wxi] * xs0) + (windowX[wxi + 1] * xs1);
                float   w_ = wsx * wsy;
                y += (ptr[0] * w_);
                u += (ptr[1] * w_);
                v += (ptr[2] * w_);
                wxi = wxi + 64;
                ptr = ptr + 3;
              }
              wxi = wxi - 1024;
              wyi = wyi + 64;
              ptr = ptr + ((int(w) - 16) * 3);
            }
          }
          else {
            for (int wy = -7; wy <= 8; wy++) {
              float   wsy = (windowY[wyi] * ys0) + (windowY[wyi + 1] * ys1);
              for (int wx = -7; wx <= 8; wx++) {
                int     x_ = xi + wx;
                int     y_ = yi + wy;
                float   wsx = (windowX[wxi] * xs0) + (windowX[wxi + 1] * xs1);
                float   w_ = wsx * wsy;
                if (x_ < 0 || x_ >= int(w) || y_ < 0 || y_ >= int(h)) {
                  y += (borderColorY * w_);
                  u += (borderColorU * w_);
                  v += (borderColorV * w_);
                }
                else {
                  float   *ptr = &(inputImage[((y_ * int(w)) + x_) * 3]);
                  y += (ptr[0] * w_);
                  u += (ptr[1] * w_);
                  v += (ptr[2] * w_);
                }
                wxi = wxi + 64;
              }
              wxi = wxi - 1024;
              wyi = wyi + 64;
            }
          }
          y = (y > 0.0f ? (y < 1.0f ? y : 1.0f) : 0.0f);
          u = (u > -0.436f ? (u < 0.436f ? u : 0.436f) : -0.436f);
          v = (v > -0.615f ? (v < 0.615f ? v : 0.615f) : -0.615f);
          storePixelFunc(storePixelFuncUserData, xc, yc, y, u, v);
        }
      }
      delete[] windowX;
      delete[] windowY;
      delete[] inputImage;
      setProgressPercentage(100);
      progressMessage("");
    }
    catch (...) {
      if (windowX)
        delete[] windowX;
      if (windowY)
        delete[] windowY;
      if (inputImage)
        delete[] inputImage;
      if (f)
        f->release();
      progressMessage("");
      throw;
    }
    return true;
  }

  void YUVImageConverter::setProgressMessageCallback(
      void (*func)(void *userData, const char *msg), void *userData_)
  {
    if (func) {
      progressMessageCallback = func;
      progressMessageUserData = userData_;
    }
    else {
      progressMessageCallback = &defaultProgressMessageCb;
      progressMessageUserData = (void *) 0;
    }
  }

  void YUVImageConverter::setProgressPercentageCallback(
      bool (*func)(void *userData, int n), void *userData_)
  {
    if (func) {
      progressPercentageCallback = func;
      progressPercentageUserData = userData_;
    }
    else {
      progressPercentageCallback = &defaultProgressPercentageCb;
      progressPercentageUserData = (void *) 0;
    }
  }

  void YUVImageConverter::progressMessage(const char *msg)
  {
    if (msg == (char *) 0)
      msg = "";
    progressMessageCallback(progressMessageUserData, msg);
  }

  bool YUVImageConverter::setProgressPercentage(int n)
  {
    limitValue(n, 0, 100);
    if (n != prvProgressPercentage) {
      prvProgressPercentage = n;
      return progressPercentageCallback(progressPercentageUserData, n);
    }
    return true;
  }

}       // namespace Plus4FLIConv

