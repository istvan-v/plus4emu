
// p4fliconv: high resolution interlaced FLI converter utility
// Copyright (C) 2007-2008 Istvan Varga <istvanv@users.sourceforge.net>
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// The Plus/4 program files generated by this utility are not covered by the
// GNU General Public License, and can be used, modified, and distributed
// without any restrictions.

#include "plus4emu.hpp"
#include "compress.hpp"

static void defaultProgressMessageCb(void *userData, const char *msg)
{
  (void) userData;
  if (msg != (char *) 0 && msg[0] != '\0')
    std::fprintf(stderr, "%s\n", msg);
}

static bool defaultProgressPercentageCb(void *userData, int n)
{
  (void) userData;
  if (n != 100)
    std::fprintf(stderr, "\r  %3d%%    ", n);
  else
    std::fprintf(stderr, "\r  %3d%%    \n", n);
  return true;
}

static size_t getGammaCodeLength(size_t n)
{
  size_t  nBits = 1;
  while (n > 1) {
    n = n >> 1;
    nBits = nBits + 2;
  }
  return nBits;
}

static std::vector< unsigned int >::iterator
    writeGammaCode(std::vector< unsigned int >& outBuf,
                   std::vector< unsigned int >::iterator outBufPos,
                   size_t n)
{
  size_t  nBits = 0;
  size_t  m = 0;
  while (n > 1) {
    m = (m << 1) | (n & 1);
    n = n >> 1;
    nBits++;
  }
  while (nBits > 0) {
    outBufPos = outBuf.insert(outBufPos, 0x01000001U);
    outBufPos++;
    outBufPos = outBuf.insert(outBufPos, 0x01000000U | (unsigned int) (m & 1));
    outBufPos++;
    m = m >> 1;
    nBits--;
  }
  outBufPos = outBuf.insert(outBufPos, 0x01000000U);
  outBufPos++;
  return outBufPos;
}

static inline size_t estimateSymbolLength(size_t cnt, size_t totalCount)
{
  size_t  nBits = 1;
  cnt = cnt * 14;
  totalCount = totalCount * 5;
  while (cnt < totalCount) {
    cnt = cnt << 1;
    nBits++;
  }
  return nBits;
}

namespace Plus4FLIConv {

  PRGCompressor::HuffmanCompressor::HuffmanCompressor(size_t nCharValues_)
    : nCharValues(nCharValues_)
  {
    charCounts.resize(nCharValues);
    for (size_t i = 0; i < nCharValues; i++)
      charCounts[i] = 0;
  }

  PRGCompressor::HuffmanCompressor::~HuffmanCompressor()
  {
  }

  void PRGCompressor::HuffmanCompressor::buildEncodeTable(
      std::vector< unsigned int >& encodeTable,
      const HuffmanNode *p, unsigned int n = 0U, unsigned int nBits = 0U)
  {
    if (p == (HuffmanNode *) 0)
      return;
    if (p->isLeafNode()) {
      encodeTable[p->value] = (nBits << 24) | n;
    }
    else {
      n = n << 1;
      nBits++;
      if (p->child0)
        buildEncodeTable(encodeTable, p->child0, n, nBits);
      if (p->child1)
        buildEncodeTable(encodeTable, p->child1, n | 1U, nBits);
    }
  }

  std::vector< unsigned int >::iterator
      PRGCompressor::HuffmanCompressor::calculateCompression(
          std::vector< unsigned int >& outBuf,
          std::vector< unsigned int >::iterator outBufPos,
          std::vector< unsigned int >& encodeTable)
  {
    encodeTable.resize(nCharValues);
    for (size_t i = 0; i < nCharValues; i++)
      encodeTable[i] = 0U;
    size_t  nCharValuesUsed = 0;
    size_t  totalCharsUncompressed = 0;
    size_t  totalBitsUncompressed = 0;
    size_t  totalBitsCompressed = 0;
    size_t  bitsPerCharUncompressed = 0;
    {
      size_t  tmp = 1;
      while (tmp < nCharValues) {
        tmp = tmp << 1;
        bitsPerCharUncompressed++;
      }
    }
    for (size_t i = 0; i < nCharValues; i++) {
      if (charCounts[i] > 0) {
        nCharValuesUsed++;
        totalCharsUncompressed += charCounts[i];
      }
    }
    totalBitsUncompressed = totalCharsUncompressed * bitsPerCharUncompressed;
    // check for trivial cases (zero or one symbol only)
    if (nCharValuesUsed == 0) {
      outBufPos = outBuf.insert(outBufPos, 0x01000000U);
      outBufPos++;
      return outBufPos;
    }
    if (nCharValuesUsed == 1) {
      for (size_t i = 0; i < nCharValues; i++) {
        if (charCounts[i] > 0)
          encodeTable[i] = 0x01000000U;
      }
    }
    else {
      // build Huffman tree
      std::list< HuffmanNode * >  nodeList;
      std::vector< HuffmanNode >  buf;
      buf.resize(nCharValues * 2);
      size_t  n = 0;
      for (size_t i = 0; i < nCharValues; i++) {
        if (charCounts[i] > 0) {
          HuffmanNode *p = &(buf[n]);
          n++;
          p->weight = charCounts[i];
          p->value = i;
          p->parent = (HuffmanNode *) 0;
          p->child0 = (HuffmanNode *) 0;
          p->child1 = (HuffmanNode *) 0;
          std::list< HuffmanNode * >::iterator  i_ = nodeList.begin();
          while (i_ != nodeList.end()) {
            if ((*i_)->weight > p->weight)
              break;
            i_++;
          }
          nodeList.insert(i_, p);
        }
      }
      HuffmanNode *rootNode = (HuffmanNode *) 0;
      while (nodeList.begin() != nodeList.end()) {
        HuffmanNode *p0 = nodeList.front();
        nodeList.pop_front();
        if (nodeList.begin() == nodeList.end()) {
          rootNode = p0;
          break;
        }
        HuffmanNode *p1 = nodeList.front();
        nodeList.pop_front();
        rootNode = &(buf[n]);
        n++;
        rootNode->weight = p0->weight + p1->weight;
        rootNode->value = 0;
        rootNode->parent = (HuffmanNode *) 0;
        rootNode->child0 = p0;
        p0->parent = rootNode;
        rootNode->child1 = p1;
        p1->parent = rootNode;
        std::list< HuffmanNode * >::iterator  i_ = nodeList.begin();
        while (i_ != nodeList.end()) {
          if ((*i_)->weight > rootNode->weight)
            break;
          i_++;
        }
        nodeList.insert(i_, rootNode);
      }
      buildEncodeTable(encodeTable, rootNode);
      nodeList.clear();
      buf.clear();
    }
    // convert encode table to canonical Huffman codes
    size_t  sizeCounts[16];
    size_t  sizeCodes[16];
    for (size_t i = 0; i < 16; i++)
      sizeCounts[i] = 0;
    for (size_t i = 0; i < nCharValues; i++) {
      if (charCounts[i] > 0)
        sizeCounts[(encodeTable[i] >> 24) - 1U]++;
    }
    sizeCodes[0] = 0;
    for (size_t i = 1; i < 16; i++)
      sizeCodes[i] = (sizeCodes[i - 1] + sizeCounts[i - 1]) << 1;
    for (size_t i = 0; i < nCharValues; i++) {
      if (charCounts[i] > 0) {
        size_t  j = size_t(encodeTable[i] >> 24);
        encodeTable[i] = (unsigned int) ((j << 24) | sizeCodes[j - 1]);
        sizeCodes[j - 1]++;
      }
    }
    // avoid the code 1111111 since it currently breaks the decompressor
    for (size_t i = 0; i < nCharValues; i++) {
      if (encodeTable[i] == 0x0700007FU) {
        encodeTable[i] = 0x080000FEU;
        break;
      }
    }
    // calculate compressed size
    for (size_t i = 1; i <= 16; i++) {
      unsigned int  prvChar = 0U - 1U;
      size_t        sizeCnt = 0;
      for (size_t j = 0; j < nCharValues; j++) {
        if (size_t(encodeTable[j] >> 24) == i) {
          sizeCnt++;
          unsigned int  newChar = (unsigned int) j;
          unsigned int  d = newChar - prvChar;
          prvChar = newChar;
          totalBitsCompressed += getGammaCodeLength(d);
        }
      }
      totalBitsCompressed += getGammaCodeLength(sizeCnt + 1);
    }
    // if the size cannot be reduced, store the data without compression
    if (totalBitsCompressed >= totalBitsUncompressed) {
      for (size_t i = 0; i < nCharValues; i++)
        encodeTable[i] = (unsigned int) ((bitsPerCharUncompressed << 24) | i);
      outBufPos = outBuf.insert(outBufPos, 0x01000000U);
      outBufPos++;
      return outBufPos;
    }
    // add decode table to the output buffer
    outBufPos = outBuf.insert(outBufPos, 0x01000001U);
    outBufPos++;
    for (size_t i = 1; i <= 16; i++) {
      size_t  sizeCnt = 0;
      for (size_t j = 0; j < nCharValues; j++) {
        if (size_t(encodeTable[j] >> 24) == i)
          sizeCnt++;
      }
      outBufPos = writeGammaCode(outBuf, outBufPos, sizeCnt + 1);
      unsigned int  prvChar = 0U - 1U;
      for (size_t j = 0; j < nCharValues; j++) {
        if (size_t(encodeTable[j] >> 24) == i) {
          unsigned int  newChar = (unsigned int) j;
          unsigned int  d = newChar - prvChar;
          prvChar = newChar;
          outBufPos = writeGammaCode(outBuf, outBufPos, d);
        }
      }
    }
    return outBufPos;
  }

  // --------------------------------------------------------------------------

  void PRGCompressor::SearchTable::sortFunc(size_t startPos, size_t endPos,
                                            std::vector< unsigned int >& tmpBuf)
  {
    if ((startPos + 1) >= endPos)
      return;
    size_t  splitPos = (startPos + endPos) >> 1;
    sortFunc(startPos, splitPos, tmpBuf);
    sortFunc(splitPos, endPos, tmpBuf);
    size_t  i = startPos;
    size_t  j = splitPos;
    for (size_t k = 0; k < (endPos - startPos); k++) {
      if (i >= splitPos) {
        tmpBuf[k] = suffixArray[j];
        j++;
      }
      else if (j >= endPos) {
        tmpBuf[k] = suffixArray[i];
        i++;
      }
      else {
        size_t  pos1 = suffixArray[i];
        size_t  pos2 = suffixArray[j];
        size_t  len1 = buf.size() - pos1;
        if (len1 > PRGCompressor::maxRepeatLen)
          len1 = PRGCompressor::maxRepeatLen;
        size_t  len2 = buf.size() - pos2;
        if (len2 > PRGCompressor::maxRepeatLen)
          len2 = PRGCompressor::maxRepeatLen;
        size_t  l = (len1 < len2 ? len1 : len2);
        const void  *ptr1 = (const void *) (&(buf.front()) + pos1);
        const void  *ptr2 = (const void *) (&(buf.front()) + pos2);
        int     c = std::memcmp(ptr1, ptr2, l);
        if (c == 0)
          c = (pos1 < pos2 ? -1 : 1);
        if (c < 0) {
          tmpBuf[k] = suffixArray[i];
          i++;
        }
        else {
          tmpBuf[k] = suffixArray[j];
          j++;
        }
      }
    }
    for (size_t k = 0; k < (endPos - startPos); k++)
      suffixArray[startPos + k] = tmpBuf[k];
  }

  PRGCompressor::SearchTable::SearchTable(
      const std::vector< unsigned char >& inBuf)
    : buf(inBuf)
  {
    std::vector< unsigned int > tmpBuf;
    tmpBuf.resize(buf.size());
    suffixArray.resize(buf.size());
    prvMatchLenTable.resize(buf.size());
    nxtMatchLenTable.resize(buf.size());
    size_t  matchLenCnt =
        PRGCompressor::maxRepeatLen + 1 - PRGCompressor::minRepeatLen;
    bestMatchPosTable.resize(matchLenCnt);
    for (size_t i = 0; i < matchLenCnt; i++) {
      bestMatchPosTable[i].resize(buf.size());
      for (size_t j = 0; j < buf.size(); j++)
        bestMatchPosTable[i][j] = 0;
    }
    maxMatchLenTable.resize(buf.size());
    seqDiffTable.resize(4);
    maxSeqLenTable.resize(4);
    for (size_t i = 0; i < 4; i++) {
      seqDiffTable[i].resize(buf.size());
      maxSeqLenTable[i].resize(buf.size());
      for (size_t j = 0; j < buf.size(); j++) {
        seqDiffTable[i][j] = 0x00;
        maxSeqLenTable[i][j] = 0;
      }
    }
    for (size_t i = 0; i < buf.size(); i++) {
      maxMatchLenTable[i] = 0;
      suffixArray[i] = (unsigned int) i;
    }
    sortFunc(0, buf.size(), tmpBuf);
    for (size_t i = 0; i < buf.size(); i++) {
      if (i == 0) {
        prvMatchLenTable[i] = 0;
      }
      else {
        size_t  len = 0;
        size_t  p1 = suffixArray[i - 1];
        size_t  p2 = suffixArray[i];
        while (len < PRGCompressor::maxRepeatLen &&
               p1 < buf.size() && p2 < buf.size() &&
               buf[p1] == buf[p2]) {
          len++;
          p1++;
          p2++;
        }
        prvMatchLenTable[i] = (unsigned short) len;
        nxtMatchLenTable[i - 1] = prvMatchLenTable[i];
      }
      nxtMatchLenTable[i] = 0;
    }
    for (size_t i = PRGCompressor::minRepeatDist;
         (i + PRGCompressor::minRepeatLen) <= buf.size();
         i++) {
      for (size_t j = 1; j <= 4; j++) {
        if (i >= j) {
          unsigned char d = (buf[i] - buf[i - j]) & 0xFF;
          if (d != 0x00 && (d >= 0xC0 || d <= 0x40)) {
            size_t  k = i;
            size_t  l = i - j;
            while (k < buf.size() && (k - i) < PRGCompressor::maxRepeatLen &&
                   buf[k] == ((buf[l] + d) & 0xFF)) {
              k++;
              l++;
            }
            k = k - i;
            if (k >= PRGCompressor::minRepeatLen) {
              seqDiffTable[j - 1][i] = d;
              maxSeqLenTable[j - 1][i] = (unsigned short) k;
            }
          }
        }
      }
    }
    for (size_t i_ = 1; (i_ + 1) < buf.size(); i_++) {
      size_t  i = suffixArray[i_];
      size_t  matchLen = buf.size() - i;
      if (matchLen > PRGCompressor::maxRepeatLen)
        matchLen = PRGCompressor::maxRepeatLen;
      size_t  minLen = PRGCompressor::minRepeatLen;
      size_t  ndx = i_;
      while (true) {
        if (size_t(prvMatchLenTable[ndx]) < matchLen)
          matchLen = size_t(prvMatchLenTable[ndx]);
        if (matchLen < PRGCompressor::minRepeatLen)
          break;
        ndx--;
        size_t  matchPos = suffixArray[ndx];
        if (matchPos >= i || (matchPos + PRGCompressor::maxRepeatDist) < i)
          continue;
        if (matchLen > size_t(maxMatchLenTable[i]))
          maxMatchLenTable[i] = (unsigned short) matchLen;
        size_t  d = i - matchPos;
        size_t  k = matchLen - PRGCompressor::minRepeatLen;
        size_t  prvDist = size_t(bestMatchPosTable[k][i]);
        if (prvDist == 0 || d < prvDist)
          bestMatchPosTable[k][i] = (unsigned short) d;
        if (d == 1) {
          minLen = matchLen + 1;
          break;
        }
      }
      matchLen = buf.size() - i;
      if (matchLen > PRGCompressor::maxRepeatLen)
        matchLen = PRGCompressor::maxRepeatLen;
      ndx = i_;
      while (true) {
        if (size_t(nxtMatchLenTable[ndx]) < matchLen)
          matchLen = size_t(nxtMatchLenTable[ndx]);
        if (matchLen < minLen)
          break;
        ndx++;
        size_t  matchPos = suffixArray[ndx];
        if (matchPos >= i || (matchPos + PRGCompressor::maxRepeatDist) < i)
          continue;
        if (matchLen > size_t(maxMatchLenTable[i]))
          maxMatchLenTable[i] = (unsigned short) matchLen;
        size_t  d = i - matchPos;
        size_t  k = matchLen - PRGCompressor::minRepeatLen;
        size_t  prvDist = size_t(bestMatchPosTable[k][i]);
        if (prvDist == 0 || d < prvDist)
          bestMatchPosTable[k][i] = (unsigned short) d;
        if (d == 1)
          break;
      }
      size_t  k = size_t(maxMatchLenTable[i]);
      if (k > PRGCompressor::minRepeatLen) {
        k = k - PRGCompressor::minRepeatLen;
        do {
          if (bestMatchPosTable[k - 1][i] == 0 ||
              bestMatchPosTable[k][i] < bestMatchPosTable[k - 1][i]) {
            bestMatchPosTable[k - 1][i] = bestMatchPosTable[k][i];
          }
        } while (--k > 0);
      }
    }
  }

  PRGCompressor::SearchTable::~SearchTable()
  {
  }

  // --------------------------------------------------------------------------

  const unsigned char PRGCompressor::decomp_code[0x02A9] = {
    0x0C, 0x10, 0x0A, 0x00, 0x9E, 0x20, 0x34, 0x31, 0x31, 0x37, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0xD8, 0xA2, 0xFF,
    0x9A, 0xAD, 0x06, 0xFF, 0x48, 0xAD, 0x19, 0xFF, 0x48, 0xA2, 0xCA, 0xBD,
    0x8D, 0x10, 0x9D, 0x23, 0x01, 0xBD, 0x57, 0x11, 0x9D, 0x34, 0x03, 0xB5,
    0x1F, 0x9D, 0x5F, 0x09, 0xBD, 0xDF, 0x11, 0x9D, 0x35, 0x0B, 0xCA, 0xD0,
    0xE6, 0x8E, 0x06, 0xFF, 0x86, 0x20, 0x8E, 0x3F, 0xFF, 0xA5, 0x2D, 0x38,
    0xE9, 0xAA, 0xA8, 0xF0, 0x23, 0xA2, 0x2D, 0x98, 0x49, 0xFF, 0x38, 0x75,
    0x00, 0x95, 0x00, 0xB0, 0x02, 0xD6, 0x01, 0xE0, 0x37, 0xA2, 0x37, 0x90,
    0xEE, 0x88, 0xB1, 0x2D, 0x91, 0x37, 0x45, 0x20, 0x0A, 0x69, 0xC4, 0x85,
    0x20, 0x98, 0xD0, 0xF1, 0xA5, 0x2E, 0xC9, 0x12, 0xF0, 0x06, 0xC6, 0x2E,
    0xC6, 0x38, 0xD0, 0xE5, 0xA5, 0x20, 0xC9, 0x80, 0xD0, 0x05, 0xA2, 0x04,
    0x4C, 0x2A, 0x01, 0x8C, 0x3E, 0xFF, 0x6C, 0xFC, 0xFF, 0xE6, 0x2F, 0xD0,
    0x33, 0xA2, 0x03, 0x86, 0x39, 0x20, 0x82, 0x03, 0xA6, 0x39, 0x95, 0x2E,
    0xCA, 0x10, 0xF4, 0x20, 0x7C, 0x03, 0xF0, 0x05, 0xA9, 0xDA, 0x8D, 0x2D,
    0x01, 0xA9, 0x82, 0x8D, 0x51, 0x01, 0x20, 0x7C, 0x03, 0xF0, 0x03, 0x20,
    0x60, 0x0B, 0xEE, 0x19, 0xFF, 0x20, 0x35, 0x03, 0xB0, 0x0E, 0x91, 0x30,
    0xE6, 0x2E, 0xF0, 0xC9, 0xE6, 0x30, 0xD0, 0xF1, 0xE6, 0x31, 0x90, 0xEA,
    0xC9, 0x3C, 0xB0, 0x3E, 0xC9, 0x08, 0x90, 0x14, 0x84, 0x33, 0x20, 0xC8,
    0x01, 0xA6, 0x39, 0xA4, 0x33, 0x95, 0x26, 0x94, 0x2A, 0xCA, 0x10, 0x02,
    0xA2, 0x03, 0x86, 0x39, 0xA2, 0x9B, 0x8E, 0x51, 0x01, 0x49, 0xFF, 0x65,
    0x30, 0x85, 0x34, 0x98, 0x49, 0xFF, 0x65, 0x31, 0x85, 0x35, 0xA0, 0x00,
    0xA2, 0x3F, 0x20, 0x37, 0x03, 0xC9, 0x08, 0x90, 0x04, 0x20, 0xC8, 0x01,
    0x18, 0xAA, 0xE8, 0xE8, 0x90, 0xA8, 0xC9, 0x40, 0xB0, 0x14, 0x29, 0x03,
    0x48, 0xA2, 0x07, 0x20, 0x87, 0x03, 0xE9, 0x3F, 0x69, 0x00, 0x8D, 0x98,
    0x03, 0xA2, 0x95, 0x68, 0x90, 0xC4, 0x65, 0x39, 0x29, 0x03, 0xAA, 0xB5,
    0x26, 0xB4, 0x2A, 0x90, 0xB7, 0x48, 0x4A, 0x4A, 0xAA, 0xCA, 0x68, 0x29,
    0x03, 0x09, 0x04, 0x06, 0x20, 0xD0, 0x03, 0x20, 0xAD, 0x03, 0x2A, 0x26,
    0x33, 0xCA, 0xD0, 0xF3, 0x60, 0x51, 0x96, 0x7F, 0x85, 0x35, 0x37, 0x00,
    0x40, 0x00, 0x44, 0x08, 0x09, 0x10, 0x10, 0xA2, 0xFF, 0xA9, 0x01, 0x84,
    0x33, 0xE8, 0x06, 0x20, 0xF0, 0x37, 0x2A, 0xB0, 0x15, 0xD5, 0x40, 0xB0,
    0xF4, 0x90, 0x1B, 0xE8, 0x06, 0x20, 0xD0, 0x05, 0xA0, 0x00, 0x20, 0xAD,
    0x03, 0x2A, 0x26, 0x33, 0x30, 0x0A, 0xD5, 0x40, 0xA8, 0xA5, 0x33, 0xF5,
    0x50, 0x98, 0xB0, 0xE7, 0xA0, 0x00, 0x75, 0x60, 0x85, 0x32, 0xA5, 0x33,
    0x75, 0x70, 0x85, 0x33, 0x49, 0x02, 0xD1, 0x32, 0x85, 0x33, 0xB1, 0x32,
    0x60, 0x20, 0xAD, 0x03, 0xD0, 0xC4, 0xA2, 0x01, 0x2C, 0xA2, 0x09, 0x2C,
    0xA2, 0x08, 0x2C, 0xA2, 0x05, 0x98, 0x06, 0x20, 0xD0, 0x03, 0x20, 0xAD,
    0x03, 0x2A, 0xCA, 0xD0, 0xF5, 0xAA, 0x60, 0xB1, 0x34, 0x69, 0x00, 0x18,
    0x2C, 0xB1, 0x34, 0xCA, 0xF0, 0x07, 0xE6, 0x34, 0xD0, 0x02, 0xE6, 0x35,
    0x60, 0xA6, 0x3E, 0x8E, 0x51, 0x01, 0x60, 0x85, 0x21, 0xA5, 0x24, 0x2A,
    0x85, 0x20, 0xE6, 0x37, 0xD0, 0x02, 0xE6, 0x38, 0xB1, 0x37, 0x85, 0x24,
    0xA5, 0x21, 0x60, 0xA9, 0x01, 0x84, 0x3F, 0x06, 0x20, 0xD0, 0x03, 0x20,
    0xAD, 0x03, 0x90, 0xF2, 0x06, 0x20, 0xD0, 0x03, 0x20, 0xAD, 0x03, 0x2A,
    0x26, 0x3F, 0x90, 0xEB, 0x68, 0x68, 0xA0, 0xA0, 0xB9, 0x5F, 0x09, 0x99,
    0x1F, 0x00, 0x88, 0xD0, 0xF7, 0x20, 0x64, 0x0B, 0xC8, 0x84, 0x25, 0xA0,
    0x00, 0x20, 0x7C, 0x03, 0xA4, 0x25, 0x4A, 0xB0, 0x0F, 0xB9, 0xE2, 0x01,
    0xBE, 0xE0, 0x01, 0x99, 0x3E, 0x00, 0x9D, 0x00, 0x01, 0xA0, 0x00, 0x60,
    0x98, 0x69, 0x09, 0xA8, 0xA2, 0x05, 0x95, 0x24, 0x88, 0x88, 0xB9, 0xE4,
    0x01, 0xCA, 0xD0, 0xF6, 0x20, 0x73, 0x0B, 0xA6, 0x25, 0xA9, 0x01, 0x0A,
    0x95, 0x40, 0xA5, 0x28, 0x49, 0x09, 0xF0, 0x02, 0x98, 0x2A, 0x95, 0x50,
    0xA0, 0xFE, 0x84, 0x3B, 0xC8, 0x84, 0x3A, 0xC8, 0xA5, 0x26, 0x38, 0xF5,
    0x40, 0x95, 0x60, 0xA5, 0x27, 0xF5, 0x50, 0x95, 0x70, 0x20, 0xC1, 0x03,
    0x85, 0x3C, 0xC9, 0x01, 0xA5, 0x3F, 0x69, 0x00, 0x85, 0x3D, 0xC6, 0x3C,
    0xD0, 0x04, 0xC6, 0x3D, 0xF0, 0x27, 0xF6, 0x40, 0xD0, 0x02, 0xF6, 0x50,
    0x20, 0xC1, 0x03, 0x65, 0x3A, 0x85, 0x3A, 0xA5, 0x3F, 0x65, 0x3B, 0x85,
    0x3B, 0x91, 0x26, 0xE6, 0x27, 0xE6, 0x27, 0xA5, 0x3A, 0x91, 0x26, 0xE6,
    0x26, 0xF0, 0x02, 0xC6, 0x27, 0xC6, 0x27, 0xD0, 0xD1, 0xC6, 0x28, 0xF0,
    0x07, 0xB5, 0x40, 0xB4, 0x50, 0xE8, 0xD0, 0x97, 0x60
  };

  const unsigned char PRGCompressor::decomp_code_c16[0x0014] = {
    0x0B, 0x10, 0x0A, 0x00, 0x9E, 0x34, 0x31, 0x30, 0x39, 0x00, 0x00, 0x00,
    0xA9, 0x00, 0x85, 0x37, 0xA9, 0x40, 0x85, 0x38
  };

  const unsigned char PRGCompressor::decomp_code_2[0x0021] = {
    0xAD, 0x3B, 0x05, 0x99, 0x00, 0x08, 0xC8, 0xD0, 0xFA, 0xEE, 0xEC, 0x03,
    0xCA, 0x10, 0xF4, 0x68, 0x8D, 0x19, 0xFF, 0x68, 0x8D, 0x06, 0xFF, 0x8C,
    0x3E, 0xFF, 0x58, 0x20, 0xBE, 0x8B, 0x4C, 0xDC, 0x8B
  };

  // --------------------------------------------------------------------------

  PRGCompressor::CompressionParameters::CompressionParameters()
    : optimizeIterations(2),
      splitOptimizationDepth(1),
      optimalParsingEnabled(false),
      optimizeMatchDistanceRepeats(false)
  {
  }

  PRGCompressor::CompressionParameters::CompressionParameters(
      const CompressionParameters& r)
  {
    optimizeIterations = r.optimizeIterations;
    if (optimizeIterations < 1)
      optimizeIterations = 1;
    if (optimizeIterations > 20)
      optimizeIterations = 20;
    splitOptimizationDepth = r.splitOptimizationDepth;
    if (splitOptimizationDepth < 1)
      splitOptimizationDepth = 1;
    if (splitOptimizationDepth > 9)
      splitOptimizationDepth = 9;
    optimalParsingEnabled = r.optimalParsingEnabled;
    optimizeMatchDistanceRepeats = r.optimizeMatchDistanceRepeats;
  }

  PRGCompressor::CompressionParameters::CompressionParameters&
      PRGCompressor::CompressionParameters::operator=(
          const CompressionParameters& r)
  {
    optimizeIterations = r.optimizeIterations;
    if (optimizeIterations < 1)
      optimizeIterations = 1;
    if (optimizeIterations > 20)
      optimizeIterations = 20;
    splitOptimizationDepth = r.splitOptimizationDepth;
    if (splitOptimizationDepth < 1)
      splitOptimizationDepth = 1;
    if (splitOptimizationDepth > 9)
      splitOptimizationDepth = 9;
    optimalParsingEnabled = r.optimalParsingEnabled;
    optimizeMatchDistanceRepeats = r.optimizeMatchDistanceRepeats;
    return (*this);
  }

  void PRGCompressor::CompressionParameters::setCompressionLevel(int n)
  {
    n = (n > 1 ? (n < 9 ? n : 9) : 1);
    optimizeIterations = size_t(n > 1 ? n : 2);
    splitOptimizationDepth = size_t(n);
    optimalParsingEnabled = (n >= 2);
    optimizeMatchDistanceRepeats = (n >= 8);
  }

  // --------------------------------------------------------------------------

  void PRGCompressor::huffmanCompressBlock(std::vector< unsigned int >& ioBuf)
  {
    HuffmanCompressor   huff1(324);
    HuffmanCompressor   huff2(28);
    std::vector< unsigned int > encodeTable1;
    encodeTable1.resize(324);
    std::vector< unsigned int > encodeTable2;
    encodeTable2.resize(28);
    for (size_t i = 0; i < ioBuf.size(); i++) {
      if (ioBuf[i] <= 0x17FU)
        huff1.addChar(ioBuf[i]);
      else if (ioBuf[i] <= 0x1FFU)
        huff2.addChar(ioBuf[i] - 0x180U);
    }
    // insert the decode table after the block header
    std::vector< unsigned int >::iterator   i_ = ioBuf.begin();
    for (size_t i = 0; i < 4 && i_ != ioBuf.end(); i++)
      i_++;
    i_ = huff1.calculateCompression(ioBuf, i_, encodeTable1);
    i_ = huff2.calculateCompression(ioBuf, i_, encodeTable2);
    for (size_t i = 0; i < ioBuf.size(); i++) {
      if (ioBuf[i] <= 0x17FU)
        ioBuf[i] = encodeTable1[ioBuf[i]];
      else if (ioBuf[i] <= 0x1FFU)
        ioBuf[i] = encodeTable2[ioBuf[i] - 0x180U];
    }
  }

  void PRGCompressor::initializeLengthCodeTables()
  {
    for (size_t i = minRepeatDist; i <= maxRepeatDist; i++) {
      size_t  lCode = 0;
      size_t  lBits = 0;
      size_t  lValue = i - minRepeatDist;
      if (lValue <= 7) {
        lCode = lValue;
        lValue = 0;
      }
      else {
        while (lValue >= (size_t(1) << lBits))
          lBits++;
        lCode = ((lValue >> (lBits - 3)) & 3) | ((lBits - 2) << 2);
        lBits = lBits - 3;
        lValue = lValue & ((size_t(1) << lBits) - 1);
      }
      size_t  j = (i - minRepeatDist) + minRepeatLen;
      if (j >= minRepeatLen && j <= maxRepeatLen) {
        lengthCodeTable[j] = (unsigned short) (lCode | 0x0180);
        lengthBitsTable[j] = (unsigned char) lBits;
        lengthValueTable[j] = (unsigned int) (lValue | (lBits << 24));
      }
      distanceCodeTable[i] = (unsigned short) (lCode | 0x0100);
      distanceBitsTable[i] = (unsigned char) lBits;
      distanceValueTable[i] = (unsigned int) (lValue | (lBits << 24));
    }
  }

  void PRGCompressor::writeRepeatCode(std::vector< unsigned int >& buf,
                                      size_t d, size_t n)
  {
    if (d > 8) {
      for (size_t i = 0; i < 4; i++) {
        if (d == prvDistances[i]) {
          unsigned int  c = 0x0140U | (unsigned int) i;
          tmpCharCountTable[c]++;
          buf.push_back(c);
          c = (unsigned int) lengthCodeTable[n];
          tmpCharCountTable[c]++;
          buf.push_back(c);
          if (lengthBitsTable[n] > 0)
            buf.push_back(lengthValueTable[n]);
          return;
        }
      }
      for (size_t i = 3; i > 0; i--)
        prvDistances[i] = prvDistances[i - 1];
      prvDistances[0] = d;
    }
    unsigned int  c = (unsigned int) distanceCodeTable[d];
    tmpCharCountTable[c]++;
    buf.push_back(c);
    if (distanceBitsTable[d] > 0)
      buf.push_back(distanceValueTable[d]);
    c = (unsigned int) lengthCodeTable[n];
    tmpCharCountTable[c]++;
    buf.push_back(c);
    if (lengthBitsTable[n] > 0)
      buf.push_back(lengthValueTable[n]);
  }

  inline size_t PRGCompressor::getRepeatCodeLength(size_t d, size_t n) const
  {
    unsigned int  dCode = (unsigned int) distanceCodeTable[d];
    unsigned int  lCode = (unsigned int) lengthCodeTable[n];
    return (tmpCharBitsTable[dCode] + size_t(distanceBitsTable[d])
            + tmpCharBitsTable[lCode] + size_t(lengthBitsTable[n]));
  }

  void PRGCompressor::writeSequenceCode(std::vector< unsigned int >& buf,
                                        unsigned char seqDiff,
                                        size_t d, size_t n)
  {
    unsigned int  c = (unsigned int) distanceCodeTable[d] | 0x003CU;
    tmpCharCountTable[c]++;
    buf.push_back(c);
    seqDiff = (seqDiff + 0x40) & 0xFF;
    if (seqDiff > 0x40)
      seqDiff--;
    buf.push_back(0x07000000U | (unsigned int) seqDiff);
    c = (unsigned int) lengthCodeTable[n];
    tmpCharCountTable[c]++;
    buf.push_back(c);
    if (lengthBitsTable[n] > 0)
      buf.push_back(lengthValueTable[n]);
  }

  inline size_t PRGCompressor::getSequenceCodeLength(size_t d, size_t n) const
  {
    unsigned int  dCode = (unsigned int) distanceCodeTable[d] | 0x003CU;
    unsigned int  lCode = (unsigned int) lengthCodeTable[n];
    return (tmpCharBitsTable[dCode] + 7
            + tmpCharBitsTable[lCode] + size_t(lengthBitsTable[n]));
  }

  inline void PRGCompressor::findBestMatch(
      LZMatchParameters& p, const std::vector< unsigned char >& inBuf,
      size_t i, size_t maxLen)
  {
    {
      size_t  k = searchTable->getMaxMatchLength(i);
      if (k >= minRepeatLen) {
        k = (k < maxLen ? k : maxLen);
        size_t  d = searchTable->getDistanceForMatchLength(i, k);
        p.d = (unsigned short) d;
        p.len = (unsigned short) k;
        p.nBits = (unsigned short) getRepeatCodeLength(d, k);
        p.seqFlag = false;
        p.seqDiff = 0x00;
        if (d == 1 && k >= 5)
          return;
      }
      else {
        p.clear();
        p.nBits = (unsigned short) tmpCharBitsTable[inBuf[i]];
      }
    }
    for (size_t d = 1; d <= 4; d++) {
      size_t  k = searchTable->getSequenceLength(i, d);
      if (k >= p.len) {
        k = (k < maxLen ? k : maxLen);
        unsigned short  nBits = (unsigned short) getSequenceCodeLength(d, k);
        if (k > p.len || nBits < p.nBits) {
          p.d = (unsigned short) d;
          p.len = (unsigned short) k;
          p.nBits = nBits;
          p.seqFlag = true;
          p.seqDiff = searchTable->getSequenceDeltaValue(i, d);
        }
      }
    }
  }

  struct BitCountTableEntry {
    long    totalBits;
    unsigned short  prvDistances[4];
    long    prvDistanceCounts[4];
  };

  void PRGCompressor::compressData_(std::vector< unsigned int >& tmpOutBuf,
                                    const std::vector< unsigned char >& inBuf,
                                    unsigned int startAddr, bool isLastBlock,
                                    size_t offs, size_t nBytes)
  {
    size_t  endPos = offs + nBytes;
    // write data header (start address, 2's complement of the number of bytes,
    // last block flag, and compression enabled flag)
    tmpOutBuf.resize(0);
    tmpOutBuf.push_back(0x10000000U | (unsigned int) (startAddr + offs));
    tmpOutBuf.push_back(0x10000000U | (unsigned int) (65536 - nBytes));
    tmpOutBuf.push_back(isLastBlock ? 0x01000001U : 0x01000000U);
    tmpOutBuf.push_back(0x01000001U);
    // compress data by searching for repeated byte sequences,
    // and replacing them with length/distance codes
    for (size_t i = 0; i < 4; i++)
      prvDistances[i] = 0;
    std::vector< LZMatchParameters >  matchTable;
    matchTable.resize(nBytes);
    for (size_t i = offs; i < endPos; i++) {
      matchTable[i - offs].clear();
      matchTable[i - offs].nBits = (unsigned short) tmpCharBitsTable[inBuf[i]];
      size_t  maxLen = endPos - i;
      if (maxLen > maxRepeatLen)
        maxLen = maxRepeatLen;
      if (maxLen >= minRepeatLen)
        findBestMatch(matchTable[i - offs], inBuf, i, maxLen);
    }
    if (config.optimalParsingEnabled) {
      if (config.optimizeMatchDistanceRepeats) {
        std::vector< BitCountTableEntry >   bitCountTable;
        bitCountTable.resize(nBytes + 1);
        bitCountTable[nBytes].totalBits = 0L;
        for (size_t i = 0; i < 4; i++) {
          bitCountTable[nBytes].prvDistances[i] = 0;
          bitCountTable[nBytes].prvDistanceCounts[i] = 0L;
        }
        for (size_t i = endPos; i > offs; ) {
          i--;
          size_t  maxLen = matchTable[i - offs].len;
          long    bestSize = 0x7FFFFFFFL;
          LZMatchParameters tmp;
          for (size_t k = maxLen; k >= minRepeatLen; k--) {
            findBestMatch(tmp, inBuf, i, k);
            BitCountTableEntry& nxtMatch = bitCountTable[i + k - offs];
            BitCountTableEntry  curMatch = nxtMatch;
            curMatch.totalBits += long(tmp.nBits);
            if (tmp.d > 8) {
              int     distNdx = -1;
              for (int nn = 0; nn < 4; nn++) {
                if (curMatch.prvDistances[nn] == tmp.d) {
                  distNdx = nn;
                  break;
                }
              }
              if (distNdx < 0) {
                unsigned short  d = curMatch.prvDistances[0];
                curMatch.totalBits +=
                    ((long(tmpCharBitsTable[0x0140])
                      - (long(tmpCharBitsTable[distanceCodeTable[d]])
                         + long(distanceBitsTable[d])))
                     * curMatch.prvDistanceCounts[0]);
                for (int nn = 0; nn < 3; nn++) {
                  curMatch.prvDistances[nn] = curMatch.prvDistances[nn + 1];
                  curMatch.prvDistanceCounts[nn] =
                      curMatch.prvDistanceCounts[nn + 1];
                }
                curMatch.prvDistances[3] = tmp.d;
                curMatch.prvDistanceCounts[3] = 0L;
              }
              else {
                curMatch.prvDistanceCounts[distNdx]++;
              }
            }
            long    nBits = curMatch.totalBits;
            for (int nn = 0; nn < 4; nn++) {
              if (curMatch.prvDistanceCounts[nn] > 0L) {
                unsigned short  d = curMatch.prvDistances[nn];
                nBits += ((long(tmpCharBitsTable[0x0140 | nn])
                           - (long(tmpCharBitsTable[distanceCodeTable[d]])
                              + long(distanceBitsTable[d])))
                          * curMatch.prvDistanceCounts[nn]);
              }
            }
            if (nBits < bestSize) {
              bestSize = nBits;
              matchTable[i - offs] = tmp;
              bitCountTable[i - offs] = curMatch;
            }
          }
          {
            BitCountTableEntry& nxtMatch = bitCountTable[i + 1 - offs];
            BitCountTableEntry  curMatch = nxtMatch;
            tmp.clear();
            tmp.nBits = (unsigned short) tmpCharBitsTable[inBuf[i]];
            curMatch.totalBits += long(tmp.nBits);
            long    nBits = curMatch.totalBits;
            for (int nn = 0; nn < 4; nn++) {
              if (curMatch.prvDistanceCounts[nn] > 0L) {
                unsigned short  d = curMatch.prvDistances[nn];
                nBits += ((long(tmpCharBitsTable[0x0140 | nn])
                           - (long(tmpCharBitsTable[distanceCodeTable[d]])
                              + long(distanceBitsTable[d])))
                          * curMatch.prvDistanceCounts[nn]);
              }
            }
            if (nBits < bestSize) {
              bestSize = nBits;
              matchTable[i - offs] = tmp;
              bitCountTable[i - offs] = curMatch;
            }
          }
        }
      }
      else {
        std::vector< size_t >   bitCountTable;
        bitCountTable.resize(nBytes + 1);
        bitCountTable[nBytes] = 0;
        for (size_t i = endPos; i > offs; ) {
          i--;
          size_t  maxLen = matchTable[i - offs].len;
          size_t  bestSize = 0x7FFFFFFFUL;
          LZMatchParameters tmp;
          for (size_t k = maxLen; k >= minRepeatLen; k--) {
            findBestMatch(tmp, inBuf, i, k);
            size_t  nBits = size_t(tmp.nBits) + bitCountTable[i + k - offs];
            if (nBits < bestSize) {
              matchTable[i - offs] = tmp;
              bestSize = nBits;
            }
          }
          size_t  nBits =
              tmpCharBitsTable[inBuf[i]] + bitCountTable[i + 1 - offs];
          if (nBits < bestSize) {
            tmp.clear();
            tmp.nBits = (unsigned short) tmpCharBitsTable[inBuf[i]];
            matchTable[i - offs] = tmp;
            bestSize = nBits;
          }
          bitCountTable[i - offs] = bestSize;
        }
      }
    }
    for (size_t i = offs; i < endPos; ) {
      LZMatchParameters&  tmp = matchTable[i - offs];
      if (tmp.len >= minRepeatLen) {
        if (tmp.seqFlag)
          writeSequenceCode(tmpOutBuf, tmp.seqDiff, tmp.d, tmp.len);
        else
          writeRepeatCode(tmpOutBuf, tmp.d, tmp.len);
        i = i + tmp.len;
      }
      else {
        unsigned int  c = (unsigned int) inBuf[i];
        i++;
        tmpCharCountTable[c]++;
        tmpOutBuf.push_back(c);
      }
    }
  }

  bool PRGCompressor::compressData(std::vector< unsigned int >& tmpOutBuf,
                                   const std::vector< unsigned char >& inBuf,
                                   unsigned int startAddr, bool isLastBlock,
                                   size_t offs, size_t nBytes)
  {
    // the 'offs' and 'nBytes' parameters allow compressing a buffer
    // as multiple chunks for possibly improved statistical compression
    if (nBytes < 1 || offs >= inBuf.size())
      return true;
    if (nBytes > (inBuf.size() - offs))
      nBytes = inBuf.size() - offs;
    size_t  endPos = offs + nBytes;
    for (size_t i = 0; i < 512; i++) {
      tmpCharCountTable[i] = 1;
      tmpCharBitsTable[i] = (i < 0x0180 ? 9 : 5);
    }
    std::vector< unsigned int >   tmpBuf;
    for (size_t i = 0; i < config.optimizeIterations; i++) {
      if (progressDisplayEnabled) {
        if (!setProgressPercentage(int(progressCnt * 100 / progressMax)))
          return false;
        progressCnt += nBytes;
      }
      tmpBuf.resize(0);
      compressData_(tmpBuf, inBuf, startAddr,
                    (isLastBlock && (i + 1) == config.optimizeIterations),
                    offs, nBytes);
      // update estimated character sizes
      size_t  totalCount = 0;
      for (size_t j = 0x0000; j < 0x0144; j++)
        totalCount += tmpCharCountTable[j];
      for (size_t j = 0x0000; j < 0x0144; j++) {
        tmpCharBitsTable[j] =
            estimateSymbolLength(tmpCharCountTable[j], totalCount);
        tmpCharCountTable[j] = (tmpCharCountTable[j] + 1) >> 1;
      }
      totalCount = 0;
      for (size_t j = 0x0180; j < 0x019C; j++)
        totalCount += tmpCharCountTable[j];
      for (size_t j = 0x0180; j < 0x019C; j++) {
        tmpCharBitsTable[j] =
            estimateSymbolLength(tmpCharCountTable[j], totalCount);
        tmpCharCountTable[j] = (tmpCharCountTable[j] + 1) >> 1;
      }
    }
    // apply statistical compression
    huffmanCompressBlock(tmpBuf);
    size_t  uncompressedSize = ((nBytes + 4) * 8) + 2;
    size_t  compressedSize = 0;
    for (size_t i = 0; i < tmpBuf.size(); i++)
      compressedSize += size_t(tmpBuf[i] >> 24);
    if (compressedSize >= uncompressedSize) {
      // if cannot reduce the data size, store without compression
      for (size_t i = 0; i < 3; i++)
        tmpOutBuf.push_back(tmpBuf[i]);
      tmpOutBuf.push_back(0x01000000U);
      for (size_t i = offs; i < endPos; i++)
        tmpOutBuf.push_back(0x08000000U | (unsigned int) inBuf[i]);
    }
    else {
      // append compressed data to output buffer
      for (size_t i = 0; i < tmpBuf.size(); i++)
        tmpOutBuf.push_back(tmpBuf[i]);
    }
    return true;
  }

  void PRGCompressor::progressMessage(const char *msg)
  {
    if (msg == (char *) 0)
      msg = "";
    progressMessageCallback(progressMessageUserData, msg);
  }

  bool PRGCompressor::setProgressPercentage(int n)
  {
    n = (n > 0 ? (n < 100 ? n : 100) : 0);
    if (n != prvProgressPercentage) {
      prvProgressPercentage = n;
      return progressPercentageCallback(progressPercentageUserData, n);
    }
    return true;
  }

  // --------------------------------------------------------------------------

  PRGCompressor::PRGCompressor(std::vector< unsigned char >& outBuf_)
    : config(),
      outBuf(outBuf_),
      lengthCodeTable((unsigned short *) 0),
      lengthBitsTable((unsigned char *) 0),
      lengthValueTable((unsigned int *) 0),
      distanceCodeTable((unsigned short *) 0),
      distanceBitsTable((unsigned char *) 0),
      distanceValueTable((unsigned int *) 0),
      tmpCharCountTable((size_t *) 0),
      tmpCharBitsTable((size_t *) 0),
      searchTable((SearchTable *) 0),
      progressCnt(0),
      progressMax(1),
      progressDisplayEnabled(false),
      haveDecompressCode(false),
      outputShiftReg(0x00),
      outputBitCnt(0),
      progressMessageCallback(&defaultProgressMessageCb),
      progressMessageUserData((void *) 0),
      progressPercentageCallback(&defaultProgressPercentageCb),
      progressPercentageUserData((void *) 0),
      prvProgressPercentage(-1)
  {
    try {
      outBuf.resize(0);
      lengthCodeTable = new unsigned short[maxRepeatLen + 1];
      lengthBitsTable = new unsigned char[maxRepeatLen + 1];
      lengthValueTable = new unsigned int[maxRepeatLen + 1];
      distanceCodeTable = new unsigned short[maxRepeatDist + 1];
      distanceBitsTable = new unsigned char[maxRepeatDist + 1];
      distanceValueTable = new unsigned int[maxRepeatDist + 1];
      tmpCharCountTable = new size_t[512];
      tmpCharBitsTable = new size_t[512];
      initializeLengthCodeTables();
      for (size_t i = 0; i < 512; i++) {
        tmpCharCountTable[i] = 1;
        tmpCharBitsTable[i] = (i < 0x0180 ? 9 : 5);
      }
      for (size_t i = 0; i < 4; i++)
        prvDistances[i] = 0;
    }
    catch (...) {
      if (lengthCodeTable)
        delete[] lengthCodeTable;
      if (lengthBitsTable)
        delete[] lengthBitsTable;
      if (lengthValueTable)
        delete[] lengthValueTable;
      if (distanceCodeTable)
        delete[] distanceCodeTable;
      if (distanceBitsTable)
        delete[] distanceBitsTable;
      if (distanceValueTable)
        delete[] distanceValueTable;
      if (tmpCharCountTable)
        delete[] tmpCharCountTable;
      if (tmpCharBitsTable)
        delete[] tmpCharBitsTable;
      throw;
    }
  }

  PRGCompressor::~PRGCompressor()
  {
    delete[] lengthCodeTable;
    delete[] lengthBitsTable;
    delete[] lengthValueTable;
    delete[] distanceCodeTable;
    delete[] distanceBitsTable;
    delete[] distanceValueTable;
    delete[] tmpCharCountTable;
    delete[] tmpCharBitsTable;
    if (searchTable)
      delete searchTable;
  }

  void PRGCompressor::getCompressionParameters(CompressionParameters& cfg) const
  {
    cfg = config;
  }

  void PRGCompressor::setCompressionParameters(const CompressionParameters& cfg)
  {
    config = cfg;
  }

  void PRGCompressor::addDecompressCode(bool c16Mode)
  {
    if (!haveDecompressCode) {
      if (outBuf.size() > 0) {
        throw Plus4Emu::Exception("internal error: "
                                  "adding decompress code to non-empty buffer");
      }
      for (size_t i = 0; i < 0x02A9; i++)
        outBuf.push_back(decomp_code[i]);
      outBuf.push_back(0x00);   // reserve space for CRC byte
      haveDecompressCode = true;
    }
    if (c16Mode) {
      for (size_t i = 0; i < 0x0014; i++)
        outBuf[i] = decomp_code_c16[i];
    }
    else {
      for (size_t i = 0; i < 0x0014; i++)
        outBuf[i] = decomp_code[i];
    }
  }

  void PRGCompressor::addDecompressEndCode(long runAddr, bool isLastBlock,
                                           bool noCleanup, bool noCLI,
                                           bool noROM)
  {
    std::vector< unsigned char >  tmpBuf;
    for (size_t i = 0; i < size_t(runAddr == -1L ? 0x0021 : 0x001B); i++) {
      if ((noCleanup && (i <= 0x0012 && i != 0x000F)) ||
          (noCLI && i == 0x001A) ||
          (noROM && (i >= 0x0017 && i <= 0x0019))) {
        continue;
      }
      tmpBuf.push_back(decomp_code_2[i]);
    }
    if (runAddr != -1L) {
      // if not 'run':
      if (!(runAddr >= 0L && runAddr <= 0xFFFFL)) {
        if (runAddr == -2L)
          runAddr = 0x867EL;            // 'ready'
        else
          runAddr = 0xFF52L;            // monitor
      }
      tmpBuf.push_back((unsigned char) 0x4C);
      tmpBuf.push_back((unsigned char) (runAddr & 0xFFL));
      tmpBuf.push_back((unsigned char) ((runAddr >> 8) & 0xFFL));
    }
    compressData(tmpBuf, 0x03E7U, isLastBlock, false);
  }

  void PRGCompressor::addZeroPageUpdate(unsigned int endAddr, bool isLastBlock)
  {
    std::vector< unsigned char >  tmpBuf;
    tmpBuf.push_back((unsigned char) (endAddr & 0xFFU));
    tmpBuf.push_back((unsigned char) ((endAddr >> 8) & 0xFFU));
    tmpBuf.push_back((unsigned char) (endAddr & 0xFFU));
    tmpBuf.push_back((unsigned char) ((endAddr >> 8) & 0xFFU));
    tmpBuf.push_back((unsigned char) (endAddr & 0xFFU));
    tmpBuf.push_back((unsigned char) ((endAddr >> 8) & 0xFFU));
    compressData(tmpBuf, 0x096DU, false, false);
    tmpBuf.resize(2);
    compressData(tmpBuf, 0x09DDU, isLastBlock, false);
  }

  bool PRGCompressor::compressData(const std::vector< unsigned char >& inBuf,
                                   unsigned int startAddr, bool isLastBlock,
                                   bool enableProgressDisplay)
  {
    if (outputBitCnt < 0)
      throw Plus4Emu::Exception("internal error: compressing to closed buffer");
    if (inBuf.size() < 1)
      return true;
    try {
      progressDisplayEnabled = enableProgressDisplay;
      if (enableProgressDisplay) {
        progressMessage("Compressing PRG data");
        setProgressPercentage(0);
      }
      if (searchTable) {
        delete searchTable;
        searchTable = (SearchTable *) 0;
      }
      searchTable = new SearchTable(inBuf);
      // split large files to improve statistical compression
      std::list< size_t >   splitPositions;
      size_t  prvPos = 0x7FFFFFFFUL;
      size_t  splitCnt = size_t(1) << config.splitOptimizationDepth;
      for (size_t i = 0; i <= splitCnt; i++) {
        size_t  tmp = inBuf.size() * i / splitCnt;
        if (tmp != prvPos) {
          splitPositions.push_back(tmp);
          prvPos = tmp;
        }
      }
      progressCnt = 0;
      while (true) {
        std::vector< unsigned int > tmpBuf;
        bool    mergeFlag = false;
        progressMax =
            progressCnt + (config.optimizeIterations * inBuf.size() * 8);
        std::list< size_t >::iterator i_0 = splitPositions.begin();
        while (i_0 != splitPositions.end()) {
          std::list< size_t >::iterator i_1 = i_0;
          i_1++;
          if (i_1 == splitPositions.end())
            break;
          std::list< size_t >::iterator i_2 = i_1;
          i_2++;
          if (i_2 == splitPositions.end())
            break;
          size_t  compressedSizeSplit = 0;
          size_t  compressedSizeMerged = 0;
          tmpBuf.resize(0);
          if (!compressData(tmpBuf, inBuf, startAddr, false,
                            size_t(*i_0), size_t(*i_1) - size_t(*i_0))) {
            if (searchTable) {
              delete searchTable;
              searchTable = (SearchTable *) 0;
            }
            progressMessage("");
            return false;
          }
          for (size_t i = 0; i < tmpBuf.size(); i++)
            compressedSizeSplit += size_t(tmpBuf[i] >> 24);
          tmpBuf.resize(0);
          if (!compressData(tmpBuf, inBuf, startAddr, false,
                            size_t(*i_1), size_t(*i_2) - size_t(*i_1))) {
            if (searchTable) {
              delete searchTable;
              searchTable = (SearchTable *) 0;
            }
            progressMessage("");
            return false;
          }
          for (size_t i = 0; i < tmpBuf.size(); i++)
            compressedSizeSplit += size_t(tmpBuf[i] >> 24);
          tmpBuf.resize(0);
          if (!compressData(tmpBuf, inBuf, startAddr, false,
                            size_t(*i_0), size_t(*i_2) - size_t(*i_0))) {
            if (searchTable) {
              delete searchTable;
              searchTable = (SearchTable *) 0;
            }
            progressMessage("");
            return false;
          }
          for (size_t i = 0; i < tmpBuf.size(); i++)
            compressedSizeMerged += size_t(tmpBuf[i] >> 24);
          if (compressedSizeMerged <= compressedSizeSplit) {
            i_0 = splitPositions.erase(i_1);
            mergeFlag = true;
          }
          else
            i_0 = i_1;
        }
        if (!mergeFlag)
          break;
      }
      std::vector< unsigned int >   outBufTmp;
      progressMax = progressCnt + (config.optimizeIterations * inBuf.size());
      std::list< size_t >::iterator i_ = splitPositions.begin();
      while (i_ != splitPositions.end()) {
        size_t  startPos = size_t(*i_);
        i_++;
        if (i_ == splitPositions.end())
          break;
        size_t  endPos = size_t(*i_);
        if (!compressData(outBufTmp, inBuf, startAddr,
                          (isLastBlock && endPos == inBuf.size()),
                          startPos, endPos - startPos)) {
          if (searchTable) {
            delete searchTable;
            searchTable = (SearchTable *) 0;
          }
          progressMessage("");
          return false;
        }
      }
      delete searchTable;
      searchTable = (SearchTable *) 0;
      if (progressDisplayEnabled) {
        setProgressPercentage(100);
        progressMessage("");
      }
      // pack output data
      if (outBuf.size() == 0)
        outBuf.push_back((unsigned char) 0x00); // reserve space for CRC value
      for (size_t i = 0; i < outBufTmp.size(); i++) {
        unsigned int  c = outBufTmp[i];
        unsigned int  nBits = c >> 24;
        if (nBits > 16U)
          throw Plus4Emu::Exception("internal error: Huffman code > 16 bits");
        c = c & 0x00FFFFFFU;
        for (unsigned int j = nBits; j > 0U; ) {
          j--;
          unsigned int  b = (unsigned int) (bool(c & (1U << j)));
          outputShiftReg = ((outputShiftReg & 0x7F) << 1) | (unsigned char) b;
          if (++outputBitCnt >= 8) {
            outBuf.push_back(outputShiftReg);
            outputShiftReg = 0x00;
            outputBitCnt = 0;
          }
        }
      }
      if (isLastBlock) {
        while (outputBitCnt != 0) {
          outputShiftReg = ((outputShiftReg & 0x7F) << 1);
          if (++outputBitCnt >= 8) {
            outBuf.push_back(outputShiftReg);
            outputShiftReg = 0x00;
            outputBitCnt = 0;
          }
        }
        // calculate CRC
        size_t  crcPos = (haveDecompressCode ? 0x02A9 : 0x0000);
        unsigned char crcVal = 0x00;
        for (size_t i = outBuf.size() - 1; i > crcPos; i--) {
          unsigned int  tmp = (unsigned int) crcVal ^ (unsigned int) outBuf[i];
          tmp = ((tmp << 1) + ((tmp & 0x80U) >> 7) + 0xC4U) & 0xFFU;
          crcVal = (unsigned char) tmp;
        }
        crcVal = (unsigned char) ((0x180 - 0xC4) >> 1) ^ crcVal;
        outBuf[crcPos] = crcVal;
        outputBitCnt = -1;      // set output buffer closed flag
      }
    }
    catch (...) {
      if (searchTable) {
        delete searchTable;
        searchTable = (SearchTable *) 0;
      }
      progressMessage("");
      throw;
    }
    return true;
  }

  void PRGCompressor::setProgressMessageCallback(void (*func)(void *userData,
                                                              const char *msg),
                                                 void *userData_)
  {
    if (func) {
      progressMessageCallback = func;
      progressMessageUserData = userData_;
    }
    else {
      progressMessageCallback = &defaultProgressMessageCb;
      progressMessageUserData = (void *) 0;
    }
  }

  void PRGCompressor::setProgressPercentageCallback(bool (*func)(void *userData,
                                                                 int n),
                                                    void *userData_)
  {
    if (func) {
      progressPercentageCallback = func;
      progressPercentageUserData = userData_;
    }
    else {
      progressPercentageCallback = &defaultProgressPercentageCb;
      progressPercentageUserData = (void *) 0;
    }
  }

}       // namespace Plus4FLIConv

