
// p4fliconv: high resolution interlaced FLI converter utility
// Copyright (C) 2007-2008 Istvan Varga <istvanv@users.sourceforge.net>
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// The Plus/4 program files generated by this utility are not covered by the
// GNU General Public License, and can be used, modified, and distributed
// without any restrictions.

#include "p4fliconv.hpp"
#include "p4slib.hpp"
#include "imgwrite.hpp"

#include <string>
#include <vector>
#include <map>

int main(int argc, char **argv)
{
  bool    printUsageFlag = false;
  bool    helpFlag = false;
  try {
    Plus4FLIConv::FLIConfiguration  config;
    config.resetDefaultSettings();
    std::string infileName = "";
    std::string outfileName = "";
    {
      std::vector< std::string >    args;
      std::map< std::string, std::vector< std::string > >   optionTable;
      optionTable["-border"].push_back("i:borderColor");
      optionTable["-outfmt"].push_back("i:outputFileFormat");
      optionTable["-compress"].push_back("i:prgCompressionLevel");
      bool    endOfOptions = false;
      size_t  skipCnt = 0;
      for (int i = 1; i < argc; i++) {
        const char  *s = argv[i];
        if (s == (char *) 0 || s[0] == '\0')
          continue;
        if (skipCnt > 0) {
          args.push_back(s);
          skipCnt--;
          continue;
        }
#ifdef __APPLE__
        if (std::strncmp(s, "-psn_", 5) == 0)
          continue;
#endif
        if (s[0] != '-' || endOfOptions) {
          if (infileName == "") {
            infileName = s;
          }
          else if (outfileName == "") {
            outfileName = s;
          }
          else {
            printUsageFlag = true;
            throw Plus4Emu::Exception("too many file name arguments");
          }
          continue;
        }
        if (std::strcmp(s, "--") == 0) {
          endOfOptions = true;
          continue;
        }
        if (std::strcmp(s, "-h") == 0 ||
            std::strcmp(s, "-help") == 0 ||
            std::strcmp(s, "--help") == 0) {
          helpFlag = true;
          throw Plus4Emu::Exception("");
        }
        if (optionTable.find(s) == optionTable.end()) {
          printUsageFlag = true;
          throw Plus4Emu::Exception("invalid command line option");
        }
        args.push_back(s);
        skipCnt = optionTable[s].size();
      }
      if (skipCnt > 0) {
        printUsageFlag = true;
        throw Plus4Emu::Exception("missing argument(s) "
                                  "for command line option");
      }
      if (infileName == "" || outfileName == "") {
        printUsageFlag = true;
        throw Plus4Emu::Exception("missing file name");
      }
      for (size_t i = 0; i < args.size(); i++) {
        std::vector< std::string >&   v = optionTable[args[i]];
        for (size_t j = 0; j < v.size(); j++) {
          char        optionType = v[j][0];
          const char  *optionName = v[j].c_str() + 2;
          i++;
          if (optionType == 'b')
            config[optionName] = bool(std::atoi(args[i].c_str()));
          else if (optionType == 'i')
            config[optionName] = int(std::atoi(args[i].c_str()));
          else if (optionType == 'f')
            config[optionName] = double(std::atof(args[i].c_str()));
        }
      }
    }
    // run in command line mode
    Plus4FLIConv::PRGData   prgData;
    unsigned int  prgStartAddr = 0x1001U;
    unsigned int  prgEndAddr = 0x1003U;
    if (!Plus4FLIConv::readP4SFile(infileName.c_str(),
                                   prgData, prgStartAddr, prgEndAddr)) {
      throw Plus4Emu::Exception("input file is not a PixelShop image");
    }
    if (prgData.getConversionType() < 8) {
      prgData.borderColor() =
          (unsigned char) ((int(config["borderColor"]) & 0x7F) | 0x80);
    }
    config.clearConfigurationChangeFlag();
    Plus4FLIConv::writeConvertedImageFile(outfileName.c_str(), prgData,
                                          prgEndAddr, -1,
                                          int(config["outputFileFormat"]),
                                          int(config["prgCompressionLevel"]));
    return 0;
  }
  catch (std::exception& e) {
    if (printUsageFlag || helpFlag) {
      std::fprintf(stderr, "Usage: %s [OPTIONS...] infile.p4s outfile.prg\n",
                           argv[0]);
      std::fprintf(stderr, "Options:\n");
      std::fprintf(stderr, "    -border <N>         (0 to 255, default: 0)\n");
      std::fprintf(stderr, "        set border color\n");
      std::fprintf(stderr, "    -outfmt <N>         (0 to 3, default: 0)\n");
      std::fprintf(stderr, "        output file format, 0: PRG with viewer, "
                           "1: raw PRG,\n        2: PixelShop P4S, 3: FED "
                           "160x200 multicolor FLI\n");
      std::fprintf(stderr, "    -compress <N>       (0 to 9, default: 0)\n");
      std::fprintf(stderr, "        compress output file if N is not zero\n");
    }
    if (!helpFlag) {
      const char  *errMsg = e.what();
      if (!errMsg)
        errMsg = "";
      std::fprintf(stderr, " *** p4sconv error: %s\n", errMsg);
      return -1;
    }
    return 0;
  }
  return 0;
}

