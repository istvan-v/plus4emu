
// p4fliconv: high resolution interlaced FLI converter utility
// Copyright (C) 2007-2008 Istvan Varga <istvanv@users.sourceforge.net>
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// The Plus/4 program files generated by this utility are not covered by the
// GNU General Public License, and can be used, modified, and distributed
// without any restrictions.

#include "p4fliconv.hpp"
#include "dither.hpp"
#include "imageconv.hpp"
#include "prgdata.hpp"
#include "interlace7.hpp"

static void getDownsampledErrorScaleFactors(double& errScaleL,
                                            double& errScaleC,
                                            int downSampleSize,
                                            double luminanceSearchModeParam,
                                            double colorErrorScale)
{
  double  tmp = double(downSampleSize) / (luminanceSearchModeParam * 0.25);
  errScaleL = (tmp < 1.0 ? tmp : (1.0 / tmp));
  tmp = tmp * 0.5;
  errScaleC = (tmp < 1.0 ? tmp : (1.0 / tmp));
  errScaleL *= double(downSampleSize
                      * (downSampleSize < 4 ? downSampleSize : 4));
  errScaleC *= double(downSampleSize
                      * (downSampleSize < 4 ? downSampleSize : 4));
  errScaleC *= colorErrorScale;
}

namespace Plus4FLIConv {

  P4FLI_Interlace7::Line320::Line320()
    : xShift(0)
  {
    buf = new float[352];
    for (size_t i = 0; i < 352; i++)
      buf[i] = 0.0f;
  }

  P4FLI_Interlace7::Line320::Line320(const Line320& r)
    : xShift(r.xShift)
  {
    buf = new float[352];
    for (size_t i = 0; i < 352; i++)
      buf[i] = r.buf[i];
  }

  P4FLI_Interlace7::Line320::~Line320()
  {
    delete[] buf;
  }

  P4FLI_Interlace7::Line320&
      P4FLI_Interlace7::Line320::operator=(const Line320& r)
  {
    xShift = r.xShift;
    for (size_t i = 0; i < 352; i++)
      buf[i] = r.buf[i];
    return (*this);
  }

  void P4FLI_Interlace7::Line320::clear()
  {
    for (size_t i = 16; i < 336; i++)
      buf[i] = 0.0f;
  }

  void P4FLI_Interlace7::Line320::setBorderColor(float c)
  {
    for (size_t i = 0; i < 16; i++) {
      buf[i] = c;
      buf[i + 336] = c;
    }
  }

  // --------------------------------------------------------------------------

  P4FLI_Interlace7::Image320x496::Image320x496()
  {
    buf = new Line320[496];
  }

  P4FLI_Interlace7::Image320x496::Image320x496(const Image320x496& r)
  {
    buf = new Line320[496];
    for (size_t i = 0; i < 496; i++)
      buf[i] = r.buf[i];
  }

  P4FLI_Interlace7::Image320x496&
      P4FLI_Interlace7::Image320x496::operator=(const Image320x496& r)
  {
    for (size_t i = 0; i < 496; i++)
      buf[i] = r.buf[i];
    return (*this);
  }

  P4FLI_Interlace7::Image320x496::~Image320x496()
  {
    delete[] buf;
  }

  // --------------------------------------------------------------------------

  P4FLI_Interlace7::YUVImage320x496::YUVImage320x496()
  {
  }

  P4FLI_Interlace7::YUVImage320x496::YUVImage320x496(const YUVImage320x496& r)
    : imageY(r.imageY),
      imageU(r.imageU),
      imageV(r.imageV)
  {
  }

  P4FLI_Interlace7::YUVImage320x496::~YUVImage320x496()
  {
  }

  P4FLI_Interlace7::YUVImage320x496&
      P4FLI_Interlace7::YUVImage320x496::operator=(const YUVImage320x496& r)
  {
    imageY = r.imageY;
    imageU = r.imageU;
    imageV = r.imageV;
    return (*this);
  }

  // --------------------------------------------------------------------------

  P4FLI_Interlace7::P4FLI_Interlace7()
    : monitorGamma(2.2),
      ditherLimit(0.25),
      ditherScale(0.95),
      ditherMode(1),
      luminanceSearchMode(2),
      luminanceSearchModeParam(4.0),
      colorErrorScale(0.5),
      xShift0(-1),
      xShift1(-1),
      borderColor(0x00),
      nLines(464),
      colorInterlaceMode(1),
      conversionQuality(6),
      disablePAL(false),
      disableInterlace(false),
      luminance1BitMode(false),
      noLuminanceInterlace(false),
      enable40ColumnMode(false),
      paletteY((float *) 0),
      paletteU((float *) 0),
      paletteV((float *) 0)
  {
    paletteY = new float[3 * 128];
    paletteU = &(paletteY[128]);
    paletteV = &(paletteY[256]);
    for (int i = 0; i < 128; i++) {
      FLIConverter::convertPlus4Color(i, paletteY[i], paletteU[i], paletteV[i],
                                      1.0);
    }
    createYTable();
    createUVTables();
  }

  P4FLI_Interlace7::~P4FLI_Interlace7()
  {
    delete[] paletteY;
  }

  void P4FLI_Interlace7::pixelStoreCallback(void *userData, int xc, int yc,
                                            float y, float u, float v)
  {
    P4FLI_Interlace7&  this_ =
        *(reinterpret_cast<P4FLI_Interlace7 *>(userData));
    if (!this_.enable40ColumnMode)
      xc = xc + 16;
    this_.resizedImage.y()[yc][xc >> 1] += (y * 0.5f);
    this_.resizedImage.u()[yc][xc >> 1] += (u * 0.5f);
    this_.resizedImage.v()[yc][xc >> 1] += (v * 0.5f);
  }

  void P4FLI_Interlace7::colorToUV(int c, float& u, float& v)
  {
    float   y = 0.0f;
    FLIConverter::convertPlus4Color(c, y, u, v, monitorGamma * 0.44);
  }

  void P4FLI_Interlace7::createYTable()
  {
    for (int i = 0; i < 9; i++) {
      float   u = 0.0f;
      float   v = 0.0f;
      FLIConverter::convertPlus4Color((i == 0 ? 0 : (((i - 1) << 4) + 1)),
                                      ditherYTable[i], u, v,
                                      monitorGamma * 0.58666667);
      FLIConverter::convertPlus4Color((i == 0 ? 0 : (((i - 1) << 4) + 1)),
                                      errorYTable[i], u, v,
                                      monitorGamma * 0.44);
    }
  }

  void P4FLI_Interlace7::createUVTables()
  {
    static const unsigned char  colorIndexTable[86] = {
       1,  1,   2,  2,  12, 12,   7,  7,   6,  6,  15, 15,   4,  4,   8,  8,
       3,  3,  10, 10,  14, 14,   9,  9,  13, 13,   5,  5,  11, 11,   2,  8,
       3, 12,  10,  7,   6, 14,   5, 15,   4, 11,   9,  8,   3, 13,  10, 15,
       4, 14,   9,  7,   6, 13,   5, 12,   2, 11,   1,  2,  12,  1,   7,  1,
       1,  6,  15,  1,   1,  4,   8,  1,   1,  3,   1, 10,  14,  1,   1,  9,
      13,  1,   1,  5,  11,  1
    };
    for (int i = 0; i < 43; i++) {
      int     c0 = colorIndexTable[i << 1];
      int     c1 = colorIndexTable[(i << 1) + 1];
      uvTable[i].c0 = c0;
      uvTable[i].c1 = c1;
      float   u0 = 0.0f;
      float   v0 = 0.0f;
      float   u1 = 0.0f;
      float   v1 = 0.0f;
      colorToUV(c0, u0, v0);
      colorToUV(c1, u1, v1);
      uvTable[i].u = (u0 + u1) * 0.5f;
      uvTable[i].v = (v0 + v1) * 0.5f;
      uvTable[i].err = (calculateErrorSqr(u0, u1) + calculateErrorSqr(v0, v1))
                       / 20.0;
    }
  }

  void P4FLI_Interlace7::checkParameters()
  {
    limitValue(monitorGamma, 1.0, 4.0);
    limitValue(ditherLimit, 0.0, 2.0);
    limitValue(ditherScale, 0.0, 1.0);
    limitValue(ditherMode, -1, 5);
    limitValue(luminanceSearchMode, 0, 6);
    if (ditherMode < 0) {
      colorInterlaceMode = 0;
      disablePAL = true;
    }
    switch (luminanceSearchMode) {
    case 2:
      limitValue(luminanceSearchModeParam, 1.0, 16.0);
      break;
    case 4:
      limitValue(luminanceSearchModeParam, 0.0, 0.5);
      break;
    case 5:
      limitValue(luminanceSearchModeParam, 0.0, 0.25);
      break;
    case 6:
      limitValue(luminanceSearchModeParam, 1.0, 16.0);
      if (ditherMode >= 0 && ditherMode < 2) {
        throw Plus4Emu::Exception("-searchmode 6 does not support "
                                  "ordered dither types");
      }
      if (xShift0 != 0 || xShift1 != 0) {
        throw Plus4Emu::Exception("-searchmode 6 does not support X shift");
      }
      break;
    default:
      limitValue(luminanceSearchModeParam, 0.0, 1.0);
      break;
    }
    limitValue(colorErrorScale, 0.05, 1.0);
    limitValue(xShift0, -2, 7);
    limitValue(xShift1, -2, 7);
    borderColor = (borderColor & 0x7F) | 0x80;
    limitValue(nLines, 256, 496);
    nLines = (nLines + 7) & (~(int(7)));
    limitValue(colorInterlaceMode, 0, 2);
    limitValue(conversionQuality, 1, 30);
  }

  void P4FLI_Interlace7::ditherPixel(PRGData& prgData, long xc, long yc)
  {
    if (xc < 0L || xc >= 320L || yc < 0L || yc >= 496L)
      return;
    long    xcShifted = xc - resizedImage.y()[yc].getXShift();
    if (xcShifted < 0L)
      return;
    int     l0 = prgData.l0(xcShifted, yc);
    int     l1 = prgData.l1(xcShifted, yc);
    float   pixelValueOriginal_ = resizedImage.y()[yc].getPixel(xc);
    float   pixelValueOriginal =
        float(std::pow(double(pixelValueOriginal_), 1.33333333));
    float   ditherError = ditherErrorImage.y()[yc].getPixel(xc);
    float   pixelValueDithered = pixelValueOriginal + ditherError;
    float   pixelValue0 = ditherYTable[l0];
    float   pixelValue1 = ditherYTable[l1];
    float   pixelValue0_ = errorYTable[l0];
    float   pixelValue1_ = errorYTable[l1];
    bool    bitValue = false;
    if (ditherMode >= 0 && ditherMode < 2 && pixelValue1 > pixelValue0) {
      // ordered dithering
      float   tmp = pixelValueOriginal;
      if (tmp < pixelValue0)
        tmp = pixelValue0;
      if (tmp > pixelValue1)
        tmp = pixelValue1;
      tmp = (tmp - pixelValue0) / (pixelValue1 - pixelValue0);
      if (ditherMode == 0) {
        if (ditherPixelValue_Bayer(xc, yc, tmp))
          pixelValueDithered = pixelValue1;
        else
          pixelValueDithered = pixelValue0;
      }
      else {
        if (ditherPixelValue(xc, yc, tmp))
          pixelValueDithered = pixelValue1;
        else
          pixelValueDithered = pixelValue0;
      }
    }
    bitValue = (calculateError(pixelValue1, pixelValueDithered)
                < calculateError(pixelValue0, pixelValueDithered));
    // save quantized pixel value for error calculation
    float   newPixelValue = (bitValue ? pixelValue1 : pixelValue0);
    if (calculateError(calculateError(pixelValue1_, pixelValueOriginal_),
                       calculateError(pixelValue0_, pixelValueOriginal_))
        >= ditherLimit) {
      bitValue = (calculateError(pixelValue1_, pixelValueOriginal_)
                  < calculateError(pixelValue0_, pixelValueOriginal_));
    }
    prgData.setPixel(xcShifted, yc, bitValue);
    if (ditherMode < 2)
      return;
    // diffuse error
    pixelValueDithered = pixelValueOriginal
                         + ((pixelValueDithered - pixelValueOriginal)
                            * float(ditherScale));
    if (pixelValueDithered < pixelValue0)
      pixelValueDithered = pixelValue0;
    if (pixelValueDithered > pixelValue1)
      pixelValueDithered = pixelValue1;
    double  err = double(pixelValueDithered) - double(newPixelValue);
    const int *errMultTbl = &(ditherTable_FloydSteinberg[0]);
    switch (ditherMode) {
    case 3:
      errMultTbl = &(ditherTable_Jarvis[0]);
      break;
    case 4:
      errMultTbl = &(ditherTable_Stucki[0]);
      break;
    case 5:
      errMultTbl = &(ditherTable_Sierra2[0]);
      break;
    }
    for (int i = 0; i < 12; i++) {
      if (errMultTbl[i + 1] == 0)
        continue;
      long    yc_ = yc + ((i + 3) / 5);
      if (yc_ >= 496L)
        break;
      long    xc_ = ((i + 3) % 5) - 2;
      xc_ = ((yc & 1L) == 0L ? (xc + xc_) : (xc - xc_));
      float   tmp = float(errMultTbl[i + 1]) / float(errMultTbl[0]);
      ditherErrorImage.y()[yc_].setPixel(xc_,
                                         ditherErrorImage.y()[yc_].getPixel(xc_)
                                         + (float(err) * tmp));
    }
  }

  inline double P4FLI_Interlace7::calculateLuminanceError(float n,
                                                          int l0, int l1)
  {
    float   l_0 = errorYTable[l0];
    float   l_1 = errorYTable[l1];
    double  err0 = calculateErrorSqr(l_0, n);
    double  err1 = calculateErrorSqr(l_1, n);
    double  err = (err0 < err1 ? err0 : err1);
    if (luminanceSearchMode == 2 && (n < l_0 || n > l_1))
      err *= luminanceSearchModeParam;
    if (luminanceSearchMode == 4) {
      double  tmp = 0.5 + luminanceSearchModeParam;
      double  l_0_ = (double(l_0) * tmp) + (double(l_1) * (1.0 - tmp));
      double  l_1_ = (double(l_0) * (1.0 - tmp)) + (double(l_1) * tmp);
      double  err0_ = calculateErrorSqr(l_0_, n);
      double  err1_ = calculateErrorSqr(l_1_, n);
      double  err_ = (err0_ > err1_ ? err0_ : err1_);
      err = (err_ < err ? err_ : err);
    }
    return err;
  }

  double P4FLI_Interlace7::findLuminanceCodes(PRGData& prgData,
                                              long xc, long yc)
  {
    int     l0 = 0;
    int     l1 = 8;
    xc = xc & (~(long(7)));
    yc = yc & (~(long(noLuminanceInterlace ? 3 : 2)));
    float   tmpBuf[32];
    int     nPixels = (noLuminanceInterlace ? 32 : 16);
    for (int i = 0; i < nPixels; i++) {
      long    x_ = xc | long(i & 7);
      long    y_ = yc | long((i & 8) >> 2) | long(i >> 4);
      tmpBuf[i] = resizedImage.y()[y_].getPixelShifted(x_);
    }
    if (!luminance1BitMode) {
      // find the best pair of luminance values, depending on the search mode
      int     l0min = 8;
      int     l1max = 0;
      if (luminanceSearchMode >= 2 && luminanceSearchMode <= 4) {
        for (int i = 0; i < nPixels; i++) {
          while (l0min > 0 && tmpBuf[i] < errorYTable[l0min])
            l0min--;
          while (l1max < 8 && tmpBuf[i] > errorYTable[l1max])
            l1max++;
        }
        if (l0min == l1max) {
          if (l1max < 8)
            l1max++;
          else
            l0min--;
        }
      }
      else {
        float   minVal = 1.0f;
        float   maxVal = 0.0f;
        for (int i = 0; i < nPixels; i++) {
          if (tmpBuf[i] < minVal)
            minVal = tmpBuf[i];
          if (tmpBuf[i] > maxVal)
            maxVal = tmpBuf[i];
        }
        double  minErr0 = 1000000.0;
        double  minErr1 = 1000000.0;
        for (int i = 0; i < 9; i++) {
          double  err = calculateError(errorYTable[i], minVal);
          if (err < minErr0) {
            l0min = i;
            minErr0 = err;
          }
          err = calculateError(errorYTable[i], maxVal);
          if (err < minErr1) {
            l1max = i;
            minErr1 = err;
          }
        }
        if (l0min == l1max) {
          if (minErr0 < minErr1) {
            if (l1max < 8)
              l1max++;
            else
              l0min--;
          }
          else {
            if (l0min > 0)
              l0min--;
            else
              l1max++;
          }
        }
      }
      if (luminanceSearchMode == 1 || luminanceSearchMode == 3) {
        l0 = l0min;
        l1 = l1max;
      }
      else {
        double  minErr = 1000000.0f;
        for (int l0tmp = l0min; l0tmp < l1max; l0tmp++) {
          for (int l1tmp = l0tmp + 1; l1tmp <= l1max; l1tmp++) {
            float   minVal = errorYTable[l0tmp];
            float   maxVal = errorYTable[l1tmp];
            double  err = 0.0;
            for (int i = 0; i < nPixels; i++) {
              err += calculateLuminanceError(tmpBuf[i], l0tmp, l1tmp);
              err += (calculateErrorSqr(tmpBuf[i], (minVal + maxVal) * 0.5f)
                      * 0.00001);
            }
            if (err < minErr) {
              minErr = err;
              l0 = l0tmp;
              l1 = l1tmp;
            }
          }
        }
        if (luminanceSearchMode == 5) {
          bool    l0DecFlag;
          bool    l1IncFlag;
          do {
            l0DecFlag = false;
            l1IncFlag = false;
            if (l1 < l1max) {
              l1++;
              double  err = 0.0;
              for (int i = 0; i < nPixels; i++)
                err += calculateLuminanceError(tmpBuf[i], l0, l1);
              if ((err - minErr) < (double(nPixels) * luminanceSearchModeParam))
                l1IncFlag = true;
              else
                l1--;
            }
            if (l0 > l0min) {
              l0--;
              double  err = 0.0;
              for (int i = 0; i < nPixels; i++)
                err += calculateLuminanceError(tmpBuf[i], l0, l1);
              if ((err - minErr) < (double(nPixels) * luminanceSearchModeParam))
                l0DecFlag = true;
              else
                l0++;
            }
          } while (l0DecFlag || l1IncFlag);
        }
      }
    }
    // store luminance codes
    prgData.l0(xc, yc) = l0;
    prgData.l1(xc, yc) = l1;
    if (noLuminanceInterlace) {
      prgData.l0(xc, yc + 1L) = l0;
      prgData.l1(xc, yc + 1L) = l1;
    }
    // return the total amount of error (used when optimizing horizontal shifts)
    double  err = 0.0;
    for (int i = 0; i < nPixels; i++) {
      long    y_ = yc | long((i & 8) >> 2) | long(i >> 4);
      long    x_ = (xc | long(i & 7)) + resizedImage.y()[y_].getXShift();
      if (x_ >= 8L && x_ < 312L)  // ignore pixels that are not visible
        err += calculateLuminanceError(tmpBuf[i], l0, l1);
    }
    return err;
  }

  void P4FLI_Interlace7::findAttributes_YUVMode(PRGData& prgData,
                                                long xc, long yc,
                                                int& randomSeed)
  {
    xc = xc & (~(long(7)));
    yc = yc & (~(long(3)));
    float   tmpBufY_1x1[32];
    float   tmpBufU_1x1[32];
    float   tmpBufV_1x1[32];
    float   tmpBufY_2x2[8];
    float   tmpBufU_2x2[8];
    float   tmpBufV_2x2[8];
    float   tmpBufY_4x4[2];
    float   tmpBufU_4x4[2];
    float   tmpBufV_4x4[2];
    float   tmpBufY_8x4[1];
    float   tmpBufU_8x4[1];
    float   tmpBufV_8x4[1];
    for (int i = 0; i < 8; i++) {
      tmpBufY_2x2[i] = 0.0f;
      tmpBufU_2x2[i] = 0.0f;
      tmpBufV_2x2[i] = 0.0f;
    }
    for (int i = 0; i < 2; i++) {
      tmpBufY_4x4[i] = 0.0f;
      tmpBufU_4x4[i] = 0.0f;
      tmpBufV_4x4[i] = 0.0f;
    }
    tmpBufY_8x4[0] = 0.0f;
    tmpBufU_8x4[0] = 0.0f;
    tmpBufV_8x4[0] = 0.0f;
    for (int y_ = 0; y_ < 4; y_++) {
      for (int x_ = 0; x_ < 8; x_++) {
        float   y = resizedImage.y()[yc + y_].getPixel(xc + x_);
        float   u = resizedImage.u()[yc + y_].getPixel(xc + x_);
        float   v = resizedImage.v()[yc + y_].getPixel(xc + x_);
        if (!disablePAL) {
          y = y + ditherErrorImage.y()[yc + y_].getPixel(xc + x_);
          u = u + ditherErrorImage.u()[yc + y_].getPixel(xc + x_);
          v = v + ditherErrorImage.v()[yc + y_].getPixel(xc + x_);
          limitYUVColor(y, u, v);
        }
        tmpBufY_1x1[(y_ << 3) + x_] = y;
        tmpBufU_1x1[(y_ << 3) + x_] = u;
        tmpBufV_1x1[(y_ << 3) + x_] = v;
        tmpBufY_2x2[((y_ >> 1) << 2) + (x_ >> 1)] += (y * 0.25f);
        tmpBufU_2x2[((y_ >> 1) << 2) + (x_ >> 1)] += (u * 0.25f);
        tmpBufV_2x2[((y_ >> 1) << 2) + (x_ >> 1)] += (v * 0.25f);
        tmpBufY_4x4[x_ >> 2] += (y * 0.0625f);
        tmpBufU_4x4[x_ >> 2] += (u * 0.0625f);
        tmpBufV_4x4[x_ >> 2] += (v * 0.0625f);
        tmpBufY_8x4[0] += (y * 0.03125f);
        tmpBufU_8x4[0] += (u * 0.03125f);
        tmpBufV_8x4[0] += (v * 0.03125f);
      }
    }
    float   tmpPalette0Y[17];
    float   tmpPalette0U[17];
    float   tmpPalette0V[17];
    float   tmpPalette1Y[17];
    float   tmpPalette1U[17];
    float   tmpPalette1V[17];
    int     bestColor0_0 = 0;
    int     bestColor1_0 = 0;
    int     bestColor0_1 = 0;
    int     bestColor1_1 = 0;
    double  bestError = 1000000.0;
    for (int l = 0; l < conversionQuality; l++) {
      int     color0_0 = Plus4Emu::getRandomNumber(randomSeed) & 0x7F;
      int     color1_0 = Plus4Emu::getRandomNumber(randomSeed) & 0x7F;
      int     color0_1 = Plus4Emu::getRandomNumber(randomSeed) & 0x7F;
      int     color1_1 = Plus4Emu::getRandomNumber(randomSeed) & 0x7F;
      if ((color0_0 & 0x0F) == 0)
        color0_0 = 0;
      else if (luminance1BitMode)
        color0_0 = color0_0 | 0x70;
      if ((color1_0 & 0x0F) == 0)
        color1_0 = 0;
      else if (luminance1BitMode)
        color1_0 = color1_0 | 0x70;
      if ((color0_1 & 0x0F) == 0)
        color0_1 = 0;
      else if (luminance1BitMode)
        color0_1 = color0_1 | 0x70;
      if ((color1_1 & 0x0F) == 0)
        color1_1 = 0;
      else if (luminance1BitMode)
        color1_1 = color1_1 | 0x70;
      double  minErr = 1000000.0;
      bool    doneFlag = false;
      do {
        doneFlag = true;
        for (int i = 0; i < 4; i++) {
          int&    colorValue =
              (i == 0 ? color0_0 : (i == 1 ? color1_0
                                             : (i == 2 ? color0_1 : color1_1)));
          int     bestColor = colorValue;
          for (int c = 0; c < 128; c++) {
            if ((c & 0x0F) == 0 && c != 0)
              continue;
            if (luminance1BitMode && c != 0)
              c = c | 0x70;
            colorValue = c;
            for (int j = 0; j < 17; j++) {
              int     tmp = 16;
              if (j > 0) {
                tmp = j - 1;
                // reverse bits
                tmp = ((tmp & 0x0C) >> 2) | ((tmp & 0x03) << 2);
                tmp = ((tmp & 0x0A) >> 1) | ((tmp & 0x05) << 1);
              }
              float   f = float(tmp) * 0.0625f;
              tmpPalette0Y[j] = (paletteY[color0_0] * (1.0f - f))
                                + (paletteY[color1_0] * f);
              tmpPalette0U[j] = (paletteU[color0_0] * (1.0f - f))
                                + (paletteU[color1_0] * f);
              tmpPalette0V[j] = (paletteV[color0_0] * (1.0f - f))
                                + (paletteV[color1_0] * f);
              tmpPalette1Y[j] = (paletteY[color0_1] * (1.0f - f))
                                + (paletteY[color1_1] * f);
              tmpPalette1U[j] = (paletteU[color0_1] * (1.0f - f))
                                + (paletteU[color1_1] * f);
              tmpPalette1V[j] = (paletteV[color0_1] * (1.0f - f))
                                + (paletteV[color1_1] * f);
            }
            double  totalError = 0.0;
            // 1x1 downsample
            double  errScaleL = 1.0;
            double  errScaleC = colorErrorScale;
            if (ditherMode >= 0) {
              getDownsampledErrorScaleFactors(errScaleL, errScaleC, 1,
                                              luminanceSearchModeParam,
                                              colorErrorScale);
            }
            for (int j = 0; j < 32; j++) {
              double  minErr2 = 1000000.0;
              float   y = tmpBufY_1x1[j];
              float   u = tmpBufU_1x1[j];
              float   v = tmpBufV_1x1[j];
              float   *tmpPaletteY =
                  ((j & 8) == 0 ? &(tmpPalette0Y[0]) : &(tmpPalette1Y[0]));
              float   *tmpPaletteU =
                  ((j & 8) == 0 ? &(tmpPalette0U[0]) : &(tmpPalette1U[0]));
              float   *tmpPaletteV =
                  ((j & 8) == 0 ? &(tmpPalette0V[0]) : &(tmpPalette1V[0]));
              for (int k = 0; k < 2; k++) {
                double  err =
                    calculateYUVErrorSqr(tmpPaletteY[k],
                                         tmpPaletteU[k],
                                         tmpPaletteV[k],
                                         y, u, v, errScaleL, errScaleC);
                if (err < minErr2)
                  minErr2 = err;
              }
              totalError += minErr2;
            }
            if (ditherMode >= 0) {
              if (totalError > (minErr * 1.000001))
                continue;
              // 2x2 downsample
              getDownsampledErrorScaleFactors(errScaleL, errScaleC, 2,
                                              luminanceSearchModeParam,
                                              colorErrorScale);
              for (int j = 0; j < 8; j++) {
                double  minErr2 = 1000000.0;
                float   y = tmpBufY_2x2[j];
                float   u = tmpBufU_2x2[j];
                float   v = tmpBufV_2x2[j];
                for (int k0 = 0; k0 < 3; k0++) {
                  for (int k1 = 0; k1 < 3; k1++) {
                    float   y_ = (tmpPalette0Y[k0] + tmpPalette1Y[k1]) * 0.5f;
                    float   u_ = (tmpPalette0U[k0] + tmpPalette1U[k1]) * 0.5f;
                    float   v_ = (tmpPalette0V[k0] + tmpPalette1V[k1]) * 0.5f;
                    double  err = calculateYUVErrorSqr(y_, u_, v_, y, u, v,
                                                       errScaleL, errScaleC);
                    if (err < minErr2)
                      minErr2 = err;
                  }
                }
                totalError += minErr2;
              }
              if (totalError > (minErr * 1.000001))
                continue;
              // 4x4 downsample
              getDownsampledErrorScaleFactors(errScaleL, errScaleC, 4,
                                              luminanceSearchModeParam,
                                              colorErrorScale);
              for (int j = 0; j < 2; j++) {
                double  minErr2 = 1000000.0;
                float   y = tmpBufY_4x4[j];
                float   u = tmpBufU_4x4[j];
                float   v = tmpBufV_4x4[j];
                for (int k0 = 0; k0 < 9; k0++) {
                  for (int k1 = 0; k1 < 9; k1++) {
                    float   y_ = (tmpPalette0Y[k0] + tmpPalette1Y[k1]) * 0.5f;
                    float   u_ = (tmpPalette0U[k0] + tmpPalette1U[k1]) * 0.5f;
                    float   v_ = (tmpPalette0V[k0] + tmpPalette1V[k1]) * 0.5f;
                    double  err = calculateYUVErrorSqr(y_, u_, v_, y, u, v,
                                                       errScaleL, errScaleC);
                    if (err < minErr2)
                      minErr2 = err;
                  }
                }
                totalError += minErr2;
              }
              if (totalError > (minErr * 1.000001))
                continue;
              // 8x4 downsample
              getDownsampledErrorScaleFactors(errScaleL, errScaleC, 8,
                                              luminanceSearchModeParam,
                                              colorErrorScale);
              for (int j = 0; j < 1; j++) {
                double  minErr2 = 1000000.0;
                float   y = tmpBufY_8x4[j];
                float   u = tmpBufU_8x4[j];
                float   v = tmpBufV_8x4[j];
                for (int k0 = 0; k0 < 17; k0++) {
                  for (int k1 = 0; k1 < 17; k1++) {
                    float   y_ = (tmpPalette0Y[k0] + tmpPalette1Y[k1]) * 0.5f;
                    float   u_ = (tmpPalette0U[k0] + tmpPalette1U[k1]) * 0.5f;
                    float   v_ = (tmpPalette0V[k0] + tmpPalette1V[k1]) * 0.5f;
                    double  err = calculateYUVErrorSqr(y_, u_, v_, y, u, v,
                                                       errScaleL, errScaleC);
                    if (err < minErr2)
                      minErr2 = err;
                  }
                }
                totalError += minErr2;
              }
            }
            if (totalError < (minErr * 0.999999)) {
              bestColor = colorValue;
              minErr = totalError;
              doneFlag = false;
            }
          }
          colorValue = bestColor;
        }
      } while (!doneFlag);
      if (minErr < bestError) {
        bestColor0_0 = color0_0;
        bestColor1_0 = color1_0;
        bestColor0_1 = color0_1;
        bestColor1_1 = color1_1;
        bestError = minErr;
      }
    }
    // store luminance and color codes
    int     l0_0 = (bestColor0_0 & 0x70) >> 4;
    int     l1_0 = (bestColor1_0 & 0x70) >> 4;
    int     c0_0 = bestColor0_0 & 0x0F;
    int     c1_0 = bestColor1_0 & 0x0F;
    int     l0_1 = (bestColor0_1 & 0x70) >> 4;
    int     l1_1 = (bestColor1_1 & 0x70) >> 4;
    int     c0_1 = bestColor0_1 & 0x0F;
    int     c1_1 = bestColor1_1 & 0x0F;
    if (c0_0 != 0)
      l0_0++;
    else
      l0_0 = 0;
    if (c1_0 != 0)
      l1_0++;
    else
      l1_0 = 0;
    if (c0_1 != 0)
      l0_1++;
    else
      l0_1 = 0;
    if (c1_1 != 0)
      l1_1++;
    else
      l1_1 = 0;
    prgData.l0(xc, yc) = l0_0;
    prgData.l1(xc, yc) = l1_0;
    prgData.c0(xc, yc) = c0_0;
    prgData.c1(xc, yc) = c1_0;
    prgData.l0(xc, yc + 1L) = l0_1;
    prgData.l1(xc, yc + 1L) = l1_1;
    prgData.c0(xc, yc + 1L) = c0_1;
    prgData.c1(xc, yc + 1L) = c1_1;
  }

  void P4FLI_Interlace7::generateBitmaps(PRGData& prgData)
  {
    for (int yc = 0; yc < nLines; yc += 2) {
      for (int xc = 0; xc < 320; xc++)
        ditherPixel(prgData, xc, yc);
      for (int xc = 319; xc >= 0; xc--)
        ditherPixel(prgData, xc, yc + 1);
    }
    for (int yc = 0; yc < nLines; yc++) {
      if (yc & 2)
        continue;
      for (int xc = 0; xc < 320; xc += 8) {
        // if all bits are 0 or 1, replace the bitmaps with
        // a dither pattern to improve color conversion
        int     b0 = 0;
        int     b1 = 1;
        for (int i = 0; i < 16; i++) {
          bool    tmp = prgData.getPixel(xc | (i & 7), yc | ((i & 8) >> 2));
          b0 = b0 | int(tmp);
          b1 = b1 & int(tmp);
        }
        int&    l0 = prgData.l0(xc, yc);
        int&    l1 = prgData.l1(xc, yc);
        if ((b0 == 0 && l0 != 0) || (b1 == 1 && l1 != 0)) {
          if (b0 == 0)
            l1 = l0;
          else
            l0 = l1;
          for (int i = 0; i < 16; i++) {
            int     tmpY = yc | ((i & 8) >> 2);
            int     tmpX = (xc | (i & 7)) + resizedImage.y()[tmpY].getXShift();
            prgData.setPixel(xc | (i & 7), tmpY,
                             ditherPixelValue(tmpX, tmpY, 0.66667f));
          }
        }
      }
    }
  }

  void P4FLI_Interlace7::ditherLine_YUVMode(PRGData& prgData, long yc)
  {
    // error diffusion dithering
    for (long xc = 0L; xc < 320L; xc++) {
      if ((yc & 1L) != 0L && ditherMode >= 0)
        xc = 319L - xc;
      int     color0 = (prgData.l0(xc, yc & (~(long(2)))) << 4)
                       | prgData.c0(xc, yc & (~(long(2))));
      int     color1 = (prgData.l1(xc, yc & (~(long(2)))) << 4)
                       | prgData.c1(xc, yc & (~(long(2))));
      if ((color0 & 0xF0) != 0)
        color0 = color0 - 0x10;
      else
        color0 = 0x00;
      if ((color1 & 0xF0) != 0)
        color1 = color1 - 0x10;
      else
        color1 = 0x00;
      float   yMin = paletteY[color0];
      float   yMax = paletteY[color1];
      if (yMax < yMin) {
        float   tmp = yMin;
        yMin = yMax;
        yMax = tmp;
      }
      float   uMin = paletteU[color0];
      float   uMax = paletteU[color1];
      if (uMax < uMin) {
        float   tmp = uMin;
        uMin = uMax;
        uMax = tmp;
      }
      float   vMin = paletteV[color0];
      float   vMax = paletteV[color1];
      if (vMax < vMin) {
        float   tmp = vMin;
        vMin = vMax;
        vMax = tmp;
      }
      // find the palette color nearest the original pixel
      float   y0 = resizedImage.y()[yc].getPixel(xc);
      float   u0 = resizedImage.u()[yc].getPixel(xc);
      float   v0 = resizedImage.v()[yc].getPixel(xc);
      int     c0 = color0;
      if (calculateYUVErrorSqr(paletteY[color1],
                               paletteU[color1],
                               paletteV[color1],
                               y0, u0, v0, colorErrorScale)
          < calculateYUVErrorSqr(paletteY[color0],
                                 paletteU[color0],
                                 paletteV[color0],
                                 y0, u0, v0, colorErrorScale)) {
        c0 = color1;
      }
      // find the palette color nearest the original pixel with error added
      float   y = y0 + ditherErrorImage.y()[yc].getPixel(xc);
      float   u = u0 + ditherErrorImage.u()[yc].getPixel(xc);
      float   v = v0 + ditherErrorImage.v()[yc].getPixel(xc);
      limitYUVColor(y, u, v);
      int     c = color0;
      if (calculateYUVErrorSqr(paletteY[color1],
                               paletteU[color1],
                               paletteV[color1],
                               y, u, v, colorErrorScale)
          < calculateYUVErrorSqr(paletteY[color0],
                                 paletteU[color0],
                                 paletteV[color0],
                                 y, u, v, colorErrorScale)) {
        c = color1;
      }
      double  err0 =
          std::sqrt(calculateYUVErrorSqr(paletteY[c0],
                                         paletteU[c0],
                                         paletteV[c0],
                                         y0, u0, v0, colorErrorScale));
      double  err =
          std::sqrt(calculateYUVErrorSqr(paletteY[c],
                                         paletteU[c],
                                         paletteV[c],
                                         y0, u0, v0, colorErrorScale));
      prgData.setPixel(xc, yc,
                       ((calculateError(err, err0) < ditherLimit ? c : c0)
                        != color0));
      if (ditherMode < 0)
        continue;
      y = y0 + ((y - y0) * float(ditherScale));
      u = u0 + ((u - u0) * float(ditherScale));
      v = v0 + ((v - v0) * float(ditherScale));
      float   errY = y - paletteY[c];
      float   errU = u - paletteU[c];
      float   errV = v - paletteV[c];
      const int *errMultTbl = &(ditherTable_FloydSteinberg[0]);
      switch (ditherMode) {
      case 3:
        errMultTbl = &(ditherTable_Jarvis[0]);
        break;
      case 4:
        errMultTbl = &(ditherTable_Stucki[0]);
        break;
      case 5:
        errMultTbl = &(ditherTable_Sierra2[0]);
        break;
      }
      for (int i = 0; i < 12; i++) {
        if (errMultTbl[i + 1] == 0)
          continue;
        long    yc_ = yc + ((i + 3) / 5);
        long    xc_ = ((i + 3) % 5) - 2;
        xc_ = ((yc & 1L) == 0L ? (xc + xc_) : (xc - xc_));
        if (yc_ >= 0L && yc_ < long(nLines) && xc_ >= 0L && xc_ < 320L) {
          float   errMult = float(errMultTbl[i + 1]) / float(errMultTbl[0]);
          ditherErrorImage.y()[yc_].setPixel(
              xc_, ditherErrorImage.y()[yc_].getPixel(xc_) + (errY * errMult));
          ditherErrorImage.u()[yc_].setPixel(
              xc_, ditherErrorImage.u()[yc_].getPixel(xc_) + (errU * errMult));
          ditherErrorImage.v()[yc_].setPixel(
              xc_, ditherErrorImage.v()[yc_].getPixel(xc_) + (errV * errMult));
        }
      }
      if (yc & 1L)
        xc = 319L - xc;
    }
  }

  void P4FLI_Interlace7::findColorCodes(PRGData& prgData,
                                        long xc, long yc, int dir_)
  {
    bool    oddField = bool(yc & 1L);
    float   savedU0[9];
    float   savedV0[9];
    float   savedU1[9];
    float   savedV1[9];
    for (int i = 0; i < 9; i++) {
      savedU0[i] = line0U.getPixelShifted(xc + (i * dir_));
      savedV0[i] = line0V.getPixelShifted(xc + (i * dir_));
      savedU1[i] = line1U.getPixelShifted(xc + (i * dir_));
      savedV1[i] = line1V.getPixelShifted(xc + (i * dir_));
    }
    // find the pair of colors that gives the least amount of error
    int     c0 = 0;
    int     c1 = 0;
    int     l0 = prgData.l0(xc, yc);
    int     l1 = prgData.l1(xc, yc);
    double  minColorErr = 1000000.0;
    int     colorCnt =
        (colorInterlaceMode == 0 ? 15 : (colorInterlaceMode == 2 ? 43 : 29));
    for (int i0 = 0; i0 < colorCnt; i0++) {
      for (int i1 = 0; i1 < colorCnt; i1++) {
        int     c0tmp = 0;
        int     c1tmp = 0;
        double  err = 0.0;
        float   u0 = 0.0f;
        float   v0 = 0.0f;
        float   u1 = 0.0f;
        float   v1 = 0.0f;
        {
          double  err0 = 0.0;
          double  err1 = 0.0;
          if (l0 > 0) {
            c0tmp = (oddField ? uvTable[i0].c1 : uvTable[i0].c0);
            u0 = uvTable[i0].u;
            v0 = uvTable[i0].v;
            err0 = uvTable[i0].err;
          }
          if (l1 > 0) {
            c1tmp = (oddField ? uvTable[i1].c1 : uvTable[i1].c0);
            u1 = uvTable[i1].u;
            v1 = uvTable[i1].v;
            err1 = uvTable[i1].err;
          }
          for (int x = 0; x < 9; x++) {
            bool    b = prgData.getPixel(xc + ((x <= 7 ? x : 7) * dir_), yc);
            float   u_ = (b ? u1 : u0);
            float   v_ = (b ? v1 : v0);
            if (x < 8)
              err += (b ? err1 : err0);
            line0U.setPixelShifted(xc + (x * dir_), u_);
            line0V.setPixelShifted(xc + (x * dir_), v_);
            b = prgData.getPixel(xc + ((x <= 7 ? x : 7) * dir_), yc + 2L);
            u_ = (b ? u1 : u0);
            v_ = (b ? v1 : v0);
            if (x < 8)
              err += (b ? err1 : err0);
            line1U.setPixelShifted(xc + (x * dir_), u_);
            line1V.setPixelShifted(xc + (x * dir_), v_);
          }
        }
        for (int j = 0; j < 16; j++) {
          int     x = j & 7;
          Line320 *l0U = (j < 8 ? (&line0U) : (&line1U));
          Line320 *l0V = (j < 8 ? (&line0V) : (&line1V));
          float   u_ = l0U->getPixelShifted(xc + (x * dir_));
          float   v_ = l0V->getPixelShifted(xc + (x * dir_));
          if (!disablePAL) {
            // assume PAL filtering if requested
            Line320 *lm1U = (j < 8 ? (&prvLineU) : (&line0U));
            Line320 *lm1V = (j < 8 ? (&prvLineV) : (&line0V));
            u_ += lm1U->getPixelShifted(xc + (x * dir_));
            v_ += lm1V->getPixelShifted(xc + (x * dir_));
            u_ *= 0.96f;
            v_ *= 0.96f;
            u_ += (l0U->getPixelShifted(xc + ((x - 1) * dir_)) * 0.52f);
            v_ += (l0V->getPixelShifted(xc + ((x - 1) * dir_)) * 0.52f);
            u_ += (l0U->getPixelShifted(xc + ((x + 1) * dir_)) * 0.52f);
            v_ += (l0V->getPixelShifted(xc + ((x + 1) * dir_)) * 0.52f);
            u_ += (lm1U->getPixelShifted(xc + ((x - 1) * dir_)) * 0.52f);
            v_ += (lm1V->getPixelShifted(xc + ((x - 1) * dir_)) * 0.52f);
            u_ += (lm1U->getPixelShifted(xc + ((x + 1) * dir_)) * 0.52f);
            v_ += (lm1V->getPixelShifted(xc + ((x + 1) * dir_)) * 0.52f);
            u_ *= 0.25f;
            v_ *= 0.25f;
          }
          float   u = resizedImage.u()[yc + ((j & 8) >> 2)].getPixelShifted(
                          xc + (x * dir_));
          float   v = resizedImage.v()[yc + ((j & 8) >> 2)].getPixelShifted(
                          xc + (x * dir_));
          if (disablePAL && l0 == l1) {
            if ((calculateErrorSqr(u1, u) + calculateErrorSqr(v1, v))
                < (calculateErrorSqr(u0, u) + calculateErrorSqr(v0, v))) {
              u_ = u1;
              v_ = v1;
            }
            else {
              u_ = u0;
              v_ = v0;
            }
          }
          err = err + calculateErrorSqr(u_, u) + calculateErrorSqr(v_, v);
          if (err > (minColorErr * 1.000001))
            break;
        }
        if (err < minColorErr) {
          c0 = c0tmp;
          c1 = c1tmp;
          minColorErr = err;
          if (disablePAL && l0 == l1) {
            for (int l = 0; l < 2; l++) {
              for (int x = 0; x < 8; x++) {
                long    xc_ = xc + (x * dir_);
                long    yc_ = yc + (l << 1);
                float   u = resizedImage.u()[yc_].getPixelShifted(xc_);
                float   v = resizedImage.v()[yc_].getPixelShifted(xc_);
                prgData.setPixel(xc_, yc_,
                                 ((calculateErrorSqr(u1, u)
                                   + calculateErrorSqr(v1, v))
                                  < (calculateErrorSqr(u0, u)
                                     + calculateErrorSqr(v0, v))));
              }
            }
          }
        }
        else {
          for (int i = 0; i < 9; i++) {
            line0U.setPixelShifted(xc + (i * dir_), savedU0[i]);
            line0V.setPixelShifted(xc + (i * dir_), savedV0[i]);
            line1U.setPixelShifted(xc + (i * dir_), savedU1[i]);
            line1V.setPixelShifted(xc + (i * dir_), savedV1[i]);
          }
        }
      }
    }
    // store color codes
    prgData.c0(xc, yc) = c0;
    prgData.c1(xc, yc) = c1;
  }

  bool P4FLI_Interlace7::processImage(PRGData& prgData,
                                      unsigned int& prgEndAddr,
                                      const char *infileName,
                                      YUVImageConverter& imgConv,
                                      Plus4Emu::ConfigurationDB& config)
  {
    try {
      monitorGamma = config["monitorGamma"];
      ditherLimit = config["ditherLimit"];
      ditherScale = config["ditherDiffusion"];
      ditherMode = config["ditherMode"];
      luminanceSearchMode = config["luminanceSearchMode"];
      luminanceSearchModeParam = config["luminanceSearchModeParam"];
      colorErrorScale = config["mcColorErrorScale"];
      xShift0 = config["xShift0"];
      xShift1 = config["xShift1"];
      borderColor = config["borderColor"];
      nLines = config["verticalSize"];
      colorInterlaceMode = config["colorInterlaceMode"];
      conversionQuality = config["multiColorQuality"];
      disablePAL = !(bool(config["enablePAL"]));
      disableInterlace = (nLines < 256);
      if (disableInterlace)
        nLines = nLines << 1;
      luminance1BitMode = config["luminance1BitMode"];
      noLuminanceInterlace = config["noLuminanceInterlace"];
      checkParameters();
      if (luminanceSearchMode == 6 && ditherMode >= 0)
        colorErrorScale = colorErrorScale * (disablePAL ? 0.707107 : 0.5);
      createYTable();
      createUVTables();
      enable40ColumnMode = (xShift0 == 0 && xShift1 == 0);
      float   borderY = 0.0f;
      float   borderU = 0.0f;
      float   borderV = 0.0f;
      FLIConverter::convertPlus4Color(borderColor, borderY, borderU, borderV,
                                      (luminanceSearchMode != 6 ?
                                       (monitorGamma * 0.44) : 1.0));
      prgData.setConversionType(0);
      prgData.clear();
      prgData.borderColor() = (unsigned char) borderColor;
      prgData.setVerticalSize(disableInterlace ? (nLines >> 1) : nLines);
      for (int yc = 0; yc < 496; yc++) {
        resizedImage.y()[yc].clear();
        resizedImage.y()[yc].setBorderColor(borderY);
        resizedImage.u()[yc].clear();
        resizedImage.u()[yc].setBorderColor(borderU);
        resizedImage.v()[yc].clear();
        resizedImage.v()[yc].setBorderColor(borderV);
        ditherErrorImage.y()[yc].clear();
        ditherErrorImage.u()[yc].clear();
        ditherErrorImage.v()[yc].clear();
      }
      prvLineU.setBorderColor(borderU);
      prvLineV.setBorderColor(borderV);
      line0U.setBorderColor(borderU);
      line0V.setBorderColor(borderV);
      line1U.setBorderColor(borderU);
      line1V.setBorderColor(borderV);
      imgConv.setImageSize((enable40ColumnMode ? 640 : 608), nLines);
      imgConv.setPixelAspectRatio(1.0f);
      imgConv.setPixelStoreCallback(&pixelStoreCallback, (void *) this);
      imgConv.convertImageFile(infileName);
      progressMessage("Calculating FLI data");
      for (int yc = 0; yc < nLines; yc += 2) {
        for (int xc = 0; xc < 320; xc++) {
          if (disableInterlace) {
            float   y0 = resizedImage.y()[yc].getPixel(xc);
            float   y1 = resizedImage.y()[yc + 1].getPixel(xc);
            resizedImage.y()[yc].setPixel(xc, (y0 + y1) * 0.5f);
            resizedImage.y()[yc + 1].setPixel(xc, (y0 + y1) * 0.5f);
          }
          float   u0 = resizedImage.u()[yc].getPixel(xc);
          float   u1 = resizedImage.u()[yc + 1].getPixel(xc);
          float   v0 = resizedImage.v()[yc].getPixel(xc);
          float   v1 = resizedImage.v()[yc + 1].getPixel(xc);
          resizedImage.u()[yc].setPixel(xc, (u0 + u1) * 0.5f);
          resizedImage.u()[yc + 1].setPixel(xc, (u0 + u1) * 0.5f);
          resizedImage.v()[yc].setPixel(xc, (v0 + v1) * 0.5f);
          resizedImage.v()[yc + 1].setPixel(xc, (v0 + v1) * 0.5f);
        }
      }
      // initialize horizontal scroll table
      int     randomSeed = 0;
      Plus4Emu::setRandomSeed(randomSeed,
                              Plus4Emu::Timer::getRandomSeedFromTime());
      for (int yc = 0; yc < nLines; yc++) {
        int     xShift_ = (!(yc & 1) ? xShift0 : xShift1);
        if (xShift_ == -2)
          xShift_ = Plus4Emu::getRandomNumber(randomSeed) & 7;
        else if (xShift_ == -1)
          xShift_ = 0;
        resizedImage.y()[yc].setXShift(xShift_);
        resizedImage.u()[yc].setXShift(xShift_);
        resizedImage.v()[yc].setXShift(xShift_);
      }
      if (!enable40ColumnMode) {
        for (int yc = 0; yc < nLines; yc++) {
          for (int i = 0; i < 8; i++) {
            resizedImage.y()[yc][i] = resizedImage.y()[yc][15 - i];
            resizedImage.y()[yc][312 + i] = resizedImage.y()[yc][311 - i];
            resizedImage.u()[yc][i] = resizedImage.u()[yc][15 - i];
            resizedImage.u()[yc][312 + i] = resizedImage.u()[yc][311 - i];
            resizedImage.v()[yc][i] = resizedImage.v()[yc][15 - i];
            resizedImage.v()[yc][312 + i] = resizedImage.v()[yc][311 - i];
          }
        }
      }
      for (int yc = 0; yc < nLines; yc++) {
        for (int xc = 0; xc < 320; xc++) {
          limitYUVColor(resizedImage.y()[yc][xc],
                        resizedImage.u()[yc][xc],
                        resizedImage.v()[yc][xc]);
          resizedImage.y()[yc][xc] =
              float(std::pow(double(resizedImage.y()[yc][xc]),
                             (luminanceSearchMode != 6 ? 0.704 : 0.7272727)));
        }
      }
      if (luminanceSearchMode != 6) {
        for (int yc = 0; yc < nLines; yc++) {
          if ((yc & (noLuminanceInterlace ? 3 : 2)) != 0)
            continue;
          if (!setProgressPercentage(yc * 33 / nLines)) {
            prgData[0] = 0x01;
            prgData[1] = 0x10;
            prgData[2] = 0x00;
            prgData[3] = 0x00;
            prgEndAddr = 0x1003U;
            progressMessage("");
            return false;
          }
          if (!(xShift0 == -1 || xShift1 == -1)) {
            for (int xc = 0; xc < 320; xc += 8)
              findLuminanceCodes(prgData, xc, yc);
          }
          else if (!(yc & 3)) {
            // find optimal horizontal shifts
            double  minErr = 1000000.0;
            int     bestXShift[4];
            int     xs[4];
            for (int i = 0; i < 4; i++) {
              bestXShift[i] = 0;
              xs[i] = 0;
            }
            do {
              for (int i = 0; i < 4; i++) {
                xs[i] = xs[i] & 7;
                resizedImage.y()[yc + i].setXShift(xs[i]);
                resizedImage.u()[yc + i].setXShift(xs[i]);
                resizedImage.v()[yc + i].setXShift(xs[i]);
              }
              bool    skipFlag = false;
              for (int i = 0; i < 4; i++) {
                // do not allow stepping by more than one pixel at once
                if ((yc + i) > 0) {
                  int     d = resizedImage.y()[yc + i].getXShift()
                              - resizedImage.y()[yc + i - 1].getXShift();
                  if (!(d == 0 || d == 1 || d == -1 || d == 7 || d == -7)) {
                    skipFlag = true;
                    break;
                  }
                }
              }
              if (!skipFlag) {
                // calculate the total error for four lines
                double  err = 0.0;
                for (int xc = 0; xc < 320; xc += 8)
                  err += findLuminanceCodes(prgData, xc, yc);
                if (!noLuminanceInterlace) {
                  for (int xc = 0; xc < 320; xc += 8)
                    err += findLuminanceCodes(prgData, xc, yc + 1);
                }
                if (err < minErr) {
                  for (int i = 0; i < 4; i++)
                    bestXShift[i] = xs[i];
                  minErr = err;
                }
              }
              for (int i = 0; i < 4; i++) {
                xs[i] = xs[i] + 1;
                if (xs[i] < 8)
                  break;
              }
            } while (xs[3] < 8);
            // use the best horizontal shift that was found
            for (int i = 0; i < 4; i++) {
              resizedImage.y()[yc + i].setXShift(bestXShift[i]);
              resizedImage.u()[yc + i].setXShift(bestXShift[i]);
              resizedImage.v()[yc + i].setXShift(bestXShift[i]);
            }
            for (int xc = 0; xc < 320; xc += 8)
              findLuminanceCodes(prgData, xc, yc);
            if (!noLuminanceInterlace) {
              for (int xc = 0; xc < 320; xc += 8)
                findLuminanceCodes(prgData, xc, yc + 1);
            }
          }
        }
        generateBitmaps(prgData);
        // convert color information
        {
          Line320 savedPrvLineU;
          Line320 savedPrvLineV;
          savedPrvLineU.setBorderColor(borderU);
          savedPrvLineV.setBorderColor(borderV);
          for (int xc = 0; xc < 320; xc++) {
            prvLineU[xc] = borderU;
            prvLineV[xc] = borderV;
            savedPrvLineU[xc] = borderU;
            savedPrvLineV[xc] = borderV;
          }
          for (int yc = 0; yc < nLines; yc++) {
            if (yc & 2)
              continue;
            if (!setProgressPercentage((yc * 67 / nLines) + 33)) {
              prgData[0] = 0x01;
              prgData[1] = 0x10;
              prgData[2] = 0x00;
              prgData[3] = 0x00;
              prgEndAddr = 0x1003U;
              progressMessage("");
              return false;
            }
            line0U.clear();
            line0V.clear();
            line1U.clear();
            line1V.clear();
            line0U.setXShift(resizedImage.u()[yc].getXShift());
            line0V.setXShift(resizedImage.v()[yc].getXShift());
            line1U.setXShift(resizedImage.u()[yc + 2].getXShift());
            line1V.setXShift(resizedImage.v()[yc + 2].getXShift());
            if (resizedImage.y()[yc].getXShift()
                >= resizedImage.y()[yc + 2].getXShift()) {
              for (int xc = 0; xc < 320; xc += 8)
                findColorCodes(prgData, xc, yc, 1);
            }
            else {
              for (int xc = 319; xc >= 0; xc -= 8)
                findColorCodes(prgData, xc, yc, -1);
            }
            for (int xc = 0; xc < 320; xc++) {
              prvLineU[xc] = (line1U[xc] * 0.5f) + (savedPrvLineU[xc] * 0.5f);
              prvLineV[xc] = (line1V[xc] * 0.5f) + (savedPrvLineV[xc] * 0.5f);
            }
            savedPrvLineU = line1U;
            savedPrvLineV = line1V;
          }
        }
      }
      else {
        Plus4Emu::setRandomSeed(randomSeed, 54321U);
        for (int yc = 0; yc < nLines; yc += 4) {
          for (int xc = 0; xc < 320; xc += 8) {
            if (!setProgressPercentage(((yc * 40) + (xc / 8)) * 100
                                       / (nLines * 40))) {
              prgData[0] = 0x01;
              prgData[1] = 0x10;
              prgData[2] = 0x00;
              prgData[3] = 0x00;
              prgEndAddr = 0x1003U;
              progressMessage("");
              return false;
            }
            findAttributes_YUVMode(prgData, xc, yc, randomSeed);
          }
          for (int i = 0; i < 4; i++)
            ditherLine_YUVMode(prgData, yc + i);
        }
      }
      setProgressPercentage(100);
      progressMessage("");
      if (!enable40ColumnMode) {
        // bug fix for the case when all X shifts are zero after optimization:
        int     tmp = 0;
        for (int yc = 0; yc < nLines; yc++)
          tmp = tmp | resizedImage.y()[yc].getXShift();
        if (!(tmp & 7)) {
          // clear the first and last character column to border color
          int     l = (borderColor & 0x70) >> 4;
          int     c = borderColor & 0x0F;
          if (c != 0)
            l++;
          for (int yc = 0; yc < nLines; yc++) {
            prgData.l0(0, yc) = l;
            prgData.c0(0, yc) = c;
            prgData.l1(0, yc) = l;
            prgData.c1(0, yc) = c;
            prgData.l0(312, yc) = l;
            prgData.c0(312, yc) = c;
            prgData.l1(312, yc) = l;
            prgData.c1(312, yc) = c;
            for (int i = 0; i < 8; i++) {
              prgData.setPixel(i, yc, false);
              prgData.setPixel(312 + i, yc, false);
            }
          }
        }
      }
      // write PRG output
      for (int yc = 0; yc < nLines; yc++) {
        prgData.lineXShift(yc) =
            (unsigned char) resizedImage.y()[yc].getXShift();
      }
      prgData.optimizeAttributes();
      prgData.convertImageData();
      prgEndAddr = prgData.getImageDataEndAddress();
    }
    catch (...) {
      prgData[0] = 0x01;
      prgData[1] = 0x10;
      prgData[2] = 0x00;
      prgData[3] = 0x00;
      prgEndAddr = 0x1003U;
      progressMessage("");
      throw;
    }
    return true;
  }

}       // namespace Plus4FLIConv

