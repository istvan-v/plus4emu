
// p4fliconv: high resolution interlaced FLI converter utility
// Copyright (C) 2007-2008 Istvan Varga <istvanv@users.sourceforge.net>
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// The Plus/4 program files generated by this utility are not covered by the
// GNU General Public License, and can be used, modified, and distributed
// without any restrictions.

#include "p4fliconv.hpp"
#include "dither.hpp"
#include "imageconv.hpp"
#include "prgdata.hpp"
#include "mcfli.hpp"

namespace Plus4FLIConv {

  P4FLI_MultiColorNoInterlace::Line160::Line160()
    : xShift(0),
      multiColorFlag(false)
  {
    buf = new float[192];
    for (size_t i = 0; i < 192; i++)
      buf[i] = 0.0f;
  }

  P4FLI_MultiColorNoInterlace::Line160::Line160(const Line160& r)
    : xShift(r.xShift),
      multiColorFlag(r.multiColorFlag)
  {
    buf = new float[192];
    for (size_t i = 0; i < 192; i++)
      buf[i] = r.buf[i];
  }

  P4FLI_MultiColorNoInterlace::Line160::~Line160()
  {
    delete[] buf;
  }

  P4FLI_MultiColorNoInterlace::Line160&
      P4FLI_MultiColorNoInterlace::Line160::operator=(const Line160& r)
  {
    xShift = r.xShift;
    multiColorFlag = r.multiColorFlag;
    for (size_t i = 0; i < 192; i++)
      buf[i] = r.buf[i];
    return (*this);
  }

  void P4FLI_MultiColorNoInterlace::Line160::clear()
  {
    for (size_t i = 16; i < 176; i++)
      buf[i] = 0.0f;
  }

  void P4FLI_MultiColorNoInterlace::Line160::setBorderColor(float c)
  {
    for (size_t i = 0; i < 16; i++) {
      buf[i] = c;
      buf[i + 176] = c;
    }
  }

  // --------------------------------------------------------------------------

  P4FLI_MultiColorNoInterlace::Image160x248::Image160x248()
  {
    buf = new Line160[248];
  }

  P4FLI_MultiColorNoInterlace::Image160x248::Image160x248(const Image160x248& r)
  {
    buf = new Line160[248];
    for (size_t i = 0; i < 248; i++)
      buf[i] = r.buf[i];
  }

  P4FLI_MultiColorNoInterlace::Image160x248&
      P4FLI_MultiColorNoInterlace::Image160x248::operator=(
          const Image160x248& r)
  {
    for (size_t i = 0; i < 248; i++)
      buf[i] = r.buf[i];
    return (*this);
  }

  P4FLI_MultiColorNoInterlace::Image160x248::~Image160x248()
  {
    delete[] buf;
  }

  // --------------------------------------------------------------------------

  P4FLI_MultiColorNoInterlace::YUVImage160x248::YUVImage160x248()
  {
  }

  P4FLI_MultiColorNoInterlace::YUVImage160x248::YUVImage160x248(
      const YUVImage160x248& r)
    : imageY(r.imageY),
      imageU(r.imageU),
      imageV(r.imageV)
  {
  }

  P4FLI_MultiColorNoInterlace::YUVImage160x248::~YUVImage160x248()
  {
  }

  P4FLI_MultiColorNoInterlace::YUVImage160x248&
      P4FLI_MultiColorNoInterlace::YUVImage160x248::operator=(
          const YUVImage160x248& r)
  {
    imageY = r.imageY;
    imageU = r.imageU;
    imageV = r.imageV;
    return (*this);
  }

  // --------------------------------------------------------------------------

  P4FLI_MultiColorNoInterlace::P4FLI_MultiColorNoInterlace()
    : monitorGamma(1.33),
      ditherLimit(0.125),
      ditherScale(0.9),
      ditherMode(1),
      xShift0(-1),
      borderColor(0x00),
      nLines(232),
      conversionQuality(6),
      luminance1BitMode(false),
      enable40ColumnMode(false),
      ditheredImage((int *) 0),
      errorTable((double *) 0),
      xShiftTable((int *) 0)
  {
    try {
      ditheredImage = new int[160 * 248];
      errorTable = new double[128 * 128];
      xShiftTable = new int[248];
      for (int i = 0; i < (160 * 248); i++)
        ditheredImage[i] = 0;
      for (int i = 0; i < (128 * 128); i++)
        errorTable[i] = 0.0;
      for (int i = 0; i < 248; i++)
        xShiftTable[i] = 0;
    }
    catch (...) {
      if (ditheredImage)
        delete[] ditheredImage;
      if (errorTable)
        delete[] errorTable;
      if (xShiftTable)
        delete[] xShiftTable;
      throw;
    }
  }

  P4FLI_MultiColorNoInterlace::~P4FLI_MultiColorNoInterlace()
  {
    delete[] ditheredImage;
    delete[] errorTable;
    delete[] xShiftTable;
  }

  void P4FLI_MultiColorNoInterlace::pixelStoreCallback(
      void *userData, int xc, int yc, float y, float u, float v)
  {
    P4FLI_MultiColorNoInterlace&  this_ =
        *(reinterpret_cast<P4FLI_MultiColorNoInterlace *>(userData));
    if (!this_.enable40ColumnMode)
      xc = xc + 16;
    float   c = float(std::sqrt(double(u * u) + double(v * v)));
    if (c > FLIConverter::defaultColorSaturation) {
      u = u * FLIConverter::defaultColorSaturation / c;
      v = v * FLIConverter::defaultColorSaturation / c;
    }
    this_.resizedImage.y()[yc >> 1][xc >> 2] += (y * 0.125f);
    this_.resizedImage.u()[yc >> 1][xc >> 2] += (u * 0.125f);
    this_.resizedImage.v()[yc >> 1][xc >> 2] += (v * 0.125f);
  }

  void P4FLI_MultiColorNoInterlace::checkParameters()
  {
    limitValue(monitorGamma, 0.25, 4.0);
    limitValue(ditherLimit, 0.0, 2.0);
    limitValue(ditherScale, 0.0, 1.0);
    limitValue(ditherMode, 0, 4);
    limitValue(xShift0, -2, 7);
    if (xShift0 >= 0)
      xShift0 = xShift0 & 6;
    borderColor = (borderColor & 0x7F) | 0x80;
    nLines = (nLines > 128 ? (nLines < 248 ? nLines : 248) : 128);
    nLines = (nLines + 3) & (~(int(3)));
    limitValue(conversionQuality, 1, 30);
  }

  P4FLI_MultiColorNoInterlace::FLIBlock4x2::FLIBlock4x2(
      const double *errorTable_,
      int& color0_0_, int& color0_1_, int& color3_0_, int& color3_1_)
    : errorTable(errorTable_),
      color0_0(color0_0_),
      color0_1(color0_1_),
      color3_0(color3_0_),
      color3_1(color3_1_),
      color1(0x00),
      color2(0x00),
      nColors(0),
      nColors_0(0),
      nColors_1(0)
  {
    for (int i = 0; i < 8; i++) {
      pixelColorCodes[i] = 0x00;
      pixelColorCounts[i] = 0;
    }
    for (int i = 0; i < 4; i++) {
      pixelColorCodes_0[i] = 0x00;
      pixelColorCounts_0[i] = 0;
      pixelColorCodes_1[i] = 0x00;
      pixelColorCounts_1[i] = 0;
    }
  }

  P4FLI_MultiColorNoInterlace::FLIBlock4x2::FLIBlock4x2(const FLIBlock4x2& r)
    : errorTable(r.errorTable),
      color0_0(r.color0_0),
      color0_1(r.color0_1),
      color3_0(r.color3_0),
      color3_1(r.color3_1),
      color1(r.color1),
      color2(r.color2),
      nColors(r.nColors),
      nColors_0(r.nColors_0),
      nColors_1(r.nColors_1)
  {
    for (int i = 0; i < 8; i++) {
      pixelColorCodes[i] = r.pixelColorCodes[i];
      pixelColorCounts[i] = r.pixelColorCounts[i];
    }
    for (int i = 0; i < 4; i++) {
      pixelColorCodes_0[i] = r.pixelColorCodes_0[i];
      pixelColorCounts_0[i] = r.pixelColorCounts_0[i];
      pixelColorCodes_1[i] = r.pixelColorCodes_1[i];
      pixelColorCounts_1[i] = r.pixelColorCounts_1[i];
    }
  }

  static void addPixel_(int& nColors,
                        int *pixelColorCodes, int *pixelColorCounts,
                        int c)
  {
    c = c & 0x7F;
    if ((c & 0x0F) == 0)
      c = 0x00;
    {
      int     i = 0;
      while (i < nColors) {
        if (pixelColorCodes[i] == c) {
          pixelColorCounts[i]++;
          break;
        }
        i++;
      }
      if (i >= nColors) {
        pixelColorCodes[nColors] = c;
        pixelColorCounts[nColors] = 1;
        nColors++;
      }
    }
    for (int i = 0; i < nColors; i++) {
      for (int j = i + 1; j < nColors; j++) {
        if (pixelColorCounts[j] > pixelColorCounts[i]) {
          int     tmp = pixelColorCodes[i];
          pixelColorCodes[i] = pixelColorCodes[j];
          pixelColorCodes[j] = tmp;
          tmp = pixelColorCounts[i];
          pixelColorCounts[i] = pixelColorCounts[j];
          pixelColorCounts[j] = tmp;
        }
      }
    }
  }

  void P4FLI_MultiColorNoInterlace::FLIBlock4x2::addPixel(int l, int c)
  {
    addPixel_(nColors, &(pixelColorCodes[0]), &(pixelColorCounts[0]), c);
    if (l == 0) {
      addPixel_(nColors_0, &(pixelColorCodes_0[0]), &(pixelColorCounts_0[0]),
                c);
    }
    else {
      addPixel_(nColors_1, &(pixelColorCodes_1[0]), &(pixelColorCounts_1[0]),
                c);
    }
  }

  inline double P4FLI_MultiColorNoInterlace::FLIBlock4x2::calculateError() const
  {
    double  totalErr = 0.0;
    for (int i = 0; i < nColors_0; i++) {
      int     c = pixelColorCodes_0[i];
      double  minErr = errorTable[(c << 7) | color0_0];
      double  err = errorTable[(c << 7) | color1];
      if (err < minErr)
        minErr = err;
      err = errorTable[(c << 7) | color2];
      if (err < minErr)
        minErr = err;
      err = errorTable[(c << 7) | color3_0];
      if (err < minErr)
        minErr = err;
      totalErr += (minErr * double(pixelColorCounts_0[i]));
    }
    for (int i = 0; i < nColors_1; i++) {
      int     c = pixelColorCodes_1[i];
      double  minErr = errorTable[(c << 7) | color0_1];
      double  err = errorTable[(c << 7) | color1];
      if (err < minErr)
        minErr = err;
      err = errorTable[(c << 7) | color2];
      if (err < minErr)
        minErr = err;
      err = errorTable[(c << 7) | color3_1];
      if (err < minErr)
        minErr = err;
      totalErr += (minErr * double(pixelColorCounts_1[i]));
    }
    return totalErr;
  }

  inline double
      P4FLI_MultiColorNoInterlace::FLIBlock4x2::calculateErrorLine0() const
  {
    double  totalErr = 0.0;
    for (int i = 0; i < nColors_0; i++) {
      int     c = pixelColorCodes_0[i];
      double  minErr = errorTable[(c << 7) | color0_0];
      double  err = errorTable[(c << 7) | color1];
      if (err < minErr)
        minErr = err;
      err = errorTable[(c << 7) | color2];
      if (err < minErr)
        minErr = err;
      err = errorTable[(c << 7) | color3_0];
      if (err < minErr)
        minErr = err;
      totalErr += (minErr * double(pixelColorCounts_0[i]));
    }
    return totalErr;
  }

  inline double
      P4FLI_MultiColorNoInterlace::FLIBlock4x2::calculateErrorLine1() const
  {
    double  totalErr = 0.0;
    for (int i = 0; i < nColors_1; i++) {
      int     c = pixelColorCodes_1[i];
      double  minErr = errorTable[(c << 7) | color0_1];
      double  err = errorTable[(c << 7) | color1];
      if (err < minErr)
        minErr = err;
      err = errorTable[(c << 7) | color2];
      if (err < minErr)
        minErr = err;
      err = errorTable[(c << 7) | color3_1];
      if (err < minErr)
        minErr = err;
      totalErr += (minErr * double(pixelColorCounts_1[i]));
    }
    return totalErr;
  }

  double P4FLI_MultiColorNoInterlace::FLIBlock4x2::optimizeColors(
      const std::vector< int >& colorTable_)
  {
    if (nColors <= 2) {
      color1 = pixelColorCodes[0];
      color2 = pixelColorCodes[1];
      return 0.0;
    }
    int     nColors_ = 0;
    int     nColors_0_ = 0;
    int     nColors_1_ = 0;
    int     pixelColorCodes_[8];
    int     pixelColorCounts_[8];
    int     pixelColorCodes_0_[4];
    int     pixelColorCounts_0_[4];
    int     pixelColorCodes_1_[4];
    int     pixelColorCounts_1_[4];
    for (int i = 0; i < nColors_0; i++) {
      int     c = pixelColorCodes_0[i];
      if (c == color0_0 || c == color3_0)
        continue;
      pixelColorCodes_0_[nColors_0_] = c;
      pixelColorCounts_0_[nColors_0_] = pixelColorCounts_0[i];
      nColors_0_++;
    }
    for (int i = 0; i < nColors_1; i++) {
      int     c = pixelColorCodes_1[i];
      if (c == color0_1 || c == color3_1)
        continue;
      pixelColorCodes_1_[nColors_1_] = c;
      pixelColorCounts_1_[nColors_1_] = pixelColorCounts_1[i];
      nColors_1_++;
    }
    for (int i = 0; i < nColors_0_; i++) {
      int     c = pixelColorCodes_0_[i];
      int     n = pixelColorCounts_0_[i];
      int     j = 0;
      while (j < nColors_) {
        if (pixelColorCodes_[j] == c) {
          pixelColorCounts_[j] += n;
          break;
        }
        j++;
      }
      if (j >= nColors_) {
        pixelColorCodes_[nColors_] = c;
        pixelColorCounts_[nColors_] = n;
        nColors_++;
      }
    }
    for (int i = 0; i < nColors_1_; i++) {
      int     c = pixelColorCodes_1_[i];
      int     n = pixelColorCounts_1_[i];
      int     j = 0;
      while (j < nColors_) {
        if (pixelColorCodes_[j] == c) {
          pixelColorCounts_[j] += n;
          break;
        }
        j++;
      }
      if (j >= nColors_) {
        pixelColorCodes_[nColors_] = c;
        pixelColorCounts_[nColors_] = n;
        nColors_++;
      }
    }
    if (nColors_ <= 2) {
      if (nColors_ >= 1)
        color1 = pixelColorCodes_[0];
      else
        color1 = 0x00;
      if (nColors_ >= 2)
        color2 = pixelColorCodes_[1];
      else
        color2 = 0x00;
      return 0.0;
    }
    double  minErr = 1000000.0;
    if (colorTable_.size() <= 48) {
      // color #1 and color #2
      int     bestColor1 = color1;
      int     bestColor2 = color2;
      for (size_t c1i = 0; c1i < colorTable_.size(); c1i++) {
        for (size_t c2i = c1i + 1; c2i < colorTable_.size(); c2i++) {
          color1 = colorTable_[c1i];
          color2 = colorTable_[c2i];
          double  err = 0.0;
          for (int i = 0; i < nColors_0_; i++) {
            int     c = pixelColorCodes_0_[i];
            double  minErr2 = errorTable[(c << 7) | color0_0];
            double  err2 = errorTable[(c << 7) | color1];
            if (err2 < minErr2)
              minErr2 = err2;
            err2 = errorTable[(c << 7) | color2];
            if (err2 < minErr2)
              minErr2 = err2;
            err2 = errorTable[(c << 7) | color3_0];
            if (err2 < minErr2)
              minErr2 = err2;
            err += (minErr2 * double(pixelColorCounts_0_[i]));
          }
          for (int i = 0; i < nColors_1_; i++) {
            int     c = pixelColorCodes_1_[i];
            double  minErr2 = errorTable[(c << 7) | color0_1];
            double  err2 = errorTable[(c << 7) | color1];
            if (err2 < minErr2)
              minErr2 = err2;
            err2 = errorTable[(c << 7) | color2];
            if (err2 < minErr2)
              minErr2 = err2;
            err2 = errorTable[(c << 7) | color3_1];
            if (err2 < minErr2)
              minErr2 = err2;
            err += (minErr2 * double(pixelColorCounts_1_[i]));
          }
          if (err < minErr) {
            bestColor1 = color1;
            bestColor2 = color2;
            minErr = err;
          }
        }
      }
      color1 = bestColor1;
      color2 = bestColor2;
    }
    else {
      // color #1
      int     bestColor = color1;
      for (size_t j = 0; j < colorTable_.size(); j++) {
        color1 = colorTable_[j];
        double  err = 0.0;
        for (int i = 0; i < nColors_0_; i++) {
          int     c = pixelColorCodes_0_[i];
          double  minErr2 = errorTable[(c << 7) | color0_0];
          double  err2 = errorTable[(c << 7) | color1];
          if (err2 < minErr2)
            minErr2 = err2;
          err2 = errorTable[(c << 7) | color2];
          if (err2 < minErr2)
            minErr2 = err2;
          err2 = errorTable[(c << 7) | color3_0];
          if (err2 < minErr2)
            minErr2 = err2;
          err += (minErr2 * double(pixelColorCounts_0_[i]));
        }
        for (int i = 0; i < nColors_1_; i++) {
          int     c = pixelColorCodes_1_[i];
          double  minErr2 = errorTable[(c << 7) | color0_1];
          double  err2 = errorTable[(c << 7) | color1];
          if (err2 < minErr2)
            minErr2 = err2;
          err2 = errorTable[(c << 7) | color2];
          if (err2 < minErr2)
            minErr2 = err2;
          err2 = errorTable[(c << 7) | color3_1];
          if (err2 < minErr2)
            minErr2 = err2;
          err += (minErr2 * double(pixelColorCounts_1_[i]));
        }
        if (err < minErr) {
          bestColor = color1;
          minErr = err;
        }
      }
      color1 = bestColor;
      // color #2
      minErr = 1000000.0;
      bestColor = color2;
      for (size_t j = 0; j < colorTable_.size(); j++) {
        color2 = colorTable_[j];
        double  err = 0.0;
        for (int i = 0; i < nColors_0_; i++) {
          int     c = pixelColorCodes_0_[i];
          double  minErr2 = errorTable[(c << 7) | color0_0];
          double  err2 = errorTable[(c << 7) | color1];
          if (err2 < minErr2)
            minErr2 = err2;
          err2 = errorTable[(c << 7) | color2];
          if (err2 < minErr2)
            minErr2 = err2;
          err2 = errorTable[(c << 7) | color3_0];
          if (err2 < minErr2)
            minErr2 = err2;
          err += (minErr2 * double(pixelColorCounts_0_[i]));
        }
        for (int i = 0; i < nColors_1_; i++) {
          int     c = pixelColorCodes_1_[i];
          double  minErr2 = errorTable[(c << 7) | color0_1];
          double  err2 = errorTable[(c << 7) | color1];
          if (err2 < minErr2)
            minErr2 = err2;
          err2 = errorTable[(c << 7) | color2];
          if (err2 < minErr2)
            minErr2 = err2;
          err2 = errorTable[(c << 7) | color3_1];
          if (err2 < minErr2)
            minErr2 = err2;
          err += (minErr2 * double(pixelColorCounts_1_[i]));
        }
        if (err < minErr) {
          bestColor = color2;
          minErr = err;
        }
      }
      color2 = bestColor;
    }
    return minErr;
  }

  void P4FLI_MultiColorNoInterlace::createErrorTable(double colorErrorScale)
  {
    limitValue(colorErrorScale, 0.05, 1.0);
    for (int c0 = 0; c0 < 128; c0++) {
      float   c0y = 0.0f;
      float   c0u = 0.0f;
      float   c0v = 0.0f;
      FLIConverter::convertPlus4Color(c0, c0y, c0u, c0v, monitorGamma);
      for (int c1 = 0; c1 < 128; c1++) {
        float   c1y = 0.0f;
        float   c1u = 0.0f;
        float   c1v = 0.0f;
        FLIConverter::convertPlus4Color(c1, c1y, c1u, c1v, monitorGamma);
        errorTable[(c0 << 7) | c1] =
            calculateErrorSqr(c0y, c1y)
            + (calculateErrorSqr(c0u, c1u) * colorErrorScale)
            + (calculateErrorSqr(c0v, c1v) * colorErrorScale);
      }
    }
  }

  void P4FLI_MultiColorNoInterlace::ditherLine(long yc)
  {
    float   paletteY[128];
    float   paletteU[128];
    float   paletteV[128];
    for (int i = 0; i < 128; i++) {
      FLIConverter::convertPlus4Color(i, paletteY[i], paletteU[i], paletteV[i],
                                      monitorGamma);
    }
    if (ditherMode < 2) {
      // ordered dithering
      float   luminanceTable[9];
      float   hueTable[15];
      int     hueIndexTable[15];
      for (int i = 0; i < 9; i++)
        luminanceTable[i] = paletteY[(i == 0 ? 0 : (((i - 1) << 4) + 1))];
      for (int i = 0; i < 14; i++) {
        float   u = paletteU[66 + i];
        float   v = paletteV[66 + i];
        double  phs = std::atan2(double(v), double(u)) / (2.0 * 3.14159265);
        if (phs < 0.0)
          phs = phs + 1.0;
        hueTable[i] = float(phs);
        hueIndexTable[i] = i;
      }
      for (int i = 0; i < 14; i++) {
        for (int j = i + 1; j < 14; j++) {
          if (hueTable[j] < hueTable[i]) {
            {
              float   tmp = hueTable[i];
              hueTable[i] = hueTable[j];
              hueTable[j] = tmp;
            }
            {
              int     tmp = hueIndexTable[i];
              hueIndexTable[i] = hueIndexTable[j];
              hueIndexTable[j] = tmp;
            }
          }
        }
      }
      hueTable[14] = hueTable[0] + 1.0f;
      hueIndexTable[14] = hueIndexTable[0];
      for (long xc = 0L; xc < 160L; xc++) {
        float   y = resizedImage.y()[yc].getPixel(xc);
        float   u = resizedImage.u()[yc].getPixel(xc);
        float   v = resizedImage.v()[yc].getPixel(xc);
        float   s = float(std::sqrt(double(u * u) + double(v * v)));
        float   h = float(std::atan2(double(v), double(u)));
        h = h / (2.0f * 3.14159265f);
        if (h < 0.0f)
          h = h + 1.0f;
        int     li0 = 0;
        int     li1 = 8;
        if (!luminance1BitMode) {
          while (y > luminanceTable[li0 + 1] && li0 < 7)
            li0++;
          li1 = li0 + 1;
        }
        if (calculateError(calculateError(y, luminanceTable[li0]),
                           calculateError(y, luminanceTable[li1]))
            >= ditherLimit) {
          if (calculateError(y, luminanceTable[li0])
              > calculateError(y, luminanceTable[li1])) {
            li0 = li1;
          }
        }
        else {
          float   f = (y - luminanceTable[li0])
                      / (luminanceTable[li1] - luminanceTable[li0]);
          if (ditherMode == 0) {
            if (ditherPixelValue_Bayer(xc, yc, f))
              li0 = li1;
          }
          else {
            if (ditherPixelValue(xc, yc, f))
              li0 = li1;
          }
        }
        int     si = 0;
        if (ditherMode == 0) {
          if (ditherPixelValue_Bayer(
                  xc, yc, s / FLIConverter::defaultColorSaturation)) {
            si++;
          }
        }
        else {
          if (ditherPixelValue(
                  xc, yc, s / FLIConverter::defaultColorSaturation)) {
            si++;
          }
        }
        int     hi = 0;
        if (h < hueTable[0])    // special case for hue wrap-around
          h = h + 1.0f;
        while (h > hueTable[hi + 1] && hi < 13)
          hi++;
        float   f = (h - hueTable[hi]) / (hueTable[hi + 1] - hueTable[hi]);
        if (ditherMode == 0) {
          if (ditherPixelValue_Bayer(xc, yc, f))
            hi++;
        }
        else {
          if (ditherPixelValue(xc, yc, f))
            hi++;
        }
        hi = hueIndexTable[hi];
        ditheredImage[yc * 160L + xc] =
            (li0 == 0 ? 0 : ((si == 0 ? 1 : (hi + 2)) + ((li0 - 1) << 4)));
      }
      return;
    }
    // error diffusion dithering
    for (long xc = 0L; xc < 160L; xc++) {
      if (yc & 1L)
        xc = 159L - xc;
      // find the palette color nearest the original pixel
      float   y0 = resizedImage.y()[yc].getPixel(xc);
      float   u0 = resizedImage.u()[yc].getPixel(xc);
      float   v0 = resizedImage.v()[yc].getPixel(xc);
      int     c0 = 0;
      double  minErr0 = 1000000.0;
      for (int i = (luminance1BitMode ? 112 : 0); i < 128; i++) {
        double  err = calculateErrorSqr(paletteY[i], y0)
                      + (calculateErrorSqr(paletteU[i], u0) * 0.0625)
                      + (calculateErrorSqr(paletteV[i], v0) * 0.0625);
        if (err < minErr0) {
          c0 = i;
          minErr0 = err;
        }
      }
      // find the palette color nearest the original pixel with error added
      float   y = y0 + ditherErrorImage.y()[yc].getPixel(xc);
      float   u = u0 + ditherErrorImage.u()[yc].getPixel(xc);
      float   v = v0 + ditherErrorImage.v()[yc].getPixel(xc);
      y = (y > 0.0f ? (y < 1.0f ? y : 1.0f) : 0.0f);
      {
        float   tmp = float(std::sqrt(double(u * u) + double(v * v)));
        if (tmp > FLIConverter::defaultColorSaturation) {
          tmp = FLIConverter::defaultColorSaturation / tmp;
          u = u * tmp;
          v = v * tmp;
        }
      }
      int     c = 0;
      double  minErr = 1000000.0;
      for (int i = (luminance1BitMode ? 112 : 0); i < 128; i++) {
        double  err = calculateErrorSqr(paletteY[i], y)
                      + (calculateErrorSqr(paletteU[i], u) * 0.0625)
                      + (calculateErrorSqr(paletteV[i], v) * 0.0625);
        if (err < minErr) {
          c = i;
          minErr = err;
        }
      }
      if (calculateError(
              std::sqrt(minErr0),
              std::sqrt(calculateErrorSqr(paletteY[c], y0)
                        + (calculateErrorSqr(paletteU[c], u0) * 0.0625)
                        + (calculateErrorSqr(paletteV[c], v0) * 0.0625)))
          < ditherLimit) {
        ditheredImage[yc * 160L + xc] = c;
      }
      else {
        ditheredImage[yc * 160L + xc] = c0;
      }
      y = y0 + ((y - y0) * float(ditherScale));
      u = u0 + ((u - u0) * float(ditherScale));
      v = v0 + ((v - v0) * float(ditherScale));
      float   errY = y - paletteY[c];
      float   errU = u - paletteU[c];
      float   errV = v - paletteV[c];
      if (ditherMode == 2) {
        // Floyd-Steinberg dithering
        static const int    xOffsTbl[4] = { 1, -1, 0, 1 };
        static const int    yOffsTbl[4] = { 0, 1, 1, 1 };
        static const float  errMultTbl[4] = {
          0.4375f, 0.1875f, 0.3125f, 0.0625f
        };
        for (int i = 0; i < 4; i++) {
          long    yc_ = yc + yOffsTbl[i];
          long    xc_ = xOffsTbl[i];
          xc_ = ((yc & 1L) == 0L ? (xc + xc_) : (xc - xc_));
          if (yc_ >= 0L && yc_ < long(nLines) && xc_ >= 0L && xc_ < 160L) {
            float   errMult = errMultTbl[i];
            ditherErrorImage.y()[yc_].setPixel(
                xc_,
                ditherErrorImage.y()[yc_].getPixel(xc_) + (errY * errMult));
            ditherErrorImage.u()[yc_].setPixel(
                xc_,
                ditherErrorImage.u()[yc_].getPixel(xc_) + (errU * errMult));
            ditherErrorImage.v()[yc_].setPixel(
                xc_,
                ditherErrorImage.v()[yc_].getPixel(xc_) + (errV * errMult));
          }
        }
      }
      else if (ditherMode == 3) {
        // Jarvis dithering
        for (int i = 0; i < 3; i++) {
          for (int j = (i == 0 ? 1 : -2); j < 3; j++) {
            if (yc & 1L)
              j = (-j);
            long    yc_ = yc + i;
            long    xc_ = xc + j;
            if (yc_ >= 0L && yc_ < long(nLines) && xc_ >= 0L && xc_ < 160L) {
              float   errMult = (4.5f - float(i + (j >= 0 ? j : (-j)))) / 24.0f;
              ditherErrorImage.y()[yc_].setPixel(
                  xc_,
                  ditherErrorImage.y()[yc_].getPixel(xc_) + (errY * errMult));
              ditherErrorImage.u()[yc_].setPixel(
                  xc_,
                  ditherErrorImage.u()[yc_].getPixel(xc_) + (errU * errMult));
              ditherErrorImage.v()[yc_].setPixel(
                  xc_,
                  ditherErrorImage.v()[yc_].getPixel(xc_) + (errV * errMult));
            }
            if (yc & 1L)
              j = (-j);
          }
        }
      }
      else {
        // Stucki dithering
        for (int i = 0; i < 3; i++) {
          for (int j = (i == 0 ? 1 : -2); j < 3; j++) {
            if (yc & 1L)
              j = (-j);
            long    yc_ = yc + i;
            long    xc_ = xc + j;
            if (yc_ >= 0L && yc_ < long(nLines) && xc_ >= 0L && xc_ < 160L) {
              float   errMult = float(16 >> (i + (j >= 0 ? j : (-j)))) / 42.0f;
              ditherErrorImage.y()[yc_].setPixel(
                  xc_,
                  ditherErrorImage.y()[yc_].getPixel(xc_) + (errY * errMult));
              ditherErrorImage.u()[yc_].setPixel(
                  xc_,
                  ditherErrorImage.u()[yc_].getPixel(xc_) + (errU * errMult));
              ditherErrorImage.v()[yc_].setPixel(
                  xc_,
                  ditherErrorImage.v()[yc_].getPixel(xc_) + (errV * errMult));
            }
            if (yc & 1L)
              j = (-j);
          }
        }
      }
      if (yc & 1L)
        xc = 159L - xc;
    }
  }

  double P4FLI_MultiColorNoInterlace::convertTwoLines(PRGData& prgData, long yc)
  {
    int     color0_0 = 0;
    int     color0_1 = 0;
    int     color3_0 = 0;
    int     color3_1 = 0;
    // find the color indexes used in each attribute block area
    std::vector< FLIBlock4x2 >  attrBlocks(40, FLIBlock4x2(errorTable,
                                                           color0_0, color0_1,
                                                           color3_0, color3_1));
    int     xs[2];
    xs[0] = xShiftTable[yc + 0];
    xs[1] = xShiftTable[yc + 1];
    for (int i = 0; i < 2; i++) {
      for (int xc = (enable40ColumnMode ? 0 : 4);
           xc < (enable40ColumnMode ? 160 : 156);
           xc++) {
        int     n = ((xc << 1) - xs[i]) >> 3;
        attrBlocks[n].addPixel(i, ditheredImage[(yc + i) * 160L + xc]);
      }
    }
    bool    color0ChangeEnabled = (nLines <= 200 || xs[1] == xs[0]);
    std::vector< float >  paletteY(128);
    std::vector< float >  paletteU(128);
    std::vector< float >  paletteV(128);
    for (int i = 0; i < 128; i++) {
      FLIConverter::convertPlus4Color(i, paletteY[i], paletteU[i], paletteV[i],
                                      monitorGamma);
    }
    // find the set of colors that needs to be searched for optimal conversion
    std::vector< int >  colorTable0;                    // for color #0 and #3
    std::vector< std::vector< int > >   colorTables;    // for color #1 and #2
    colorTables.resize(40);
    {
      float   minY0 = 1.0f;
      float   maxY0 = 0.0f;
      float   minU0 = 1.0f;
      float   maxU0 = -1.0f;
      float   minV0 = 1.0f;
      float   maxV0 = -1.0f;
      for (int i = 0; i < 40; i++) {
        float   minY = 1.0f;
        float   maxY = 0.0f;
        float   minU = 1.0f;
        float   maxU = -1.0f;
        float   minV = 1.0f;
        float   maxV = -1.0f;
        for (int j = 0; j < attrBlocks[i].nColors; j++) {
          float   y = paletteY[attrBlocks[i].pixelColorCodes[j]];
          float   u = paletteU[attrBlocks[i].pixelColorCodes[j]];
          float   v = paletteV[attrBlocks[i].pixelColorCodes[j]];
          minY = (y < minY ? y : minY);
          maxY = (y > maxY ? y : maxY);
          minU = (u < minU ? u : minU);
          maxU = (u > maxU ? u : maxU);
          minV = (v < minV ? v : minV);
          maxV = (v > maxV ? v : maxV);
          if (attrBlocks[i].nColors > 2) {
            minY0 = (y < minY0 ? y : minY0);
            maxY0 = (y > maxY0 ? y : maxY0);
            minU0 = (u < minU0 ? u : minU0);
            maxU0 = (u > maxU0 ? u : maxU0);
            minV0 = (v < minV0 ? v : minV0);
            maxV0 = (v > maxV0 ? v : maxV0);
          }
        }
        if (minV < 0.0f && maxV > 0.0f) {
          if (minU < 0.0f)
            minU = -(FLIConverter::defaultColorSaturation);
          if (maxU > 0.0f)
            maxU = FLIConverter::defaultColorSaturation;
        }
        if (minU < 0.0f && maxU > 0.0f) {
          if (minV < 0.0f)
            minV = -(FLIConverter::defaultColorSaturation);
          if (maxV > 0.0f)
            maxV = FLIConverter::defaultColorSaturation;
        }
        minY = minY - 0.0001f;
        maxY = maxY + 0.0001f;
        minU = minU - 0.0001f;
        maxU = maxU + 0.0001f;
        minV = minV - 0.0001f;
        maxV = maxV + 0.0001f;
        for (int j = 0; j < 128; j++) {
          if (j > 0 && (j & 15) == 0)
            continue;
          float   y = paletteY[j];
          float   u = paletteU[j];
          float   v = paletteV[j];
          if (y > minY && y < maxY &&
              ((j & 15) == 1 ||
               (u > minU && u < maxU && v > minV && v < maxV))) {
            colorTables[i].push_back(j);
          }
        }
      }
      if (minV0 < 0.0f && maxV0 > 0.0f) {
        if (minU0 < 0.0f)
          minU0 = -(FLIConverter::defaultColorSaturation);
        if (maxU0 > 0.0f)
          maxU0 = FLIConverter::defaultColorSaturation;
      }
      if (minU0 < 0.0f && maxU0 > 0.0f) {
        if (minV0 < 0.0f)
          minV0 = -(FLIConverter::defaultColorSaturation);
        if (maxV0 > 0.0f)
          maxV0 = FLIConverter::defaultColorSaturation;
      }
      minY0 = minY0 - 0.0001f;
      maxY0 = maxY0 + 0.0001f;
      minU0 = minU0 - 0.0001f;
      maxU0 = maxU0 + 0.0001f;
      minV0 = minV0 - 0.0001f;
      maxV0 = maxV0 + 0.0001f;
      for (int j = 0; j < 128; j++) {
        if (j > 0 && (j & 15) == 0)
          continue;
        float   y = paletteY[j];
        float   u = paletteU[j];
        float   v = paletteV[j];
        if (y > minY0 && y < maxY0 &&
            ((j & 15) == 1 ||
             (u > minU0 && u < maxU0 && v > minV0 && v < maxV0))) {
          colorTable0.push_back(j);
        }
      }
    }
    double  bestErr = 1000000.0;
    std::vector< int >  bestColors(84);
    for (int i = 0; i < 80; i += 2) {
      bestColors[i + 0] = attrBlocks[i >> 1].color1;
      bestColors[i + 1] = attrBlocks[i >> 1].color2;
    }
    bestColors[80] = color0_0;
    bestColors[81] = color0_1;
    bestColors[82] = color3_0;
    bestColors[83] = color3_1;
    std::vector< int >  colorCnts(128);
    int     randomSeed = 0;
    Plus4Emu::setRandomSeed(randomSeed, 1U);
    for (int l = 0; l < conversionQuality; l++) {
      // set initial palette with different methods, and choose the one
      // that results in the least error after optimization
      for (int i = 0; i < 128; i++)
        colorCnts[i] = 0;
      for (int i = 0; i < 40; i++) {
        int     nColors = attrBlocks[i].nColors;
        if (nColors <= 2) {
          attrBlocks[i].color1 = attrBlocks[i].pixelColorCodes[0];
          attrBlocks[i].color2 = attrBlocks[i].pixelColorCodes[1];
        }
        else {
          switch (l) {
          case 0:
          case 6:
            attrBlocks[i].color1 = attrBlocks[i].pixelColorCodes[nColors - 1];
            attrBlocks[i].color2 = attrBlocks[i].pixelColorCodes[nColors - 2];
            break;
          case 1:
          case 7:
            attrBlocks[i].color1 = attrBlocks[i].pixelColorCodes[0];
            attrBlocks[i].color2 = attrBlocks[i].pixelColorCodes[1];
            break;
          case 2:
          case 8:
            attrBlocks[i].color1 = attrBlocks[i].pixelColorCodes[0];
            attrBlocks[i].color2 = attrBlocks[i].pixelColorCodes[nColors - 1];
            break;
          case 3:
          case 9:
            {
              attrBlocks[i].color1 = attrBlocks[i].pixelColorCodes[0];
              double  maxErr = 0.0;
              for (int j = 1; j < nColors; j++) {
                double  err = errorTable[(attrBlocks[i].color1 << 7)
                                         | (attrBlocks[i].pixelColorCodes[j])];
                if (err >= maxErr) {
                  attrBlocks[i].color2 = attrBlocks[i].pixelColorCodes[j];
                  maxErr = err;
                }
              }
            }
            break;
          case 4:
          case 10:
            attrBlocks[i].color1 = 0x00;
            attrBlocks[i].color2 = 0x00;
            break;
          case 5:
          case 11:
            attrBlocks[i].color1 = 0x71;
            attrBlocks[i].color2 = 0x71;
            break;
          default:
            attrBlocks[i].color1 =
                colorTables[i][Plus4Emu::getRandomNumber(randomSeed)
                               % int(colorTables[i].size())];
            attrBlocks[i].color2 =
                colorTables[i][Plus4Emu::getRandomNumber(randomSeed)
                               % int(colorTables[i].size())];
            break;
          }
          for (int j = 0; j < nColors; j++) {
            int     c = attrBlocks[i].pixelColorCodes[j];
            if (c != attrBlocks[i].color1 && c != attrBlocks[i].color2)
              colorCnts[c] = colorCnts[c] + attrBlocks[i].pixelColorCounts[j];
          }
        }
      }
      if (l == 4 || l == 10) {
        color0_0 = 0x71;
        color3_0 = 0x71;
      }
      else if (l == 5 || l == 11) {
        color0_0 = 0x00;
        color3_0 = 0x00;
      }
      else if (l < 12 || colorTable0.size() < 1) {
        int     maxCnt1 = 0;
        int     maxCnt2 = 0;
        for (int i = 0; i < 128; i++) {
          if (colorCnts[i] > maxCnt1) {
            maxCnt2 = maxCnt1;
            color3_0 = color0_0;
            maxCnt1 = colorCnts[i];
            color0_0 = i;
          }
          else if (colorCnts[i] > maxCnt2) {
            maxCnt2 = colorCnts[i];
            color3_0 = i;
          }
        }
      }
      else {
        color0_0 = colorTable0[Plus4Emu::getRandomNumber(randomSeed)
                               % int(colorTable0.size())];
        color3_0 = colorTable0[Plus4Emu::getRandomNumber(randomSeed)
                               % int(colorTable0.size())];
      }
      color0_1 = color0_0;
      color3_1 = color3_0;
      // optimize attributes and color registers
      double  prvErr = 1000000.0;
      for (int i = (l < 6 ? 7 : -1); i >= 0; i--) {
        // color #0 (FF15), line 0 and 1
        double  minErr = prvErr;
        int     bestColor = color0_0;
        for (size_t j = 0; j < colorTable0.size(); j++) {
          color0_0 = colorTable0[j];
          color0_1 = color0_0;
          double  err = 0.0;
          for (int k = 0; k < 40; k++) {
            if (attrBlocks[k].nColors <= 2)
              continue;
            err += attrBlocks[k].calculateError();
            if (err > (minErr * 1.000001))
              break;
          }
          if (err < minErr) {
            bestColor = color0_0;
            minErr = err;
          }
        }
        color0_0 = bestColor;
        color0_1 = color0_0;
        // color #3 (FF16), line 0 and 1
        bestColor = color3_0;
        for (size_t j = 0; j < colorTable0.size(); j++) {
          color3_0 = colorTable0[j];
          color3_1 = color3_0;
          double  err = 0.0;
          for (int k = 0; k < 40; k++) {
            if (attrBlocks[k].nColors <= 2)
              continue;
            err += attrBlocks[k].calculateError();
            if (err > (minErr * 1.000001))
              break;
          }
          if (err < minErr) {
            bestColor = color3_0;
            minErr = err;
          }
        }
        color3_0 = bestColor;
        color3_1 = color3_0;
        // color #1 and color #2
        double  err = 0.0;
        for (int k = 0; k < 40; k++)
          err += attrBlocks[k].optimizeColors(colorTables[k]);
        // quit the optimization loop earlier if the error could not be reduced
        if (err >= (prvErr * 0.99999999)) {
          prvErr = err;
          break;
        }
        prvErr = err;
      }
      for (int i = 7; i >= 0; i--) {
        // color #0 (FF15), line 0
        double  minErr = 0.0;
        if (color0ChangeEnabled) {
          for (int k = 0; k < 40; k++) {
            if (attrBlocks[k].nColors <= 2)
              continue;
            minErr += attrBlocks[k].calculateErrorLine0();
          }
        }
        else
          minErr = prvErr;
        int     bestColor = color0_0;
        for (size_t j = 0; j < colorTable0.size(); j++) {
          color0_0 = colorTable0[j];
          if (!color0ChangeEnabled)
            color0_1 = color0_0;
          double  err = 0.0;
          for (int k = 0; k < 40; k++) {
            if (attrBlocks[k].nColors <= 2)
              continue;
            if (color0ChangeEnabled)
              err += attrBlocks[k].calculateErrorLine0();
            else
              err += attrBlocks[k].calculateError();
            if (err > (minErr * 1.000001))
              break;
          }
          if (err < minErr) {
            bestColor = color0_0;
            minErr = err;
          }
        }
        color0_0 = bestColor;
        if (!color0ChangeEnabled)
          color0_1 = color0_0;
        // color #0 (FF15), line 1
        if (color0ChangeEnabled) {
          minErr = 0.0;
          for (int k = 0; k < 40; k++) {
            if (attrBlocks[k].nColors <= 2)
              continue;
            minErr += attrBlocks[k].calculateErrorLine1();
          }
          bestColor = color0_1;
          for (size_t j = 0; j < colorTable0.size(); j++) {
            color0_1 = colorTable0[j];
            double  err = 0.0;
            for (int k = 0; k < 40; k++) {
              if (attrBlocks[k].nColors <= 2)
                continue;
              err += attrBlocks[k].calculateErrorLine1();
              if (err > (minErr * 1.000001))
                break;
            }
            if (err < minErr) {
              bestColor = color0_1;
              minErr = err;
            }
          }
          color0_1 = bestColor;
        }
        // color #3 (FF16), line 0
        minErr = 0.0;
        for (int k = 0; k < 40; k++) {
          if (attrBlocks[k].nColors <= 2)
            continue;
          minErr += attrBlocks[k].calculateErrorLine0();
        }
        bestColor = color3_0;
        for (size_t j = 0; j < colorTable0.size(); j++) {
          color3_0 = colorTable0[j];
          double  err = 0.0;
          for (int k = 0; k < 40; k++) {
            if (attrBlocks[k].nColors <= 2)
              continue;
            err += attrBlocks[k].calculateErrorLine0();
            if (err > (minErr * 1.000001))
              break;
          }
          if (err < minErr) {
            bestColor = color3_0;
            minErr = err;
          }
        }
        color3_0 = bestColor;
        // color #3 (FF16), line 1
        minErr = 0.0;
        for (int k = 0; k < 40; k++) {
          if (attrBlocks[k].nColors <= 2)
            continue;
          minErr += attrBlocks[k].calculateErrorLine1();
        }
        bestColor = color3_1;
        for (size_t j = 0; j < colorTable0.size(); j++) {
          color3_1 = colorTable0[j];
          double  err = 0.0;
          for (int k = 0; k < 40; k++) {
            if (attrBlocks[k].nColors <= 2)
              continue;
            err += attrBlocks[k].calculateErrorLine1();
            if (err > (minErr * 1.000001))
              break;
          }
          if (err < minErr) {
            bestColor = color3_1;
            minErr = err;
          }
        }
        color3_1 = bestColor;
        // color #1 and color #2
        double  err = 0.0;
        for (int k = 0; k < 40; k++)
          err += attrBlocks[k].optimizeColors(colorTables[k]);
        // quit the optimization loop earlier if the error could not be reduced
        if (err >= (prvErr * 0.99999999)) {
          prvErr = err;
          break;
        }
        prvErr = err;
      }
      if (prvErr < bestErr) {
        for (int i = 0; i < 80; i += 2) {
          bestColors[i + 0] = attrBlocks[i >> 1].color1;
          bestColors[i + 1] = attrBlocks[i >> 1].color2;
        }
        bestColors[80] = color0_0;
        bestColors[81] = color0_1;
        bestColors[82] = color3_0;
        bestColors[83] = color3_1;
        bestErr = prvErr;
      }
    }
    for (int i = 0; i < 80; i += 2) {
      attrBlocks[i >> 1].color1 = bestColors[i + 0];
      attrBlocks[i >> 1].color2 = bestColors[i + 1];
    }
    color0_0 = bestColors[80];
    color0_1 = bestColors[81];
    color3_0 = bestColors[82];
    color3_1 = bestColors[83];
    // store the attributes and color registers
    prgData.lineColor0(yc << 1) = (unsigned char) color0_0;
    prgData.lineColor0((yc << 1) | 2L) = (unsigned char) color0_1;
    prgData.lineColor3(yc << 1) = (unsigned char) color3_0;
    prgData.lineColor3((yc << 1) | 2L) = (unsigned char) color3_1;
    for (int i = 0; i < 40; i++) {
      int     l0 = (attrBlocks[i].color2 >> 4) & 0x07;
      int     l1 = (attrBlocks[i].color1 >> 4) & 0x07;
      int     c0 = attrBlocks[i].color2 & 0x0F;
      int     c1 = attrBlocks[i].color1 & 0x0F;
      if (c0 == 0)
        l0 = 0;
      else
        l0++;
      if (c1 == 0)
        l1 = 0;
      else
        l1++;
      prgData.l0(i << 3, yc << 1) = l0;
      prgData.l1(i << 3, yc << 1) = l1;
      prgData.c0(i << 3, yc << 1) = c0;
      prgData.c1(i << 3, yc << 1) = c1;
    }
    // generate bitmaps
    for (int i = 0; i < 2; i++) {
      for (int j = (enable40ColumnMode ? 0 : 4);
           j < (enable40ColumnMode ? 160 : 156);
           j++) {
        int     xc = (j << 1) - xShiftTable[yc + i];
        int     n = xc >> 3;
        int     c = ditheredImage[(yc + i) * 160L + j];
        int     ci = 0;
        double  minErr = errorTable[(c << 7) | (i == 0 ? color0_0 : color0_1)];
        double  err = errorTable[(c << 7) | attrBlocks[n].color1];
        if (err < minErr) {
          ci = 1;
          minErr = err;
        }
        err = errorTable[(c << 7) | attrBlocks[n].color2];
        if (err < minErr) {
          ci = 2;
          minErr = err;
        }
        err = errorTable[(c << 7) | (i == 0 ? color3_0 : color3_1)];
        if (err < minErr)
          ci = 3;
        prgData.setPixel(xc & (~(int(1))), (yc + i) << 1, bool(ci & 2));
        prgData.setPixel(xc | 1, (yc + i) << 1, bool(ci & 1));
      }
    }
    // return the total amount of error
    return bestErr;
  }

  bool P4FLI_MultiColorNoInterlace::processImage(
      PRGData& prgData, unsigned int& prgEndAddr,
      const char *infileName, YUVImageConverter& imgConv,
      Plus4Emu::ConfigurationDB& config)
  {
    try {
      monitorGamma = config["monitorGamma"];
      ditherLimit = config["ditherLimit"];
      ditherScale = config["ditherDiffusion"];
      ditherMode = config["ditherMode"];
      xShift0 = config["xShift0"];
      borderColor = config["borderColor"];
      nLines = config["verticalSize"];
      if (nLines >= 256)
        nLines = nLines >> 1;
      conversionQuality = config["multiColorQuality"];
      luminance1BitMode = config["luminance1BitMode"];
      checkParameters();
      createErrorTable(double(config["mcColorErrorScale"]));
      enable40ColumnMode = (xShift0 == 0);
      float   borderY = 0.0f;
      float   borderU = 0.0f;
      float   borderV = 0.0f;
      FLIConverter::convertPlus4Color(borderColor, borderY, borderU, borderV,
                                      monitorGamma);
      prgData.setConversionType(5);
      prgData.clear();
      prgData.borderColor() = (unsigned char) borderColor;
      prgData.setVerticalSize(nLines);
      for (int yc = 0; yc < 248; yc++) {
        resizedImage.y()[yc].clear();
        resizedImage.y()[yc].setBorderColor(borderY);
        resizedImage.u()[yc].clear();
        resizedImage.u()[yc].setBorderColor(borderU);
        resizedImage.v()[yc].clear();
        resizedImage.v()[yc].setBorderColor(borderV);
        ditherErrorImage.y()[yc].clear();
        ditherErrorImage.u()[yc].clear();
        ditherErrorImage.v()[yc].clear();
      }
      imgConv.setImageSize((enable40ColumnMode ? 640 : 608), nLines * 2);
      imgConv.setPixelAspectRatio(1.0f);
      imgConv.setPixelStoreCallback(&pixelStoreCallback, (void *) this);
      imgConv.convertImageFile(infileName);
      // initialize horizontal scroll table
      int     randomSeed = 0;
      Plus4Emu::setRandomSeed(randomSeed,
                              Plus4Emu::Timer::getRandomSeedFromTime());
      for (int i = 0; i < nLines; i++) {
        int     xShift_ = xShift0;
        if (xShift_ == -2)
          xShift_ = Plus4Emu::getRandomNumber(randomSeed) & 7;
        else if (xShift_ == -1)
          xShift_ = 0;
        xShiftTable[i] = xShift_ & 6;
      }
      // convert input image to 121 colors with dithering
      progressMessage("Calculating FLI data");
      for (int yc = 0; yc < nLines; yc++) {
        if (!setProgressPercentage(yc * 20 / nLines)) {
          prgData[0] = 0x01;
          prgData[1] = 0x10;
          prgData[2] = 0x00;
          prgData[3] = 0x00;
          prgEndAddr = 0x1003U;
          progressMessage("");
          return false;
        }
        ditherLine(yc);
      }
      // generate FLI data
      double  totalError = 0.0;
      for (int yc = 0; yc < nLines; yc += 2) {
        if (!setProgressPercentage((yc * 80 / nLines) + 20)) {
          prgData[0] = 0x01;
          prgData[1] = 0x10;
          prgData[2] = 0x00;
          prgData[3] = 0x00;
          prgEndAddr = 0x1003U;
          progressMessage("");
          return false;
        }
        int     bestXShift0 = xShiftTable[yc + 0];
        int     bestXShift1 = xShiftTable[yc + 1];
        if (xShift0 == -1) {
          // find optimal horizontal shifts
          double  minErr = 1000000.0;
          for (int xs0 = 0; xs0 < 8; xs0 += 2) {
            for (int xs1 = 0; xs1 < 8; xs1 += 2) {
              xShiftTable[yc + 0] = xs0;
              xShiftTable[yc + 1] = xs1;
              double  err = convertTwoLines(prgData, yc);
              if (err < minErr) {
                bestXShift0 = xs0;
                bestXShift1 = xs1;
                minErr = err;
              }
            }
          }
        }
        xShiftTable[yc + 0] = bestXShift0;
        xShiftTable[yc + 1] = bestXShift1;
        totalError += convertTwoLines(prgData, yc);
      }
      setProgressPercentage(100);
      progressMessage("");
      {
        char    tmpBuf[64];
        totalError =
            std::sqrt(totalError
                      / double(nLines * (enable40ColumnMode ? 160 : 152)));
        std::sprintf(&(tmpBuf[0]), "Done, RMS error = %.4f", totalError);
        progressMessage(&(tmpBuf[0]));
      }
      if (!enable40ColumnMode) {
        // bug fix for the case when all X shifts are zero after optimization:
        int     tmp = 0;
        for (int yc = 0; yc < nLines; yc++)
          tmp = tmp | xShiftTable[yc];
        if (!(tmp & 6)) {
          // clear the first and last character column to border color
          int     l = (borderColor & 0x70) >> 4;
          int     c = borderColor & 0x0F;
          if (c != 0)
            l++;
          for (int yc = 0; yc < nLines; yc++) {
            prgData.l0(0, yc << 1) = l;
            prgData.c0(0, yc << 1) = c;
            prgData.l1(0, yc << 1) = l;
            prgData.c1(0, yc << 1) = c;
            prgData.l0(312, yc << 1) = l;
            prgData.c0(312, yc << 1) = c;
            prgData.l1(312, yc << 1) = l;
            prgData.c1(312, yc << 1) = c;
            for (int i = 0; i < 8; i++) {
              prgData.setPixel(i, yc << 1, bool(i & 1));
              prgData.setPixel(312 + i, yc << 1, bool(i & 1));
            }
          }
        }
      }
      // write PRG output
      for (int yc = 0; yc < nLines; yc++) {
        int     xs0 = (xShiftTable[yc] & 0x06) | 0x10;
        prgData.lineXShift(yc << 1) = (unsigned char) xs0;
      }
      prgData.convertImageData();
      prgEndAddr = prgData.getImageDataEndAddress();
    }
    catch (...) {
      prgData[0] = 0x01;
      prgData[1] = 0x10;
      prgData[2] = 0x00;
      prgData[3] = 0x00;
      prgEndAddr = 0x1003U;
      progressMessage("");
      throw;
    }
    return true;
  }

}       // namespace Plus4FLIConv

