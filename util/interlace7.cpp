
// interlace7.cpp: simple high resolution interlaced FLI converter utility
// Copyright (C) 2007-2008 Istvan Varga <istvanv@users.sourceforge.net>
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// The Plus/4 program files generated by this utility are not covered by the
// GNU General Public License, and can be used, modified, and distributed
// without any restrictions.

#include "plus4emu.hpp"

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>

#include <FL/Fl.H>
#include <FL/Fl_Image.H>
#include <FL/Fl_Shared_Image.H>
#include <FL/Fl_PNG_Image.H>

namespace Plus4FLIConv {

  class YUVImageConverter {
   private:
    int     width;
    int     height;
    float   pixelAspectRatio;
    float   scaleX;
    float   scaleY;
    float   offsetX;
    float   offsetY;
    float   yGamma;
    float   yMin;
    float   yMax;
    float   colorSaturationMult;
    float   colorSaturationPow;
    float   borderColorY;
    float   borderColorU;
    float   borderColorV;
    void    (*storePixelFunc)(void *userData, int xc, int yc,
                              float y, float u, float v);
    void    *storePixelFuncUserData;
    static void defaultStorePixelFunc(void *userData, int xc, int yc,
                                      float y, float u, float v);
   public:
    YUVImageConverter();
    virtual ~YUVImageConverter();
    void convertImageFile(const char *fileName);
    inline void setImageSize(int w, int h)
    {
      width = w;
      height = h;
    }
    inline void setPixelAspectRatio(float r)
    {
      pixelAspectRatio = r;
    }
    inline void setXYScaleAndOffset(float xs, float ys, float xo, float yo)
    {
      scaleX = xs;
      scaleY = ys;
      offsetX = xo;
      offsetY = yo;
    }
    inline void setYGamma(float g)
    {
      yGamma = g;
    }
    inline void setLuminanceRange(float minVal, float maxVal)
    {
      yMin = minVal;
      yMax = maxVal;
    }
    inline void setColorSaturation(float m, float p)
    {
      colorSaturationMult = m;
      colorSaturationPow = p;
    }
    inline void setBorderColor(float y, float u, float v)
    {
      borderColorY = y;
      borderColorU = u;
      borderColorV = v;
    }
    inline void setPixelStoreCallback(void (*func)(void *userData,
                                                   int xc, int yc,
                                                   float y, float u, float v),
                                      void *userData_)
    {
      storePixelFunc = func;
      storePixelFuncUserData = userData_;
    }
  };

  void YUVImageConverter::defaultStorePixelFunc(void *userData, int xc, int yc,
                                                float y, float u, float v)
  {
    (void) userData;
    (void) xc;
    (void) yc;
    float   r = (v / 0.877f) + y;
    float   b = (u / 0.492f) + y;
    float   g = (y - ((r * 0.299f) + (b * 0.114f))) / 0.587f;
    r = (r > 0.0f ? (r < 1.0f ? r : 1.0f) : 0.0f);
    g = (g > 0.0f ? (g < 1.0f ? g : 1.0f) : 0.0f);
    b = (b > 0.0f ? (b < 1.0f ? b : 1.0f) : 0.0f);
    std::fputc(int(r * 255.0f + 0.5f), stdout);
    std::fputc(int(g * 255.0f + 0.5f), stdout);
    std::fputc(int(b * 255.0f + 0.5f), stdout);
  }

  YUVImageConverter::YUVImageConverter()
    : width(640),
      height(400),
      pixelAspectRatio(1.0f),
      scaleX(1.0f),
      scaleY(1.0f),
      offsetX(0.0f),
      offsetY(0.0f),
      yGamma(1.0f),
      yMin(0.0f),
      yMax(1.0f),
      colorSaturationMult(1.0f),
      colorSaturationPow(1.0f),
      borderColorY(0.0f),
      borderColorU(0.0f),
      borderColorV(0.0f),
      storePixelFunc(&defaultStorePixelFunc),
      storePixelFuncUserData((void *) 0)
  {
  }

  YUVImageConverter::~YUVImageConverter()
  {
  }

  void YUVImageConverter::convertImageFile(const char *fileName)
  {
    if (fileName == (char *) 0 || fileName[0] == '\0')
      throw Plus4Emu::Exception("invalid image file name");
    float     *windowX = (float *) 0;
    float     *windowY = (float *) 0;
    float     *inputImage = (float *) 0;
    Fl_Image  *f = Fl_Shared_Image::get(fileName);
    if (!f)
      throw Plus4Emu::Exception("error opening image file");
    try {
      int     cnt = f->count();
      int     d = f->d();
      size_t  w = size_t(f->w());
      size_t  h = size_t(f->h());
      const char  *p = (char *) 0;
      if (cnt == 1)
        p = f->data()[0];
      if ((d < 1 || d > 4) || (w < 32 || w > 8192) || (h < 32 || h > 6144) ||
          p == (char *) 0) {
        throw Plus4Emu::Exception("image format is not supported");
      }
      // read input image, and convert it to YUV format
      inputImage = new float[w * h * 3];
      bool    haveAlpha = !(d & 1);
      for (size_t yc = 0; yc < h; yc++) {
        for (size_t xc = 0; xc < w; xc++) {
          float   r = 0.0f;
          float   g = 0.0f;
          float   b = 0.0f;
          const char  *pixelPtr = &(p[((yc * w) + xc) * size_t(d)]);
          if (d < 3) {
            r = float((unsigned char) pixelPtr[0]) * (1.0f / 255.0f);
            g = r;
            b = r;
          }
          else {
            r = float((unsigned char) pixelPtr[0]) * (1.0f / 255.0f);
            g = float((unsigned char) pixelPtr[1]) * (1.0f / 255.0f);
            b = float((unsigned char) pixelPtr[2]) * (1.0f / 255.0f);
          }
          r = (r * (yMax - yMin)) + yMin;
          g = (g * (yMax - yMin)) + yMin;
          b = (b * (yMax - yMin)) + yMin;
          r = (r > 0.0f ? (r < 1.0f ? r : 1.0f) : 0.0f);
          g = (g > 0.0f ? (g < 1.0f ? g : 1.0f) : 0.0f);
          b = (b > 0.0f ? (b < 1.0f ? b : 1.0f) : 0.0f);
          float   y = (r * 0.299f) + (g * 0.587f) + (b * 0.114f);
          float   u = (b - y) * 0.492f * colorSaturationMult;
          float   v = (r - y) * 0.877f * colorSaturationMult;
          y = float(std::pow(y, yGamma));
          double  c = std::sqrt((u * u) + (v * v));
          if (c > 0.000001) {
            c = c * (1.0 / 0.19);
            c = std::pow(c, double(colorSaturationPow)) / c;
            u = float(c * u);
            v = float(c * v);
          }
          if (haveAlpha) {
            float   a =
                float((unsigned char) pixelPtr[d - 1]) * (1.0f / 255.0f);
            y = (y * a) + (borderColorY * (1.0f - a));
            u = (u * a) + (borderColorU * (1.0f - a));
            v = (v * a) + (borderColorV * (1.0f - a));
          }
          float   *ptr = &(inputImage[((yc * w) + xc) * 3]);
          ptr[0] = y;
          ptr[1] = u;
          ptr[2] = v;
        }
      }
      delete f;
      f = (Fl_Image *) 0;
      // initialize interpolation window
      float   aspectScale = (float(width) * pixelAspectRatio / float(height))
                            / (float(int(w)) / float(int(h)));
      float   xScale = float(int(w)) / float(width);
      float   yScale = float(int(h)) / float(height);
      if (aspectScale < 1.0f)
        yScale = yScale / aspectScale;
      else
        xScale = xScale * aspectScale;
      xScale = xScale / scaleX;
      yScale = yScale / scaleY;
      float   xOffs = (float(int(w)) * 0.5f) - (float(width) * 0.5f * xScale);
      float   yOffs = (float(int(h)) * 0.5f) - (float(height) * 0.5f * yScale);
      xOffs = xOffs - (offsetX * xScale);
      yOffs = yOffs - (offsetY * yScale);
      windowX = new float[1025];
      windowY = new float[1025];
      for (int x = 0; x < 1025; x++) {
        double  xf = double(x - 512) * (3.14159265 / 1024.0);
        double  wx = std::cos(xf);
        wx = wx * wx;
        float   xs = (xScale <= 1.0f ? 1.0f : (1.0f / xScale));
        xs = (xs > 0.2f ? xs : 0.2f);
        xf = xf * 16.0 * xs;
        if (xf < -0.000001 || xf > 0.000001)
          wx = wx * std::sin(xf) / xf;
        windowX[x] = float(wx * xs);
      }
      for (int y = 0; y < 1025; y++) {
        double  yf = double(y - 512) * (3.14159265 / 1024.0);
        double  wy = std::cos(yf);
        wy = wy * wy;
        float   ys = (yScale <= 1.0f ? 1.0f : (1.0f / yScale));
        ys = (ys > 0.2f ? ys : 0.2f);
        yf = yf * 16.0 * ys;
        if (yf < -0.000001 || yf > 0.000001)
          wy = wy * std::sin(yf) / yf;
        windowY[y] = float(wy * ys);
      }
      // scale image to the specified width and height
      for (int yc = 0; yc < height; yc++) {
        double  yf = double(yc) * yScale + yOffs;
        int     yi = int(yf);
        yf = yf - double(yi);
        if (yf < 0.0) {
          yf += 1.0;
          yi--;
        }
        for (int xc = 0; xc < width; xc++) {
          double  xf = double(xc) * xScale + xOffs;
          int     xi = int(xf);
          xf = xf - double(xi);
          if (xf < 0.0) {
            xf += 1.0;
            xi--;
          }
          double  wxf = 63.999999 * (1.0 - xf);
          double  wyf = 63.999999 * (1.0 - yf);
          int     wxi = int(wxf);
          wxf = wxf - double(wxi);
          int     wyi = int(wyf);
          wyf = wyf - double(wyi);
          float   xs0 = float(1.0 - wxf);
          float   xs1 = float(wxf);
          float   ys0 = float(1.0 - wyf);
          float   ys1 = float(wyf);
          float   y = 0.0f;
          float   u = 0.0f;
          float   v = 0.0f;
          if (xi >= 7 && xi < int(w - 8) && yi >= 7 && yi < int(h - 8)) {
            // faster code for the case when no pixels are clipped
            float   *ptr = &(inputImage[(((yi - 7) * int(w)) + (xi - 7)) * 3]);
            for (int wy = -7; wy <= 8; wy++) {
              float   wsy = (windowY[wyi] * ys0) + (windowY[wyi + 1] * ys1);
              for (int wx = -7; wx <= 8; wx++) {
                float   wsx = (windowX[wxi] * xs0) + (windowX[wxi + 1] * xs1);
                float   w_ = wsx * wsy;
                y += (ptr[0] * w_);
                u += (ptr[1] * w_);
                v += (ptr[2] * w_);
                wxi = wxi + 64;
                ptr = ptr + 3;
              }
              wxi = wxi - 1024;
              wyi = wyi + 64;
              ptr = ptr + ((int(w) - 16) * 3);
            }
          }
          else {
            for (int wy = -7; wy <= 8; wy++) {
              float   wsy = (windowY[wyi] * ys0) + (windowY[wyi + 1] * ys1);
              for (int wx = -7; wx <= 8; wx++) {
                int     x_ = xi + wx;
                int     y_ = yi + wy;
                float   wsx = (windowX[wxi] * xs0) + (windowX[wxi + 1] * xs1);
                float   w_ = wsx * wsy;
                if (x_ < 0 || x_ >= int(w) || y_ < 0 || y_ >= int(h)) {
                  y += (borderColorY * w_);
                  u += (borderColorU * w_);
                  v += (borderColorV * w_);
                }
                else {
                  float   *ptr = &(inputImage[((y_ * int(w)) + x_) * 3]);
                  y += (ptr[0] * w_);
                  u += (ptr[1] * w_);
                  v += (ptr[2] * w_);
                }
                wxi = wxi + 64;
              }
              wxi = wxi - 1024;
              wyi = wyi + 64;
            }
          }
          y = (y > 0.0f ? (y < 1.0f ? y : 1.0f) : 0.0f);
          u = (u > -0.436f ? (u < 0.436f ? u : 0.436f) : -0.436f);
          v = (v > -0.615f ? (v < 0.615f ? v : 0.615f) : -0.615f);
          storePixelFunc(storePixelFuncUserData, xc, yc, y, u, v);
        }
      }
      delete[] windowX;
      delete[] windowY;
      delete[] inputImage;
    }
    catch (...) {
      if (windowX)
        delete[] windowX;
      if (windowY)
        delete[] windowY;
      if (inputImage)
        delete[] inputImage;
      if (f)
        delete f;
      throw;
    }
  }

}       // namespace Plus4FLIConv

// ----------------------------------------------------------------------------

static const int ditherTable[4096] = {
  3958, 1538,    1, 3691, 1863, 2352,  626, 3333,  305, 2638,  743, 2803,
   468, 1740, 3146, 1273, 2764, 1058, 2968, 1941,  897, 2101, 3649,  730,
  2183, 3746, 1193, 2735,  990, 2911, 1854, 2351,  695, 3807,  948, 2321,
  3620, 1652,    3, 3523, 1287, 2452, 1530, 2935, 1233,   49, 1767, 4046,
  1447, 3331, 1156, 1987, 3770, 1534, 3272,  273, 2308, 3675, 1580,   42,
  2785, 1022, 3575, 1991,  527, 2237, 3346, 1439,  357, 3867, 1683, 2167,
  3950, 1161, 3608, 1398, 2359, 4039,   86, 3521, 1424, 3739,  703, 2562,
  3814, 1436,  202, 3381, 1637,  478, 3235, 2018, 3528,  451, 3880, 1280,
  2784, 1456, 2984,  229, 1378, 3198, 2206,  673, 2031, 3638,  742, 1843,
  3837, 1981, 3244,  356, 2438,  659, 3913,  471, 2458,  632, 2165, 4086,
  1413,  485, 2138, 3883,  828, 2559,  206, 2982, 1933, 2831,  866, 2422,
  3111, 1114, 2874,  947, 1925, 2521,  173, 3090,  619, 2005, 3004,  796,
  2297,  298, 3201, 1566,  443, 2244, 3029, 1153, 2453, 4054, 1392,  116,
  1718, 2596,  799, 3354,   67, 3454, 1074, 4024, 2489,  817, 3851, 1731,
  2800,  159, 3174, 2360,  420, 2680,  812, 2971, 1693, 2706, 1266, 3115,
  1062, 3520, 1702,  889, 2954, 1828, 2732, 1174, 2893, 1448, 3372, 1152,
  3728,  283, 4007, 1753,  589, 3463,  103, 3657,  552, 3279, 2119, 1513,
  3704, 1038, 2414, 1634, 3960, 1986, 1084, 3581, 1804, 3912,  625, 2772,
   339, 2117, 3051, 1928, 3156, 1342, 2973, 1179, 2433, 1768, 2277,  567,
  1873, 2731,  378, 3371, 1028, 4069, 2100,  885, 3490, 1496, 3754,  995,
  3457,  105, 3627, 1883, 2870,  209, 2581, 3407,  115, 3816,  647, 3447,
   381, 4036,  596, 2148, 1085, 2546, 1254, 2958, 1905, 2283, 1559, 2574,
  2046, 1320, 3796,  422, 1957, 3375,  224, 2748,  532, 3105, 2467,  134,
  2839,  867, 3283, 1948, 3693, 1263,  691, 3615,  557, 3972,  282, 1984,
  3571,  400, 3714, 1591, 3320, 1088, 2956, 1505, 2540,  537, 1613, 2882,
  1298, 2608,  223, 2333, 1407, 2833, 1609,  399, 2184, 3949, 1217, 1972,
  2334, 1384, 3125, 2060, 1662, 2354, 1795, 3251, 2722,  669, 3296,  195,
  3595,  769, 3906,  327, 3217,  849, 2448, 1721, 2819,  717, 3154, 1458,
  3628,  965, 1855, 3362, 1229, 2644, 1499,   50, 1669, 2919, 2226, 1552,
  2480, 1042, 2174, 3223, 1001, 2809,  844, 3088,  124, 3918, 2185,  261,
  3744, 2012, 3536,   85, 3944,  702, 3415, 1133, 4006,  748, 2499, 3794,
  1460,  666, 3231,  458, 3710,  795, 2471,  157, 3639,  735, 3028,   77,
  1506, 3541, 1672, 2455, 1416, 2708, 1127, 2943, 1650, 4061,   19, 3419,
  1188, 3848, 1815,  832, 2249, 2948,  408, 2200, 4032,  521, 3549, 2048,
  3946,  492, 3428,  179, 3735, 1752, 2709,  711, 4041, 1842, 2343, 1430,
  2565, 1950,  968, 3123,  761, 1364, 2240, 3079, 1103, 2468, 1657, 2653,
   438, 3147, 2074,  878, 3318, 2390, 1107, 2927, 1734, 2689, 1524, 3219,
  1072, 2633, 1371, 3852, 2324,  367, 2863,  714, 3810,  448, 3388, 2155,
   991, 2245, 2899,  802, 2651,  344, 2506, 3983,   62, 2040, 3802, 1132,
  1967, 2494,  920, 2873, 1323, 2572, 1147, 2828,  822, 3258,   27, 2992,
  1531,  215, 3765,  653, 3468,  483, 3576, 1579, 2282, 3352,  389, 1760,
  2781,  302, 3274,  856, 3602, 1745,  180, 2898, 1849,   59, 3614, 2103,
   292, 3997,  555, 1886, 3920,  332, 3323,  803, 1166, 4074, 1054, 3084,
  1339, 2607, 1870,  146, 3555,  575, 1369, 3679, 1887, 3472, 1050, 2107,
  3214, 1374,  687, 3013,  166, 3185, 1884,  278, 3393,  667, 3857, 1796,
  2368, 1450, 3826,  907, 2087, 3193, 1128, 3036, 2110, 1336, 2623,   37,
  4015, 1215, 2144, 3708,  781, 3849, 1316, 2865, 1183, 2303, 3471,  986,
  4059, 1570, 2529,  765, 3182, 1428, 2202, 2852, 1247, 2492, 1629, 2808,
  3210, 1920, 2384,   47, 3451,  893, 3974, 1476, 2782, 1835, 3119, 2204,
   183, 1525, 2988,  515, 1663, 3573, 2235, 1574, 3749,  976, 3499, 2331,
  1097, 2941, 2156,  371, 3585,  617, 2214, 2650, 3507,  545, 1917, 2416,
   307, 3952, 2022, 3003, 1929,  565, 2686, 1415, 3131, 1834, 2254,   18,
  3925,  574, 1945, 2634,  372, 3064, 1343, 3762, 2029,  909, 3567,   24,
  3434,  705, 3698,  177, 1746,  498, 3664, 1585, 2090, 2666,  316, 2488,
   746, 3766,  395, 1222, 4020, 2554,  914, 3726, 2445,  263, 3096,  577,
  1845, 2758,  428, 2008, 4005,  104, 1598, 3071, 1366, 3179, 1720,  345,
  1307, 2511, 3868,  952, 3330, 1641,  620, 1150, 3662, 1682, 3299,  151,
  2348,  508, 3542, 1791, 2402, 1545, 3724, 1210, 3397, 1913,  588, 2594,
   216, 3092, 1707, 2418, 1124, 2932, 1435, 2655, 3348, 2171, 1271, 3238,
   613, 3709, 1632, 3264, 2038, 1404, 2699, 3342, 1737,  453, 3307, 2025,
  1317, 2810, 1121, 4079, 2380, 1218, 3612, 1352, 2659, 1827, 3676,  879,
  2745,  204, 4090, 1976, 3656, 1603,   74, 2891, 1197, 2719, 1862, 3153,
   335, 2485,  956, 3891, 1244, 2979, 1002, 3212,  756, 3042,  255, 2712,
   845, 2322, 3480, 1039, 3842, 2220,  479, 4048, 1996,  409, 3806,  655,
  1000, 3875,  266, 2756, 2000, 1177, 2340,  538, 3935,   70, 2239,  622,
  2128, 3075, 1583,   98, 3903,  854, 3385, 1715,    4, 2885,  871, 3126,
   723, 2439,  449, 3230, 1205, 2536, 1018, 2701,  509, 2963, 2208,  789,
  3596,  185, 3776, 2247, 1495, 3437, 2077,  608, 2582, 1587, 4082,  362,
  2753, 1068, 3305, 1666, 3979,  130, 1489, 2907, 1639,  786, 2816,  971,
  3158, 2295, 1297, 2576, 3070, 1773, 2437, 1390, 4026,  168, 3503, 1304,
  2567, 1784, 3604, 1438, 3825, 1014, 2396, 3433, 1201, 2694,  383, 2168,
  3268, 1486, 3886,  222, 1989, 3812, 1510, 2142, 3928,  583, 3475, 1437,
  3361,  928, 3999, 1777, 2125, 2843, 1325,  579, 4050,   95, 2775, 1770,
  3689,  196, 1896, 2545, 1426, 3822, 1880,  543, 2510, 1858, 3683,  432,
  2096, 3291, 1260, 3631,  240, 1832, 3406,   99, 2193,  814, 3593,  563,
  2104, 3143, 1705, 2983,  794, 3197,  902, 2892,  218, 2736,  732, 2079,
  3141,  679, 1952, 3788,  757, 2600, 1079, 2294, 3344,  827, 3000,   43,
  1660, 2934, 1946,  137, 2016, 2614,  290, 3170,  641, 1539, 3367, 2172,
  1112, 2945, 1351, 3189,  911, 2190, 3392,  833, 2876,   82, 2285, 3560,
   935, 3234, 1145, 2461, 3961,   69, 1968, 2369, 1541, 2999,  922, 3993,
   376, 2834, 1487, 2937,  962, 2473,  425, 2053, 3752,  336, 2373, 1881,
  3485, 1289, 3995,  314, 1678, 3634, 2475, 1245, 2788,  300, 3449, 1747,
   475, 2767, 1267, 3432, 2353,  978, 3603, 1742, 3805, 1073, 3532, 1230,
  2399, 3910,  375, 3052, 1960,  661, 3589,  348, 1983, 3018,  455, 3787,
  1333, 3262, 1235, 2051, 2805,  275, 3005,  629, 1443, 2620, 3465,  610,
  3900,  505, 2739, 1955, 3730, 1094, 3358,   12, 3859, 1445, 3546, 1139,
  2292, 1554, 4087,  501, 1615, 2859,  969, 2211, 2924, 1423,  142, 3324,
   994, 3083, 1344, 4049, 2508, 1029, 3738, 2067,  648, 2820,  326, 2673,
   727, 2502, 1470, 3024,   10, 1736, 2692,  943, 3420, 2520, 1011, 2376,
  3984, 1165, 2631, 1622, 2417,  733, 4029,  473, 1595, 3873, 2231, 1822,
  3584,  862, 1651, 2696, 1203, 3202, 2127, 1349,  741, 2628, 1676, 2363,
  1236, 2676,  763, 3181,  119, 3061, 1077, 2544, 3295,   33, 1963, 3537,
   550, 3866, 2124, 1793, 3953,  643, 2273,  113, 1888, 3134,  355, 1617,
  3280, 1237, 4021, 1564, 3236,  424, 2737,  840, 3684, 2269, 1269, 3845,
   211, 1689, 3751, 1528,   45, 3338,  650, 3610,  232, 2986, 1035, 2561,
  3424, 1367,  698, 3137,  186, 2175, 3254,  299, 3672, 1739,  148, 2974,
  3488,  289, 4056,  640, 3440,  259, 3784, 1890, 2580,  671, 3527, 2003,
   932, 3809, 2407, 1329, 2754, 1108, 3048,  415, 2424, 1653, 2977, 1285,
  3646,  775, 2412, 3861,  169, 3058, 2217,  959, 2130, 3942, 1162, 3310,
  1820,  470, 3228,  778, 2307, 3089,  541, 2747, 2154, 1748, 2912,  977,
  2599, 1482, 3216, 2112,    6, 2014, 3655, 1181, 1937, 4091, 1102, 2583,
   954, 2345, 3838, 1061, 1548, 2495, 1189, 2850, 1910, 2961, 1624,  910,
  3908, 1763, 2266,  272, 3103, 1713,  592, 3176,  205, 2534,  859, 3721,
  1393, 3558,  535, 3304, 1500, 2687, 1973, 1144, 2637, 1850,  560, 3395,
    78, 1895, 2867,  257, 2431, 4076, 1420, 2762, 1801, 1056, 3504, 1240,
  3828,  421, 1908, 3933, 1220, 3509,  392, 1684, 3317, 2487,  496, 2949,
  2442,  414, 3050, 1467, 3531,  683, 1846, 2768, 3297,  800, 3640, 2166,
   513, 1318, 3386, 2413,  406, 3032,  852, 3971, 1115, 2313, 3654, 1206,
  4066, 1535, 3246, 1902,   55, 2570, 1812, 2329,  230, 3986,  486, 3456,
   886, 3669, 1521, 2289, 3769,  998, 2229, 3621, 1573,  675, 2960,  109,
  3195, 2054,  297, 2835,  873, 3113, 2296,  132, 2703,  806, 2350, 3855,
  1310,  829, 3943, 2092, 1007, 3737,  749, 2792,   39, 3161, 2275,  442,
  1401, 3077,   91, 1726, 3965, 2595,  158, 2064, 3600, 1291, 2647, 1508,
  2904,  379, 1839, 2822,  785, 2668,  493, 2299, 3497,  917, 3922,  987,
  3200, 2120, 1417, 2259, 2916,  386, 2812,  819, 2044, 3044,  627, 1321,
  3124, 2094, 1200, 3727,  930, 4003, 2356, 1396, 3645, 1712,  768, 3302,
  1409, 3732, 1809,  249, 2588, 3038, 1607,  117, 3401, 1709, 2309, 1231,
  4013, 1782,  992, 3929, 2609,  937, 2383, 3265,  868, 1571, 3706, 1432,
   715, 3256,   64, 3715,  772, 3508, 2250,  127, 3462, 1355, 3831, 1159,
  2072, 2908,  318, 2741, 1706,  614, 3578,   21, 1761, 4063, 1387, 3327,
   276, 1640, 3895, 2004,  163, 3565, 2454,  403, 2654, 1619,  586, 3359,
   174, 2641, 4067, 1024, 3009,  459, 2143, 3130, 1503,  571, 3513, 1899,
  2539,  320, 3332, 2062,  581, 2182, 2910,  207, 1515, 3742, 2033,  350,
  2880, 2134,  568, 2224, 2842, 1597, 2484, 1379, 2723, 1751, 1069, 3152,
  1628, 2472,  254, 2998,  600, 1776, 3423, 1135, 3797, 2242, 1584, 2151,
  3106,  744, 2542, 1046, 3718, 2466,  494, 3378, 2598, 1701,  808, 3452,
  1283, 3247, 1868, 2481, 1262, 2105,  512, 2010, 2434, 1582, 3580,  981,
  4040, 2264,  918, 2881, 1096, 3081,  890, 3777, 1498, 3500, 1276, 3410,
  2980,  481, 1802, 3373, 1157, 3844, 1788, 3482,  303, 4051,  611, 3366,
   236, 3894, 2435,  460, 4010,  820, 3347, 1449, 3686, 2382,  697, 2629,
   154, 3259,  804, 3840, 1093, 2726,  147, 3150, 2089, 1130, 2952, 1464,
   602, 3951, 2284, 1031, 2905,   28, 3881,  692, 3544, 2743, 1361, 3800,
    61, 3370,  670, 2797,  164, 1769, 3696,  401, 3911, 1556, 2425,  143,
  2829,  388, 2517,  693, 1322, 2323, 4071,  810, 2725,   26, 2987,  973,
  2617, 1225, 2939, 1006, 2335, 2013,  939, 2920, 1264, 2590, 1020, 2796,
    93, 1311, 4028, 1555, 3022, 1256, 2603,  341, 3436, 1949, 3931, 1675,
   594, 3484,   52, 2339, 3072, 1406,  243, 3792, 1744, 2327, 1433, 3055,
  1924,  270, 3209, 1655, 2900, 1083, 2618, 1301, 3276, 2411, 1224, 2773,
  1856,  558, 3188, 2030, 1692, 3618, 1122, 3890, 2681, 1661,  245, 3155,
  1474, 2525, 1251, 3233,  529, 3644, 2176, 1656, 3775,  681, 3592, 1698,
  3418,  325, 3733, 2203, 1837, 3066, 2042,  510, 1980, 3747, 1009, 2966,
  1772,  548, 1368, 2857, 2215, 1560, 4043, 1934,  894, 3335, 2027, 2720,
   634, 3594,  436, 2194,  857, 3687, 2126,  553, 2037, 3957,  315, 3635,
  1985,  758, 3110,   31, 2330, 3564, 1027, 3973,  946, 2216, 2887,   66,
   926, 3091, 2068, 1034, 3583,  726, 3981, 1618, 2457, 1951,  112, 3020,
   419, 2691, 1943,    8, 1997, 2861, 1543,  729, 3884,  393, 3563, 1733,
  3355,  265, 2428, 1332, 3288, 2021, 3624,  306, 3411,  721, 2523,  412,
  3705, 2389,  782, 1511, 3173, 1168, 2690, 4025, 1472, 2555, 1118, 3097,
  1324, 2385, 1754, 2281,  429, 3834, 1520, 3376, 1170, 2108, 2711,  256,
  3016,  616, 1940, 3322, 3700,  518, 3461, 2394,  373, 2671, 1859,  189,
  3524,  905, 3941, 1480, 3445, 1101, 3315, 1375, 3959,  582, 2139, 2953,
  1363, 2679, 1192, 2878,  936, 2713,  777, 3870,   83, 2551,  966, 2661,
  1175, 2897, 1252, 3187, 1816,  128, 2159, 3982,  288, 2503, 1900,  106,
  3289,  605, 3904,  193, 3522,  779, 3245, 1138, 2837, 1345, 2682,  836,
  4078,  466, 1833, 3425, 1418, 3795, 1265, 2161, 1757, 2806, 1185, 1930,
  3758, 1081, 3394, 2241, 1408, 2118, 2717,  790, 1798, 2611,  720, 3033,
  2260, 1239, 3389,  175, 3248,  665, 2504,   36, 4073, 1281, 3183, 1481,
  2778,  737, 3964, 1966, 3556,  182, 3778, 2207,  944, 2791, 3384, 1089,
  2099, 3511,  957, 2807, 2066, 1604, 2243, 2853, 1003, 2721,   89, 4016,
   642, 3493,  203, 1970, 2447, 1631, 2926,  895, 2558,  423, 2779,  219,
  2314,  674, 3936,  129, 2145, 2933,  464, 2825,  637, 3175,  285, 2055,
  3830,  199, 3650, 1874,  349, 3607, 1589, 2370, 1891, 3782,  997, 3464,
  1806, 2320,  358, 3677, 1075, 3095, 1664,  476, 1494, 2624, 1841,  506,
  3916, 1995,  445, 1783, 3011,  533, 1836, 3740,  385, 3470,  699, 1778,
  3819, 1454, 2519, 1253, 2989, 1679, 2228, 3312,  660, 3651,  108, 3863,
  1992, 3479, 1134, 4037, 1593, 3203, 1346, 3045, 1562,  874, 3659, 1818,
  4033, 1167, 3548, 2501,  888, 2888, 2233, 1043, 2082, 2547,  847, 4000,
   446, 1459, 3112, 2163,  531, 3014, 1694, 2091, 2397,  228, 3321, 2050,
  2994,  984, 3117, 1590, 2477, 1063, 3665, 2584,  913, 3858, 2361, 1216,
  2658, 1397, 2970, 2132,  364, 3345,  870, 3678, 1876,  503, 3761,  996,
  2766, 1395, 3171, 1567,  573, 1775, 3122,  831, 3574,  281, 2749,  591,
  3823, 2469, 1446,   48, 2093, 3062,  504, 1575, 3292, 1425,  472, 4083,
  2705,   68, 2975, 1129, 2838, 2221,  214, 1608, 3340, 1155, 3534,  657,
  4012, 1922,  843, 3643,    0, 4094,  682, 3519,  235, 3241, 1914,   58,
  3133, 1969,  208, 3271,  753, 4085,   14, 3626, 1292, 2201, 2917,  252,
  2693, 2121, 1504, 3074,  353, 2493,  858, 2677, 2047, 2896,    2, 2419,
  1982, 2272, 1685, 3416, 2002,  331, 2665, 3339,  759, 2379, 1853, 3898,
    97, 2036, 3213, 1670,  773, 3745, 1958, 3369,  631, 3663, 1857, 3927,
   908, 2793,  120, 2646, 1295, 2845, 2238, 1441, 2760, 1341, 2432, 1158,
  2847, 2232,  877, 4034, 2187, 1149, 3599, 1565, 2470, 1111, 2755, 1944,
  3194,  598, 1646, 3442, 1048, 3879,   54, 2180, 3947, 1160, 3529,  312,
  4004, 1040, 3736, 1388,  490, 3874,  798, 2341, 1148, 3118, 1723, 1012,
  3779, 1268, 2965, 1066, 2444, 3719,  982, 2357, 3128, 1468,  404, 1704,
  2577, 1212, 2728,  377, 2528, 1400, 3820, 1021, 3422,  322, 3756,  542,
  1861, 3404,  346, 3843, 1717,  559, 3426, 1546,  461, 2946,  680, 2786,
   337, 3148, 1703,  522, 1478, 3989, 2429,  813, 2860, 1383, 3286, 1803,
   621, 2826, 1953, 3211, 1296, 2465,  770, 3379, 2621, 1327, 3240,   88,
  4092,  823, 3570, 2325,  212, 2688,  384, 3408, 1533,  572, 3053,  251,
  1299, 3450, 2017, 3878,  136, 3505,  872, 3253,  713, 3087, 1898, 2342,
   752, 3139, 1577, 2147, 2922, 1082, 2669, 1275, 3285, 2063, 1019, 3049,
  2514, 1331, 3773, 1243, 3439,  916, 3872, 2257, 3025,  138, 1964, 3720,
   413, 2593,  728, 2403, 3622, 1462,  153, 1674, 2730,  360, 2947, 1209,
   194, 2848, 1519, 2597, 1278, 2814,  441, 1926, 3226, 1805, 4008,  921,
  2771, 2192, 1814, 3938, 2535,  525, 2818,  904, 3142, 1527, 2362, 1939,
  3992, 1248,  269, 3611, 1755, 2518,  919, 3905,  197, 3540,  644, 3023,
   114, 2605, 3699,  280, 1797, 3164,   92, 2291, 1771, 2564,  241, 2015,
   980, 3550, 1213, 2146, 3225, 1142, 4062, 1610,  457, 3351, 2019, 3817,
   963, 3690, 1732, 3270, 3991,  975, 3711,  710, 3466, 2170, 1551, 3865,
  1360,  585, 2150, 3001,  156, 3671,  649, 1391, 2086, 3586, 1116, 2640,
  1872,  561, 3701,   17, 1620, 2871, 2197, 1370, 3229,   73, 2976, 1228,
  2318, 1645, 2496, 1901, 3955,  787, 1680, 2271, 3888,  898, 1988, 3978,
   580, 3517, 1348, 3753, 2500,  708, 3300,  309, 1792, 2672,  123, 3107,
  2300, 1255, 2929,  718, 3140, 2153,  662, 2223, 1885, 2516,  416, 2993,
  1741,  149, 3076,  690, 2566, 3380, 1030, 1626, 3309, 1196, 2286, 3243,
    41, 1642, 2944,  301, 4060, 2278, 1335, 2589, 3455,  465, 3786,  595,
  2080, 4057,  689, 2034, 3629,  851, 3798,  439, 1522, 2405, 3492, 1358,
   526, 3356, 2615, 1059, 2886, 1576, 3094,  491, 1724, 2841, 1421, 2377,
  3781,  880, 3568, 2069, 1008, 3902,  271, 2552, 1867,   72, 3590, 1091,
   277, 3533, 1977, 1053, 3914, 2478, 1104, 3601, 2059,   16, 3815, 2507,
   454, 1979, 4042,  958, 2177, 3847,  755, 3282, 1727,  815, 3067, 1041,
  2001, 2440, 1536, 3030,  989, 2388, 1728, 3206,  380, 3057, 1412, 2213,
  3390, 1190,  178, 2991, 2451, 1601,  369, 3647, 2084,  152, 2355, 1906,
  3383,   38, 4031,  656, 1517, 3006, 1697,  516, 2877,  791, 2710, 1313,
  4047, 1469, 2645, 2073, 2374,  912, 2906, 2188,  556, 1892, 3166,  363,
  1452, 2955, 1764,  837, 3530, 2685,  291, 1897, 2901, 1164, 2602, 1259,
  2408, 3551,  242, 3896,  652, 3316,  145, 1848, 3667,  295, 3510,  891,
  2776, 1875,   44, 3177,  694, 2635, 4052, 2075,  993, 3104, 1866, 2312,
   736, 3319, 1036, 3915, 1163, 2626, 1326, 3167, 2276,  221, 2533, 3481,
  1365, 3668, 1060, 3414,  444, 3010,  842, 3306, 1658, 3954,   34, 3365,
  1605, 3666, 1202, 2387, 3977,  615, 2317, 3093, 1497,  734, 2218, 3613,
   514, 3438,  165, 3755,  484, 1912, 2854, 1414, 2761, 1186, 3975, 2302,
  1146, 2714, 1512, 2532, 1125, 3996, 2129, 1621, 3682, 1974, 1386,  628,
  3760,   23, 3429,  950, 4072, 1484, 2769,  328, 2978,  760, 3609,  452,
  1831, 3846, 1105, 1990, 2347,   20, 3196, 1824, 2400, 1623, 3850,  536,
  2950, 1261, 2575, 1381, 2660,  248, 2862,  855, 2106, 3222, 1309,  237,
  3764, 1826, 3186, 1057, 2765, 1544, 3163, 2205, 1485, 3101,  931, 2622,
   351, 3151, 2097,  517, 3391,  719, 3864,  160, 3431,  624, 2964,  482,
  2337,  246, 3257, 2541, 1471, 2652, 1238, 2734,  267, 2553,  839, 3702,
  1810, 2391, 1667, 2123, 3069,  635, 3363,  391, 3985, 1756, 2246,  587,
  3100,  172, 2261, 1921,  321, 3703,  751, 3483,  960, 4053, 1695, 3557,
   135, 1871, 3889, 2450,  896, 2849,   84, 3966, 2133,  861, 2011,  604,
  4019,   71, 3496, 1677, 3811,  901, 1738, 2884, 1457, 2426, 1319, 2913,
  1765, 2674, 1434, 3832,  945, 3543, 1825,  396, 3477,  704, 3813, 1735,
  3242, 1207, 3082, 2189,  607, 3446,  191, 3967,  983, 2801, 1490, 2667,
  1226, 3034,  940, 3790, 1171, 3617, 1372, 3398, 2757, 1099, 2423,  394,
  3015, 1904,  520, 2537, 1523, 2802,  546, 1714, 3448, 1340, 2579, 1860,
   410, 3692, 2718, 1394, 2486, 1800, 2262,  672, 2349, 1931, 3713,   32,
  3566,  427, 3277,  762, 2328,  284, 3157, 1249, 2750, 1338, 3002, 2280,
  1126, 2909, 2164,  502, 1919, 3862,   76, 1616, 3199, 1405, 2697, 1246,
  2456,   87, 3252,  686, 3545,  239, 2513, 1588, 2830,  724, 2625,  988,
  1492, 3266, 1766, 3803, 1303, 2290, 3337, 1037, 3047,  933, 3630, 2274,
   323, 3135,  663, 3514, 1636, 2301,  225, 3329,  792, 3636, 1119, 3255,
   210, 2928,  805, 2550, 1356, 2657, 1659, 4035, 1204, 3716,  824, 2464,
    81, 3921,  544, 1710, 4002,  140, 1557, 3674, 2436, 1087, 2815, 2045,
   407, 3763,  776, 3512, 1563, 3725, 1154, 2006, 2270, 1716, 3923,  343,
  1947, 3474,  102, 4070, 2306,  188, 2684,  633, 2890,   75, 2007, 3723,
   370, 3278, 1994, 1182, 4081, 1483, 2787, 1208, 3059,  949, 3924, 1708,
  2951,  333, 2795, 1568, 4088, 1385, 3467, 1052, 3939,  578, 3040,  122,
  2727, 1502, 3413, 1649, 3215, 1098, 2057, 3136,  925, 2522, 3334, 1362,
   340, 3554,  860, 4023, 2326, 1290, 2586,  294, 2942,  807, 2642, 4089,
   477, 3129,  876, 2332, 3172, 1279, 2548,  797, 1687, 3885, 1403, 3405,
  1187, 3932,  767, 2253, 1780, 2364,   46, 2925,  747, 2462,  181, 3799,
   495, 2613, 2023, 1045, 2212, 3835,  985, 2571,  750, 2449,  368, 3120,
  2227, 1549, 2160, 3350, 1004, 2560,  324, 2832,  590, 3661, 2420,  304,
  3495, 1794,  570, 2780, 2135, 1758, 3178,  551, 1889, 3041,  955, 3377,
  1786, 2316,  161, 1529, 2872, 1308, 3632, 1879,  528, 3757, 1051, 3353,
  2636,  688, 2393,  310, 2733, 1665, 3205, 1350, 3998, 1110, 3430, 1612,
  3707, 1140, 3360, 2157, 1553, 3237,    5, 3572,  549, 1877, 3298,  107,
  3400, 1473, 2744, 1903,  233, 3789,  864, 1894, 3588,  706, 3970, 1065,
  2298, 1936, 1293, 2855, 1169, 2263, 3899,  883, 3054,  167, 2476, 1547,
  3502,    7, 3893, 2173, 1070, 3801, 1923, 3343,  929, 2578,   53, 2799,
  1540, 2136, 2914,  431, 1315, 3458, 1594, 3652,  811, 2490,  231, 2783,
   469, 2648,  696, 2557,  347, 2678, 1749,  597, 4011, 1330, 2088, 2526,
  1586, 2700, 1306, 2866, 1214, 3887,  882, 3616, 1284, 2102, 2981,  405,
  2024, 3108, 1722, 2078, 3073,  200, 4080,  668, 3625,   51, 1978, 3263,
  1455, 3956,  964, 2869, 1198, 2729, 1730,  426, 3273,  645, 2763,  354,
  3836, 1851, 3435,  835, 4018,  213, 1774, 3688, 2997,    9, 2823,  999,
  2959, 1272, 3780, 1080, 3501, 1444, 3841, 1234, 3227,  924, 3037, 1918,
  2371,  387, 3459,  701, 3697,  286, 3980,  623, 2288,  456, 3017, 1596,
  3224,  638, 2255, 3731, 1195, 2401,   11, 3771,  801, 3325, 1422, 2568,
  1592, 2936,  788, 2372,  447, 2052, 3311,  365, 3680,  618, 2116, 2969,
  1440, 2527, 1354, 3149, 1648,  599, 2234, 3056, 1199, 3249, 2344,  906,
  2065, 1431, 2219, 4030,  411, 3284, 1882, 2415,  639, 3085,  162, 2258,
  1869, 3948,  100, 3642,  841, 2740, 1429, 2903, 1143, 3127, 2140, 1668,
  3180, 1808, 2378,   60, 1852, 4064, 1493,  176, 3204,  974, 2879, 1465,
  2491, 1032, 2789,  467, 3294, 1221, 3793, 1644, 3539, 1136, 2279, 1819,
  2409, 1581, 4038, 1017, 3591,  110, 3994,  745, 2109, 3670, 1453,  402,
  2656, 1909,  566, 3963,  334, 3582,  654, 1787, 2675, 1516,  111, 3368,
  2020, 1569, 2746, 3597,  530, 1654, 2836, 1402, 3326, 1071, 3772,  144,
  2404, 1962,  875, 3516,  198, 3808,  809, 3547, 2505,  497, 2804, 2210,
  1686, 3907,  678, 3469,  374, 3579, 1998, 3827,  903, 2446,  227, 2664,
   712, 2915,   96, 3854,  738, 3162,  217, 2704,  816, 2923, 1173, 2365,
  3012,  184, 2028, 3876, 1086, 3525, 1630, 2474, 3314, 1550, 2162, 3232,
  1025, 3860, 2111,  869, 4058,  437, 2076, 1334, 2191, 3486, 1123, 2497,
   313, 2962, 2181, 1700, 3877,  430, 2824, 1270, 2592, 1172, 2875, 2049,
  1131, 3063, 1337, 3658,  434, 1865, 2604, 1376, 2738, 1633,  118, 1811,
  3027, 1507, 3441, 1382, 4055, 1300, 3364, 1055, 2612, 1274, 3460, 2196,
  1627, 2056, 3538,  487, 1419, 3287, 2509,  664, 2742,  121, 3116,  853,
  1838,  534, 3768,  171, 2563,  569, 3109, 2336, 1191, 2587, 3741,  818,
  2940,  244, 2695,  722, 4068, 1935,  564, 3165,  826, 3374, 1625, 4045,
   709, 3443, 1781,  274, 3869,  754, 3387,  953, 2085, 3007,  220, 3239,
   612, 4027, 2178, 3220,  329, 2616,  646, 2846,  382, 2338, 1911, 3121,
   308, 2827, 1779,  539, 3750,  317, 2591, 1864, 3945,  884, 1699, 3412,
  1257, 3734, 1141, 2883, 3909, 2531, 1211, 2985, 1411, 3637, 1696,  279,
  3553, 1643,   25, 3303, 1817, 3917, 1016, 3275, 2265,  961, 3660, 1514,
  2058, 2512,   35, 2195, 2972,  474, 2305, 3308, 1442, 2610,   94, 2392,
  4001, 1277, 3562, 1113, 1975, 2556, 1314,  834, 3934, 1013, 3606, 2115,
  1789, 3729,  562, 1671, 3641, 1109, 3919, 2252, 1399, 3328,  850, 3086,
    29, 2811, 2149,  293, 2443, 1750, 2319,  260,  951, 1938, 3515,  740,
  2774,  941, 2039, 3008, 1100, 3138, 1907, 2358,  609, 1466, 2895, 1847,
    65, 2113, 2569,  262, 3046, 1294, 3623, 1033, 1711, 3722, 1509,  887,
  2759, 1064, 3218, 1927,  519, 2707,  821, 2293, 3402,  418, 3695, 2367,
  1427, 2894, 1681,   30, 2995, 1178, 2770, 2141,  700, 2498,   63, 3043,
   915, 2009, 2463, 1475, 3783, 1047, 3569, 1526, 4077,  507, 3444, 1999,
  3261,   56, 2225, 3192,  366, 2381, 3987,  783, 2752,  500, 3882,  972,
  3518, 2098,  417, 3791, 1602, 3427, 1241, 3990,  739, 3290,  524, 2032,
  2777,  139, 2459, 4017,  342, 3633, 2169, 1180, 3336, 1614, 3743,   57,
  1532, 2967, 1785,  170, 3498,  499, 2199, 3871,  848, 3396,  187, 3824,
  1461, 3281, 2035, 1542, 4065,  201, 3494,  584, 1813, 2715,  716, 2990,
  1357, 2858, 1067, 2606, 1463, 4044, 1611,  881, 3681, 1844,   90, 3221,
  1288, 2482, 1501, 2630,  190, 3160, 2410, 1302, 2670,  488, 2921, 1010,
  2798, 1380, 2427, 3937,  967, 3267, 1762,  684, 2889, 1830,  601, 3839,
   247, 2632, 1219, 2479, 3897,  731, 2267, 3145, 1120, 1961, 3260, 1250,
  2483, 1572, 2601,  970, 2902,  435, 3598,  677, 2222, 2844, 1117, 3184,
  2395,  338, 3341, 2122,   80, 2248, 3821,  390, 2918,  593, 2071, 3080,
  1223, 2868, 1451, 2179, 3804,  268, 3403, 1232, 4022, 1691,  766, 3577,
   934, 3853, 1729, 2315,  155, 3759, 1790,  319, 3019, 1353, 3535, 2070,
  1092, 3114, 1561, 2236, 3035,  892, 3269,  554, 1821, 2864, 1410,  630,
  4093, 2573,  764, 2751,  397, 4009,  603, 3526, 1743, 2375, 1078, 3098,
  1688,  523, 3717, 2083, 1194, 3969, 1638, 1005, 3648, 1829,  774, 2186,
   979, 3619, 2662,  226, 3926,  707, 3453,  462, 1759, 2683,  825, 2856,
   540, 2043, 2996,  125, 3190, 1893,  361, 3491, 1993, 1076, 3132, 2268,
   784, 2639,  258, 2366, 3767,   22, 3473,  463, 1956, 3940, 1488, 2137,
  3487,  264, 3653, 2421, 1725,  101, 3712, 1479, 3039, 1095, 3159, 2158,
   126, 3976, 1965,  287, 3856, 2627, 1840,  131, 3021,  780, 2538, 2938,
   547, 3144, 1558, 3489, 2460, 1823, 1049, 1959, 2311, 1578, 2515, 1916,
  3250, 1137, 3748, 1373, 2304, 3673, 1026, 2649, 1176, 2346, 3065,  830,
  2543, 3559,  636, 1673, 3409, 1258, 3968,  942, 1942, 2698, 1305, 2840,
   771, 2441,  133, 2930, 1044, 2724, 1606,  440, 3313, 2131,  900, 3421,
   234, 2406, 1932, 1328, 2794, 1227, 3191, 2524, 1347,  838, 3357, 1491,
  2256, 3605,  238, 1954, 4014, 1282, 2619,  141, 3382,  433, 3829, 2702,
   511, 3561,  150, 4095,  676, 2430,   40, 2957, 1807,  330, 3349, 1537,
  3930,  651, 1647, 4084, 1477,  398, 2398, 3892,   79, 2817, 1518, 3207,
   658, 2198, 4075, 1023, 3587, 1690, 3417, 1242, 3988,  793, 2061, 3818,
  1151, 2821, 1799, 2310, 1389, 3785,  489, 3476,  865, 3694,  725, 1635,
  3552, 2209,  450, 3901,  938, 1878, 3208,  899, 2386,  352, 3774, 2114,
  1312, 2931, 2095,  927, 3169, 1184, 2790, 1359, 3031, 1599, 3478, 1090,
  3833, 2251,  863, 2585,  253, 3399, 2152,   13, 3301, 2716, 1106, 1915,
  3078,  846, 2530,  311, 3685, 1600,  192, 3168, 2081,  359, 2663, 1971,
   480, 3099, 2549,  923, 3060,  296, 3962,  576, 3293, 2041, 2851, 1015,
  2643,  250, 2287, 3026,   15, 2813, 1286, 2026, 3068,  606, 2230, 3506,
  1377, 3102, 1719,  685
};

static inline double calculateError(double a, double b)
{
  return std::fabs(a - b);
}

static inline double calculateErrorSqr(double a, double b)
{
  return ((a - b) * (a - b));
}

static inline void limitValue(int& x, int min_, int max_)
{
  x = (x > min_ ? (x < max_ ? x : max_) : min_);
}

static inline void limitValue(double& x, double min_, double max_)
{
  if (!(x >= min_ && x <= max_)) {
    if (x < min_)
      x = min_;
    else if (x > max_)
      x = max_;
    else
      x = (min_ + max_) * 0.5;
  }
}

static bool ditherPixelValue(long xc, long yc, double n)
{
  return (n >= ((double(ditherTable[((yc & 63L) << 6)
                                    | (xc & 63L)]) + 0.5) / 4096.0));
}

// ----------------------------------------------------------------------------

class PRGData {
 private:
  static const unsigned char prgHeader_320x400[0x0401];
  static const unsigned char prgHeader_320x456[0x0401];
  static const unsigned char prgHeader_320x464[0x0401];
  static const unsigned char prgHeader_320x496[0x0401];
  unsigned char   *buf;
  int     *luminanceCodeTable;
  int     *colorCodeTable;
  bool    *bitmapTable;
  const unsigned char *prgHeader;
  int     nLines;
 public:
  PRGData();
  virtual ~PRGData();
  void clear();
  void convertImageData();
  void setVerticalSize(int n);
  inline unsigned char& operator[](long n)
  {
    return buf[n];
  }
  inline unsigned char& borderColor()
  {
    return buf[0x0500L];
  }
  inline unsigned char& interlaceDisabled()
  {
    return buf[0x0800L];
  }
  inline unsigned char& lineColor0(long yc)
  {
    return buf[(0x0400L | ((yc & 1L) << 8) | ((yc & (~(long(3)))) >> 1)) + 1L];
  }
  inline unsigned char& lineColor1(long yc)
  {
    return buf[(0x0400L | ((yc & 1L) << 8) | ((yc & (~(long(3)))) >> 1)) + 2L];
  }
  inline unsigned char& lineXShift(long yc)
  {
    return buf[(0x0600L | ((yc & 1L) << 8) | (yc >> 1)) + 1L];
  }
  inline bool getPixel(long xc, long yc) const
  {
    return bitmapTable[(yc * 320L) + xc];
  }
  inline void setPixel(long xc, long yc, bool n)
  {
    bitmapTable[(yc * 320L) + xc] = n;
  }
  inline int& l0(long xc, long yc)
  {
    return luminanceCodeTable[((yc & (~(long(2)))) * 40L) + (xc >> 3)];
  }
  inline int& l1(long xc, long yc)
  {
    return luminanceCodeTable[((yc | 2L) * 40L) + (xc >> 3)];
  }
  inline int& c0(long xc, long yc)
  {
    return colorCodeTable[((yc & (~(long(2)))) * 40L) + (xc >> 3)];
  }
  inline int& c1(long xc, long yc)
  {
    return colorCodeTable[((yc | 2L) * 40L) + (xc >> 3)];
  }
};

const unsigned char PRGData::prgHeader_320x400[0x0401] = {
  0x01, 0x10, 0x0C, 0x10, 0x0A, 0x00, 0x9E, 0x20, 0x34, 0x31, 0x31, 0x32,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0xD8, 0xA2, 0xFF, 0x9A, 0xA9, 0x76,
  0x8D, 0xFC, 0xFF, 0xA9, 0x10, 0x8D, 0xFD, 0xFF, 0x20, 0x80, 0x10, 0xA9,
  0x00, 0x8D, 0x15, 0xFF, 0x8D, 0x16, 0xFF, 0xA2, 0x00, 0xBD, 0xC8, 0x12,
  0x9D, 0x0A, 0xFF, 0xBD, 0xCA, 0x12, 0x9D, 0xFE, 0xFF, 0xE8, 0xE0, 0x02,
  0xD0, 0xEF, 0xAD, 0x09, 0xFF, 0x8D, 0x09, 0xFF, 0x8D, 0x3F, 0xFF, 0x58,
  0xA2, 0xFF, 0xA0, 0xFF, 0xA9, 0xCF, 0xCD, 0x1D, 0xFF, 0xD0, 0xFB, 0x98,
  0xAA, 0xA9, 0x7F, 0x8D, 0x30, 0xFD, 0x8D, 0x08, 0xFF, 0xAD, 0x08, 0xFF,
  0x29, 0x10, 0xA8, 0xE0, 0x10, 0xD0, 0xE5, 0xC0, 0x00, 0xD0, 0xE1, 0x78,
  0x8D, 0x3E, 0xFF, 0x8D, 0xD0, 0xFD, 0x6C, 0x74, 0x10, 0x10, 0x10, 0x78,
  0x8D, 0x3E, 0xFF, 0x8D, 0xD0, 0xFD, 0x6C, 0xFC, 0xFF, 0x78, 0x8D, 0x3E,
  0xFF, 0x20, 0xF0, 0x11, 0x20, 0x84, 0xFF, 0xA9, 0x0B, 0x8D, 0x06, 0xFF,
  0xAD, 0xFF, 0x14, 0x8D, 0x19, 0xFF, 0x2C, 0x07, 0xFF, 0x70, 0x08, 0xA9,
  0xA2, 0xA2, 0x01, 0xA0, 0xF9, 0xD0, 0x06, 0xA9, 0xA2, 0xA2, 0x01, 0xA0,
  0xE0, 0x8D, 0xC8, 0x12, 0x8E, 0xC9, 0x12, 0x8C, 0xCD, 0x12, 0xAD, 0x07,
  0xFF, 0x29, 0x40, 0x85, 0xE0, 0xA9, 0x00, 0xAA, 0x1D, 0x00, 0x16, 0x1D,
  0x00, 0x17, 0xE8, 0xE0, 0xC8, 0xD0, 0xF5, 0x29, 0x07, 0xC9, 0x01, 0xA9,
  0xFF, 0x69, 0x00, 0x29, 0x08, 0x05, 0xE0, 0x85, 0xE0, 0xA2, 0x00, 0xBD,
  0xFF, 0x15, 0x29, 0x17, 0x05, 0xE0, 0x9D, 0xFF, 0x15, 0xBD, 0xFF, 0x16,
  0x29, 0x17, 0x05, 0xE0, 0x9D, 0xFF, 0x16, 0xE8, 0xD0, 0xE9, 0xAD, 0xFF,
  0x17, 0xD0, 0x11, 0xA9, 0xA2, 0x8D, 0xCC, 0x12, 0xA9, 0xD0, 0x8D, 0xCE,
  0x12, 0xA9, 0x12, 0x8D, 0xCF, 0x12, 0xD0, 0x0B, 0xA2, 0x03, 0xBD, 0xC8,
  0x12, 0x9D, 0xCC, 0x12, 0xCA, 0x10, 0xF7, 0x8D, 0x3F, 0xFF, 0xA9, 0x00,
  0x20, 0x24, 0x11, 0xA9, 0x01, 0x20, 0x24, 0x11, 0x20, 0xF0, 0x11, 0xA9,
  0x3B, 0x8D, 0x06, 0xFF, 0x60, 0xAA, 0xD0, 0x03, 0xA0, 0xD0, 0x2C, 0xA0,
  0xDB, 0xA2, 0x0A, 0xB9, 0x00, 0x11, 0x95, 0xDE, 0x88, 0xCA, 0x10, 0xF7,
  0xA0, 0x00, 0x84, 0xDC, 0xA5, 0xDC, 0xF0, 0x0C, 0xC9, 0x64, 0xF0, 0x0E,
  0x20, 0xB8, 0x13, 0xE6, 0xDC, 0x4C, 0x3B, 0x11, 0x20, 0xD2, 0x13, 0x4C,
  0x46, 0x11, 0x20, 0x77, 0x13, 0x20, 0xC8, 0x13, 0xA9, 0x60, 0x4C, 0x30,
  0x13, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x98, 0xFF, 0x15, 0x00, 0x14, 0xE0, 0x11, 0xDC, 0x11, 0xE8, 0x00, 0xA6,
  0xFF, 0x16, 0x00, 0x15, 0xE8, 0x11, 0xDC, 0x11, 0xF0, 0x3B, 0x3D, 0x3F,
  0x39, 0x18, 0x60, 0x68, 0x70, 0x98, 0xA8, 0xB0, 0xB8, 0x78, 0x80, 0x88,
  0x90, 0xC8, 0xD0, 0xD8, 0xE0, 0x2C, 0x07, 0xFF, 0x70, 0x03, 0xA9, 0xFC,
  0x2C, 0xA9, 0xE3, 0xCD, 0x1D, 0xFF, 0xD0, 0xFB, 0x60, 0x48, 0x8A, 0x48,
  0x98, 0x48, 0xAD, 0x1D, 0xFF, 0xCD, 0x1D, 0xFF, 0xF0, 0xFB, 0xEA, 0xEA,
  0xAD, 0x1E, 0xFF, 0x29, 0x1C, 0x4A, 0x4A, 0x8D, 0x1A, 0x12, 0x10, 0x00,
  0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA5, 0xEA, 0xA5, 0xEA, 0xA2, 0xC8,
  0xE0, 0xD0, 0xF0, 0x08, 0x24, 0xEA, 0x20, 0x00, 0x98, 0x4C, 0x37, 0x12,
  0xEA, 0x20, 0x00, 0xA6, 0xAD, 0x26, 0x12, 0x29, 0x08, 0x09, 0xC0, 0x18,
  0x69, 0x08, 0x8D, 0x26, 0x12, 0x29, 0x10, 0xD0, 0x03, 0xA2, 0x00, 0x2C,
  0xA2, 0x04, 0xBD, 0xC8, 0x12, 0x8D, 0x0A, 0xFF, 0xBD, 0xC9, 0x12, 0x8D,
  0x0B, 0xFF, 0xBD, 0xCA, 0x12, 0x8D, 0xFE, 0xFF, 0xBD, 0xCB, 0x12, 0x8D,
  0xFF, 0xFF, 0xA9, 0xFF, 0x8D, 0x09, 0xFF, 0x68, 0xA8, 0x68, 0xAA, 0x68,
  0x40, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x01, 0x00, 0x12, 0xA2, 0xF9, 0xD0,
  0x12, 0x48, 0x8A, 0x48, 0x98, 0x48, 0xA2, 0x6D, 0xAD, 0x1D, 0xFF, 0xCD,
  0x1D, 0xFF, 0xF0, 0xFB, 0xAD, 0x1E, 0xFF, 0x29, 0x0E, 0x4A, 0x8D, 0xE9,
  0x12, 0x10, 0x00, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA5, 0xEA, 0x8E,
  0x1E, 0xFF, 0xA2, 0x64, 0xCA, 0xD0, 0xFD, 0x24, 0xEA, 0x24, 0xEA, 0xEA,
  0xA2, 0x00, 0xBD, 0xC8, 0x12, 0x9D, 0x0A, 0xFF, 0xBD, 0xCA, 0x12, 0x9D,
  0xFE, 0xFF, 0xE8, 0xE0, 0x02, 0xD0, 0xEF, 0xA9, 0xAD, 0x8D, 0x1E, 0xFF,
  0xA2, 0x05, 0xAD, 0x1D, 0xFF, 0xCD, 0x1D, 0xFF, 0xF0, 0xFB, 0xCA, 0xD0,
  0xF5, 0xCE, 0x1D, 0xFF, 0x4C, 0x65, 0x12, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0x91, 0xDE, 0xE6, 0xDE, 0xD0, 0x02, 0xE6, 0xDF, 0x60, 0x48, 0xA9,
  0xA9, 0x20, 0x30, 0x13, 0x68, 0x4C, 0x30, 0x13, 0x48, 0xA9, 0xA2, 0x4C,
  0x3C, 0x13, 0x48, 0xA9, 0x8D, 0x20, 0x30, 0x13, 0x68, 0x20, 0x30, 0x13,
  0xA9, 0xFF, 0x4C, 0x30, 0x13, 0x48, 0xA9, 0x8E, 0x4C, 0x4C, 0x13, 0x20,
  0x39, 0x13, 0x8A, 0x4C, 0x49, 0x13, 0xB1, 0xE0, 0xE6, 0xE0, 0xD0, 0x02,
  0xE6, 0xE1, 0x60, 0xB1, 0xE2, 0xE6, 0xE2, 0xD0, 0x02, 0xE6, 0xE3, 0x60,
  0xB1, 0xE6, 0xA2, 0x06, 0x20, 0x5E, 0x13, 0xA5, 0xE6, 0x29, 0x03, 0xA8,
  0xB1, 0xE4, 0xA0, 0x00, 0xA2, 0x14, 0x20, 0x5E, 0x13, 0xA5, 0xE6, 0x18,
  0x69, 0x01, 0x2C, 0x81, 0x13, 0xD0, 0x03, 0x38, 0xE9, 0x04, 0x85, 0xE6,
  0x20, 0x65, 0x13, 0xA2, 0x07, 0x4C, 0x5E, 0x13, 0xEA, 0xEA, 0x20, 0x6E,
  0x13, 0xA2, 0x15, 0x20, 0x5E, 0x13, 0x20, 0x6E, 0x13, 0xA2, 0x16, 0x20,
  0x5E, 0x13, 0x4C, 0x9B, 0x13, 0x20, 0x77, 0x13, 0xA9, 0xEA, 0x20, 0x30,
  0x13, 0xA9, 0xEA, 0x20, 0x30, 0x13, 0x20, 0xA5, 0x13, 0xA9, 0xEA, 0x20,
  0x30, 0x13, 0xA9, 0xEA, 0x4C, 0x30, 0x13, 0x20, 0x77, 0x13, 0xA9, 0x12,
  0x20, 0x58, 0x13, 0x4C, 0xC5, 0x13, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA
};

const unsigned char PRGData::prgHeader_320x456[0x0401] = {
  0x01, 0x10, 0x0C, 0x10, 0x0A, 0x00, 0x9E, 0x20, 0x34, 0x31, 0x31, 0x32,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0xD8, 0xA2, 0xFF, 0x9A, 0xA9, 0x76,
  0x8D, 0xFC, 0xFF, 0xA9, 0x10, 0x8D, 0xFD, 0xFF, 0x20, 0x80, 0x10, 0xA9,
  0x00, 0x8D, 0x15, 0xFF, 0x8D, 0x16, 0xFF, 0xA2, 0x00, 0xBD, 0xC8, 0x12,
  0x9D, 0x0A, 0xFF, 0xBD, 0xCA, 0x12, 0x9D, 0xFE, 0xFF, 0xE8, 0xE0, 0x02,
  0xD0, 0xEF, 0xAD, 0x09, 0xFF, 0x8D, 0x09, 0xFF, 0x8D, 0x3F, 0xFF, 0x58,
  0xA2, 0xFF, 0xA0, 0xFF, 0xA9, 0xDF, 0xCD, 0x1D, 0xFF, 0xD0, 0xFB, 0x98,
  0xAA, 0xA9, 0x7F, 0x8D, 0x30, 0xFD, 0x8D, 0x08, 0xFF, 0xAD, 0x08, 0xFF,
  0x29, 0x10, 0xA8, 0xE0, 0x10, 0xD0, 0xE5, 0xC0, 0x00, 0xD0, 0xE1, 0x78,
  0x8D, 0x3E, 0xFF, 0x8D, 0xD0, 0xFD, 0x6C, 0x74, 0x10, 0x10, 0x10, 0x78,
  0x8D, 0x3E, 0xFF, 0x8D, 0xD0, 0xFD, 0x6C, 0xFC, 0xFF, 0x78, 0x8D, 0x3E,
  0xFF, 0x20, 0xF0, 0x11, 0x20, 0x84, 0xFF, 0xA9, 0x0B, 0x8D, 0x06, 0xFF,
  0xAD, 0xFF, 0x14, 0x8D, 0x19, 0xFF, 0x2C, 0x07, 0xFF, 0x70, 0x08, 0xA9,
  0xA3, 0xA2, 0x27, 0xA0, 0xF9, 0xD0, 0x06, 0xA9, 0xA2, 0xA2, 0xF5, 0xA0,
  0xE0, 0x8D, 0xC8, 0x12, 0x8E, 0xC9, 0x12, 0x8C, 0xCD, 0x12, 0xAD, 0x07,
  0xFF, 0x29, 0x40, 0x85, 0xE0, 0xA9, 0x00, 0xAA, 0x1D, 0x00, 0x16, 0x1D,
  0x00, 0x17, 0xE8, 0xE0, 0xE4, 0xD0, 0xF5, 0x29, 0x07, 0xC9, 0x01, 0xA9,
  0xFF, 0x69, 0x00, 0x29, 0x08, 0x05, 0xE0, 0x85, 0xE0, 0xA2, 0x00, 0xBD,
  0xFF, 0x15, 0x29, 0x17, 0x05, 0xE0, 0x9D, 0xFF, 0x15, 0xBD, 0xFF, 0x16,
  0x29, 0x17, 0x05, 0xE0, 0x9D, 0xFF, 0x16, 0xE8, 0xD0, 0xE9, 0xAD, 0xFF,
  0x17, 0xD0, 0x11, 0xA9, 0xA2, 0x8D, 0xCC, 0x12, 0xA9, 0xD0, 0x8D, 0xCE,
  0x12, 0xA9, 0x12, 0x8D, 0xCF, 0x12, 0xD0, 0x0B, 0xA2, 0x03, 0xBD, 0xC8,
  0x12, 0x9D, 0xCC, 0x12, 0xCA, 0x10, 0xF7, 0x8D, 0x3F, 0xFF, 0xA9, 0x00,
  0x20, 0x24, 0x11, 0xA9, 0x01, 0x20, 0x24, 0x11, 0x20, 0xF0, 0x11, 0xA9,
  0x3B, 0x8D, 0x06, 0xFF, 0x60, 0xAA, 0xD0, 0x03, 0xA0, 0xD0, 0x2C, 0xA0,
  0xDB, 0xA2, 0x0A, 0xB9, 0x00, 0x11, 0x95, 0xDE, 0x88, 0xCA, 0x10, 0xF7,
  0xA0, 0x00, 0x84, 0xDC, 0xA9, 0x13, 0x85, 0xDD, 0xA5, 0xDC, 0xF0, 0x17,
  0xC9, 0x60, 0xF0, 0x19, 0xC9, 0x64, 0xF0, 0x1F, 0xC9, 0x71, 0xF0, 0x23,
  0x20, 0xB8, 0x13, 0xE6, 0xDC, 0xC6, 0xDD, 0xD0, 0xE7, 0xF0, 0x2A, 0x20,
  0xD2, 0x13, 0x4C, 0x52, 0x11, 0xA6, 0xE8, 0xA9, 0xA4, 0x20, 0xDD, 0x13,
  0x4C, 0x52, 0x11, 0xA5, 0xE4, 0x09, 0x04, 0x85, 0xE4, 0xD0, 0xE8, 0xA6,
  0xE8, 0xA9, 0xCA, 0x20, 0xDD, 0x13, 0x20, 0x77, 0x13, 0x20, 0xC8, 0x13,
  0xA9, 0x60, 0x4C, 0x30, 0x13, 0xC6, 0xDF, 0xA0, 0xED, 0xA9, 0x24, 0x91,
  0xDE, 0xA0, 0xFE, 0xA9, 0xEA, 0x91, 0xDE, 0xC8, 0xA9, 0x4C, 0x91, 0xDE,
  0xC8, 0xE6, 0xDF, 0xA9, 0x00, 0x91, 0xDE, 0xC8, 0xA5, 0xDF, 0x18, 0x69,
  0x02, 0x91, 0xDE, 0x85, 0xDF, 0xA0, 0x00, 0x84, 0xDE, 0x4C, 0x3B, 0x11,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xA9, 0xFF, 0x15, 0x00, 0x14, 0xE0, 0x11, 0xDC, 0x11, 0xE8, 0x00, 0xC9,
  0xFF, 0x16, 0x00, 0x15, 0xE8, 0x11, 0xDC, 0x11, 0xF0, 0x3B, 0x3D, 0x3F,
  0x39, 0x18, 0x60, 0x68, 0x70, 0x98, 0xA8, 0xB0, 0xB8, 0x78, 0x80, 0x88,
  0x90, 0xC8, 0xD0, 0xD8, 0xE0, 0x2C, 0x07, 0xFF, 0x70, 0x03, 0xA9, 0xFC,
  0x2C, 0xA9, 0xE3, 0xCD, 0x1D, 0xFF, 0xD0, 0xFB, 0x60, 0x48, 0x8A, 0x48,
  0x98, 0x48, 0xAE, 0x1C, 0xFF, 0xAC, 0x1D, 0xFF, 0xCC, 0x1D, 0xFF, 0xF0,
  0xFB, 0xAD, 0x1E, 0xFF, 0x29, 0x0E, 0x4A, 0x8D, 0x1A, 0x12, 0x10, 0x00,
  0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA5, 0xEA, 0x98, 0x18, 0x69, 0x0F,
  0xA8, 0x8A, 0x69, 0x00, 0x8C, 0x1D, 0xFF, 0x8D, 0x1C, 0xFF, 0xA2, 0x2D,
  0xCA, 0xD0, 0xFD, 0xAD, 0x1F, 0xFF, 0xA0, 0x18, 0xA2, 0x00, 0x8C, 0x1B,
  0xFF, 0x8E, 0x1A, 0xFF, 0x29, 0xFE, 0x8D, 0x1F, 0xFF, 0x09, 0x07, 0xEA,
  0xEA, 0xA2, 0x7F, 0xA0, 0xD1, 0x8E, 0x1E, 0xFF, 0xEA, 0xEA, 0xEA, 0xEA,
  0x8C, 0x1E, 0xFF, 0xA2, 0x03, 0xA0, 0x00, 0xCA, 0xD0, 0xFB, 0x8D, 0x1F,
  0xFF, 0xA0, 0x51, 0x8C, 0x1E, 0xFF, 0xA2, 0x07, 0xCA, 0xD0, 0xFD, 0xA9,
  0x00, 0xA9, 0x00, 0xEA, 0xA2, 0xC8, 0x8A, 0x0A, 0x0A, 0x69, 0x88, 0x8D,
  0x7F, 0x12, 0x20, 0x00, 0xA9, 0xAD, 0x74, 0x12, 0x29, 0x18, 0x49, 0xD8,
  0x8D, 0x74, 0x12, 0x29, 0x10, 0xD0, 0x03, 0xA2, 0x00, 0x2C, 0xA2, 0x04,
  0xBD, 0xC8, 0x12, 0x8D, 0x0A, 0xFF, 0xBD, 0xC9, 0x12, 0x8D, 0x0B, 0xFF,
  0xBD, 0xCA, 0x12, 0x8D, 0xFE, 0xFF, 0xBD, 0xCB, 0x12, 0x8D, 0xFF, 0xFF,
  0xA9, 0xCE, 0xCD, 0x1D, 0xFF, 0xD0, 0xFB, 0xA9, 0xDC, 0x8D, 0x1D, 0xFF,
  0xA9, 0xFF, 0x8D, 0x09, 0xFF, 0x68, 0xA8, 0x68, 0xAA, 0x68, 0x40, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xA3, 0x27, 0x00, 0x12, 0xA2, 0xF9, 0xD0,
  0x12, 0x48, 0x8A, 0x48, 0x98, 0x48, 0xA2, 0x6D, 0xAD, 0x1D, 0xFF, 0xCD,
  0x1D, 0xFF, 0xF0, 0xFB, 0xAD, 0x1E, 0xFF, 0x29, 0x0E, 0x4A, 0x8D, 0xE9,
  0x12, 0x10, 0x00, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA5, 0xEA, 0x8E,
  0x1E, 0xFF, 0xA2, 0x64, 0xCA, 0xD0, 0xFD, 0x24, 0xEA, 0x24, 0xEA, 0xEA,
  0xA2, 0x00, 0xBD, 0xC8, 0x12, 0x9D, 0x0A, 0xFF, 0xBD, 0xCA, 0x12, 0x9D,
  0xFE, 0xFF, 0xE8, 0xE0, 0x02, 0xD0, 0xEF, 0xA9, 0xAD, 0x8D, 0x1E, 0xFF,
  0xA2, 0x05, 0xAD, 0x1D, 0xFF, 0xCD, 0x1D, 0xFF, 0xF0, 0xFB, 0xCA, 0xD0,
  0xF5, 0xCE, 0x1D, 0xFF, 0x4C, 0xB7, 0x12, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0x91, 0xDE, 0xE6, 0xDE, 0xD0, 0x02, 0xE6, 0xDF, 0x60, 0x48, 0xA9,
  0xA9, 0x20, 0x30, 0x13, 0x68, 0x4C, 0x30, 0x13, 0x48, 0xA9, 0xA2, 0x4C,
  0x3C, 0x13, 0x48, 0xA9, 0x8D, 0x20, 0x30, 0x13, 0x68, 0x20, 0x30, 0x13,
  0xA9, 0xFF, 0x4C, 0x30, 0x13, 0x48, 0xA9, 0x8E, 0x4C, 0x4C, 0x13, 0x20,
  0x39, 0x13, 0x8A, 0x4C, 0x49, 0x13, 0xB1, 0xE0, 0xE6, 0xE0, 0xD0, 0x02,
  0xE6, 0xE1, 0x60, 0xB1, 0xE2, 0xE6, 0xE2, 0xD0, 0x02, 0xE6, 0xE3, 0x60,
  0xB1, 0xE6, 0xA2, 0x06, 0x20, 0x5E, 0x13, 0xA5, 0xE6, 0x29, 0x03, 0xA8,
  0xB1, 0xE4, 0xA0, 0x00, 0xA2, 0x14, 0x20, 0x5E, 0x13, 0xA5, 0xE6, 0x18,
  0x69, 0x01, 0x2C, 0x81, 0x13, 0xD0, 0x03, 0x38, 0xE9, 0x04, 0x85, 0xE6,
  0x20, 0x65, 0x13, 0xA2, 0x07, 0x4C, 0x5E, 0x13, 0xEA, 0xEA, 0x20, 0x6E,
  0x13, 0xA2, 0x15, 0x20, 0x5E, 0x13, 0x20, 0x6E, 0x13, 0xA2, 0x16, 0x20,
  0x5E, 0x13, 0x4C, 0x9B, 0x13, 0x20, 0x77, 0x13, 0xA9, 0xEA, 0x20, 0x30,
  0x13, 0xA9, 0xEA, 0x20, 0x30, 0x13, 0x20, 0xA5, 0x13, 0xA9, 0xEA, 0x20,
  0x30, 0x13, 0xA9, 0xEA, 0x4C, 0x30, 0x13, 0x20, 0x77, 0x13, 0xA9, 0x12,
  0x20, 0x58, 0x13, 0x4C, 0xC5, 0x13, 0x48, 0x8A, 0x48, 0x20, 0x77, 0x13,
  0xA9, 0xA2, 0x20, 0x30, 0x13, 0x68, 0x20, 0x30, 0x13, 0xA9, 0xA0, 0x20,
  0x30, 0x13, 0x68, 0x20, 0x30, 0x13, 0x20, 0xA5, 0x13, 0xA9, 0x1D, 0x48,
  0xA9, 0x8C, 0x4C, 0x4C, 0x13
};

const unsigned char PRGData::prgHeader_320x464[0x0401] = {
  0x01, 0x10, 0x0C, 0x10, 0x0A, 0x00, 0x9E, 0x20, 0x34, 0x31, 0x31, 0x32,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0xD8, 0xA2, 0xFF, 0x9A, 0xA9, 0x76,
  0x8D, 0xFC, 0xFF, 0xA9, 0x10, 0x8D, 0xFD, 0xFF, 0x20, 0x80, 0x10, 0xA9,
  0x00, 0x8D, 0x15, 0xFF, 0x8D, 0x16, 0xFF, 0xA2, 0x00, 0xBD, 0xC8, 0x12,
  0x9D, 0x0A, 0xFF, 0xBD, 0xCA, 0x12, 0x9D, 0xFE, 0xFF, 0xE8, 0xE0, 0x02,
  0xD0, 0xEF, 0xAD, 0x09, 0xFF, 0x8D, 0x09, 0xFF, 0x8D, 0x3F, 0xFF, 0x58,
  0xA2, 0xFF, 0xA0, 0xFF, 0xA9, 0xDF, 0xCD, 0x1D, 0xFF, 0xD0, 0xFB, 0x98,
  0xAA, 0xA9, 0x7F, 0x8D, 0x30, 0xFD, 0x8D, 0x08, 0xFF, 0xAD, 0x08, 0xFF,
  0x29, 0x10, 0xA8, 0xE0, 0x10, 0xD0, 0xE5, 0xC0, 0x00, 0xD0, 0xE1, 0x78,
  0x8D, 0x3E, 0xFF, 0x8D, 0xD0, 0xFD, 0x6C, 0x74, 0x10, 0x10, 0x10, 0x78,
  0x8D, 0x3E, 0xFF, 0x8D, 0xD0, 0xFD, 0x6C, 0xFC, 0xFF, 0x78, 0x8D, 0x3E,
  0xFF, 0x20, 0xF0, 0x11, 0x20, 0x84, 0xFF, 0xA9, 0x0B, 0x8D, 0x06, 0xFF,
  0xAD, 0xFF, 0x14, 0x8D, 0x19, 0xFF, 0x2C, 0x07, 0xFF, 0x70, 0x08, 0xA9,
  0xA3, 0xA2, 0x25, 0xA0, 0xF9, 0xD0, 0x06, 0xA9, 0xA2, 0xA2, 0xF3, 0xA0,
  0xE0, 0x8D, 0xC8, 0x12, 0x8E, 0xC9, 0x12, 0x8C, 0xCD, 0x12, 0xAD, 0x07,
  0xFF, 0x29, 0x40, 0x85, 0xE0, 0xA9, 0x00, 0xAA, 0x1D, 0x00, 0x16, 0x1D,
  0x00, 0x17, 0xE8, 0xE0, 0xE8, 0xD0, 0xF5, 0x29, 0x07, 0xC9, 0x01, 0xA9,
  0xFF, 0x69, 0x00, 0x29, 0x08, 0x05, 0xE0, 0x85, 0xE0, 0xA2, 0x00, 0xBD,
  0xFF, 0x15, 0x29, 0x17, 0x05, 0xE0, 0x9D, 0xFF, 0x15, 0xBD, 0xFF, 0x16,
  0x29, 0x17, 0x05, 0xE0, 0x9D, 0xFF, 0x16, 0xE8, 0xD0, 0xE9, 0xAD, 0xFF,
  0x17, 0xD0, 0x11, 0xA9, 0xA2, 0x8D, 0xCC, 0x12, 0xA9, 0xD0, 0x8D, 0xCE,
  0x12, 0xA9, 0x12, 0x8D, 0xCF, 0x12, 0xD0, 0x0B, 0xA2, 0x03, 0xBD, 0xC8,
  0x12, 0x9D, 0xCC, 0x12, 0xCA, 0x10, 0xF7, 0x8D, 0x3F, 0xFF, 0xA9, 0x00,
  0x20, 0x24, 0x11, 0xA9, 0x01, 0x20, 0x24, 0x11, 0x20, 0xF0, 0x11, 0xA9,
  0x3B, 0x8D, 0x06, 0xFF, 0x60, 0xAA, 0xD0, 0x03, 0xA0, 0xD0, 0x2C, 0xA0,
  0xDB, 0xA2, 0x0A, 0xB9, 0x00, 0x11, 0x95, 0xDE, 0x88, 0xCA, 0x10, 0xF7,
  0xA0, 0x00, 0x84, 0xDC, 0xA9, 0x15, 0x85, 0xDD, 0xA5, 0xDC, 0xF0, 0x17,
  0xC9, 0x60, 0xF0, 0x19, 0xC9, 0x64, 0xF0, 0x1F, 0xC9, 0x73, 0xF0, 0x23,
  0x20, 0xB8, 0x13, 0xE6, 0xDC, 0xC6, 0xDD, 0xD0, 0xE7, 0xF0, 0x2A, 0x20,
  0xD2, 0x13, 0x4C, 0x52, 0x11, 0xA6, 0xE8, 0xA9, 0xA4, 0x20, 0xDD, 0x13,
  0x4C, 0x52, 0x11, 0xA5, 0xE4, 0x09, 0x04, 0x85, 0xE4, 0xD0, 0xE8, 0xA6,
  0xE8, 0xA9, 0xCA, 0x20, 0xDD, 0x13, 0x20, 0x77, 0x13, 0x20, 0xC8, 0x13,
  0xA9, 0x60, 0x4C, 0x30, 0x13, 0xC6, 0xDF, 0xA0, 0xED, 0xA9, 0x24, 0x91,
  0xDE, 0xA0, 0xFE, 0xA9, 0xEA, 0x91, 0xDE, 0xC8, 0xA9, 0x4C, 0x91, 0xDE,
  0xC8, 0xE6, 0xDF, 0xA9, 0x00, 0x91, 0xDE, 0xC8, 0xA5, 0xDF, 0x18, 0x69,
  0x02, 0x91, 0xDE, 0x85, 0xDF, 0xA0, 0x00, 0x84, 0xDE, 0x4C, 0x3B, 0x11,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xA9, 0xFF, 0x15, 0x00, 0x14, 0xE0, 0x11, 0xDC, 0x11, 0xE8, 0x00, 0xC9,
  0xFF, 0x16, 0x00, 0x15, 0xE8, 0x11, 0xDC, 0x11, 0xF0, 0x3B, 0x3D, 0x3F,
  0x39, 0x18, 0x60, 0x68, 0x70, 0x98, 0xA8, 0xB0, 0xB8, 0x78, 0x80, 0x88,
  0x90, 0xC8, 0xD0, 0xD8, 0xE0, 0x2C, 0x07, 0xFF, 0x70, 0x03, 0xA9, 0xFC,
  0x2C, 0xA9, 0xE3, 0xCD, 0x1D, 0xFF, 0xD0, 0xFB, 0x60, 0x48, 0x8A, 0x48,
  0x98, 0x48, 0xAE, 0x1C, 0xFF, 0xAC, 0x1D, 0xFF, 0xCC, 0x1D, 0xFF, 0xF0,
  0xFB, 0xAD, 0x1E, 0xFF, 0x29, 0x0E, 0x4A, 0x8D, 0x1A, 0x12, 0x10, 0x00,
  0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA5, 0xEA, 0x98, 0x18, 0x69, 0x11,
  0xA8, 0x8A, 0x69, 0x00, 0x8C, 0x1D, 0xFF, 0x8D, 0x1C, 0xFF, 0xA2, 0x2D,
  0xCA, 0xD0, 0xFD, 0xAD, 0x1F, 0xFF, 0xA0, 0x18, 0xA2, 0x00, 0x8C, 0x1B,
  0xFF, 0x8E, 0x1A, 0xFF, 0x29, 0xFE, 0x8D, 0x1F, 0xFF, 0x09, 0x07, 0xEA,
  0xEA, 0xA2, 0x7F, 0xA0, 0xD1, 0x8E, 0x1E, 0xFF, 0xEA, 0xEA, 0xEA, 0xEA,
  0x8C, 0x1E, 0xFF, 0xA2, 0x03, 0xA0, 0x00, 0xCA, 0xD0, 0xFB, 0x8D, 0x1F,
  0xFF, 0xA0, 0x51, 0x8C, 0x1E, 0xFF, 0xA2, 0x07, 0xCA, 0xD0, 0xFD, 0xA9,
  0x00, 0xA9, 0x00, 0xEA, 0xA2, 0xC8, 0x8A, 0x0A, 0x0A, 0x69, 0x88, 0x8D,
  0x7F, 0x12, 0x20, 0x00, 0xA9, 0xAD, 0x74, 0x12, 0x29, 0x18, 0x49, 0xD8,
  0x8D, 0x74, 0x12, 0x29, 0x10, 0xD0, 0x03, 0xA2, 0x00, 0x2C, 0xA2, 0x04,
  0xBD, 0xC8, 0x12, 0x8D, 0x0A, 0xFF, 0xBD, 0xC9, 0x12, 0x8D, 0x0B, 0xFF,
  0xBD, 0xCA, 0x12, 0x8D, 0xFE, 0xFF, 0xBD, 0xCB, 0x12, 0x8D, 0xFF, 0xFF,
  0xA9, 0xCE, 0xCD, 0x1D, 0xFF, 0xD0, 0xFB, 0xA9, 0xDE, 0x8D, 0x1D, 0xFF,
  0xA9, 0xFF, 0x8D, 0x09, 0xFF, 0x68, 0xA8, 0x68, 0xAA, 0x68, 0x40, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xA3, 0x25, 0x00, 0x12, 0xA2, 0xF9, 0xD0,
  0x12, 0x48, 0x8A, 0x48, 0x98, 0x48, 0xA2, 0x6D, 0xAD, 0x1D, 0xFF, 0xCD,
  0x1D, 0xFF, 0xF0, 0xFB, 0xAD, 0x1E, 0xFF, 0x29, 0x0E, 0x4A, 0x8D, 0xE9,
  0x12, 0x10, 0x00, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA5, 0xEA, 0x8E,
  0x1E, 0xFF, 0xA2, 0x64, 0xCA, 0xD0, 0xFD, 0x24, 0xEA, 0x24, 0xEA, 0xEA,
  0xA2, 0x00, 0xBD, 0xC8, 0x12, 0x9D, 0x0A, 0xFF, 0xBD, 0xCA, 0x12, 0x9D,
  0xFE, 0xFF, 0xE8, 0xE0, 0x02, 0xD0, 0xEF, 0xA9, 0xAD, 0x8D, 0x1E, 0xFF,
  0xA2, 0x05, 0xAD, 0x1D, 0xFF, 0xCD, 0x1D, 0xFF, 0xF0, 0xFB, 0xCA, 0xD0,
  0xF5, 0xCE, 0x1D, 0xFF, 0x4C, 0xB7, 0x12, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0x91, 0xDE, 0xE6, 0xDE, 0xD0, 0x02, 0xE6, 0xDF, 0x60, 0x48, 0xA9,
  0xA9, 0x20, 0x30, 0x13, 0x68, 0x4C, 0x30, 0x13, 0x48, 0xA9, 0xA2, 0x4C,
  0x3C, 0x13, 0x48, 0xA9, 0x8D, 0x20, 0x30, 0x13, 0x68, 0x20, 0x30, 0x13,
  0xA9, 0xFF, 0x4C, 0x30, 0x13, 0x48, 0xA9, 0x8E, 0x4C, 0x4C, 0x13, 0x20,
  0x39, 0x13, 0x8A, 0x4C, 0x49, 0x13, 0xB1, 0xE0, 0xE6, 0xE0, 0xD0, 0x02,
  0xE6, 0xE1, 0x60, 0xB1, 0xE2, 0xE6, 0xE2, 0xD0, 0x02, 0xE6, 0xE3, 0x60,
  0xB1, 0xE6, 0xA2, 0x06, 0x20, 0x5E, 0x13, 0xA5, 0xE6, 0x29, 0x03, 0xA8,
  0xB1, 0xE4, 0xA0, 0x00, 0xA2, 0x14, 0x20, 0x5E, 0x13, 0xA5, 0xE6, 0x18,
  0x69, 0x01, 0x2C, 0x81, 0x13, 0xD0, 0x03, 0x38, 0xE9, 0x04, 0x85, 0xE6,
  0x20, 0x65, 0x13, 0xA2, 0x07, 0x4C, 0x5E, 0x13, 0xEA, 0xEA, 0x20, 0x6E,
  0x13, 0xA2, 0x15, 0x20, 0x5E, 0x13, 0x20, 0x6E, 0x13, 0xA2, 0x16, 0x20,
  0x5E, 0x13, 0x4C, 0x9B, 0x13, 0x20, 0x77, 0x13, 0xA9, 0xEA, 0x20, 0x30,
  0x13, 0xA9, 0xEA, 0x20, 0x30, 0x13, 0x20, 0xA5, 0x13, 0xA9, 0xEA, 0x20,
  0x30, 0x13, 0xA9, 0xEA, 0x4C, 0x30, 0x13, 0x20, 0x77, 0x13, 0xA9, 0x12,
  0x20, 0x58, 0x13, 0x4C, 0xC5, 0x13, 0x48, 0x8A, 0x48, 0x20, 0x77, 0x13,
  0xA9, 0xA2, 0x20, 0x30, 0x13, 0x68, 0x20, 0x30, 0x13, 0xA9, 0xA0, 0x20,
  0x30, 0x13, 0x68, 0x20, 0x30, 0x13, 0x20, 0xA5, 0x13, 0xA9, 0x1D, 0x48,
  0xA9, 0x8C, 0x4C, 0x4C, 0x13
};

const unsigned char PRGData::prgHeader_320x496[0x0401] = {
  0x01, 0x10, 0x0C, 0x10, 0x0A, 0x00, 0x9E, 0x20, 0x34, 0x31, 0x31, 0x32,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0xD8, 0xA2, 0xFF, 0x9A, 0xA9, 0x76,
  0x8D, 0xFC, 0xFF, 0xA9, 0x10, 0x8D, 0xFD, 0xFF, 0x20, 0x80, 0x10, 0xA9,
  0x00, 0x8D, 0x15, 0xFF, 0x8D, 0x16, 0xFF, 0xA2, 0x00, 0xBD, 0xC8, 0x12,
  0x9D, 0x0A, 0xFF, 0xBD, 0xCA, 0x12, 0x9D, 0xFE, 0xFF, 0xE8, 0xE0, 0x02,
  0xD0, 0xEF, 0xAD, 0x09, 0xFF, 0x8D, 0x09, 0xFF, 0x8D, 0x3F, 0xFF, 0x58,
  0xA2, 0xFF, 0xA0, 0xFF, 0xA9, 0xE9, 0xCD, 0x1D, 0xFF, 0xD0, 0xFB, 0x98,
  0xAA, 0xA9, 0x7F, 0x8D, 0x30, 0xFD, 0x8D, 0x08, 0xFF, 0xAD, 0x08, 0xFF,
  0x29, 0x10, 0xA8, 0xE0, 0x10, 0xD0, 0xE5, 0xC0, 0x00, 0xD0, 0xE1, 0x78,
  0x8D, 0x3E, 0xFF, 0x8D, 0xD0, 0xFD, 0x6C, 0x74, 0x10, 0x10, 0x10, 0x78,
  0x8D, 0x3E, 0xFF, 0x8D, 0xD0, 0xFD, 0x6C, 0xFC, 0xFF, 0x78, 0x8D, 0x3E,
  0xFF, 0x20, 0xF0, 0x11, 0x20, 0x84, 0xFF, 0xA9, 0x0B, 0x8D, 0x06, 0xFF,
  0xAD, 0xFF, 0x14, 0x8D, 0x19, 0xFF, 0x2C, 0x07, 0xFF, 0x70, 0xDC, 0xA9,
  0xA3, 0xA2, 0x1F, 0xA0, 0xF9, 0xD0, 0x06, 0xA9, 0xA3, 0xA2, 0x1F, 0xA0,
  0xF9, 0x8D, 0xC8, 0x12, 0x8E, 0xC9, 0x12, 0x8C, 0xCD, 0x12, 0xAD, 0x07,
  0xFF, 0x29, 0x40, 0x85, 0xE0, 0xA9, 0x00, 0xAA, 0x1D, 0x00, 0x16, 0x1D,
  0x00, 0x17, 0xE8, 0xE0, 0xF8, 0xD0, 0xF5, 0x29, 0x07, 0xC9, 0x01, 0xA9,
  0xFF, 0x69, 0x00, 0x29, 0x08, 0x05, 0xE0, 0x85, 0xE0, 0xA2, 0x00, 0xBD,
  0xFF, 0x15, 0x29, 0x17, 0x05, 0xE0, 0x9D, 0xFF, 0x15, 0xBD, 0xFF, 0x16,
  0x29, 0x17, 0x05, 0xE0, 0x9D, 0xFF, 0x16, 0xE8, 0xD0, 0xE9, 0xAD, 0xFF,
  0x17, 0xD0, 0x11, 0xA9, 0xA2, 0x8D, 0xCC, 0x12, 0xA9, 0xD0, 0x8D, 0xCE,
  0x12, 0xA9, 0x12, 0x8D, 0xCF, 0x12, 0xD0, 0x0B, 0xA2, 0x03, 0xBD, 0xC8,
  0x12, 0x9D, 0xCC, 0x12, 0xCA, 0x10, 0xF7, 0x8D, 0x3F, 0xFF, 0xA9, 0x00,
  0x20, 0x24, 0x11, 0xA9, 0x01, 0x20, 0x24, 0x11, 0x20, 0xF0, 0x11, 0xA9,
  0x3B, 0x8D, 0x06, 0xFF, 0x60, 0xAA, 0xD0, 0x03, 0xA0, 0xD0, 0x2C, 0xA0,
  0xDB, 0xA2, 0x0A, 0xB9, 0x00, 0x11, 0x95, 0xDE, 0x88, 0xCA, 0x10, 0xF7,
  0xA0, 0x00, 0x84, 0xDC, 0xA9, 0x16, 0x85, 0xDD, 0xA5, 0xDC, 0xF0, 0x17,
  0xC9, 0x60, 0xF0, 0x19, 0xC9, 0x64, 0xF0, 0x1F, 0xC9, 0x7B, 0xF0, 0x23,
  0x20, 0xB8, 0x13, 0xE6, 0xDC, 0xC6, 0xDD, 0xD0, 0xE7, 0xF0, 0x2A, 0x20,
  0xD2, 0x13, 0x4C, 0x52, 0x11, 0xA6, 0xE8, 0xA9, 0x94, 0x20, 0xDD, 0x13,
  0x4C, 0x52, 0x11, 0xA5, 0xE4, 0x09, 0x04, 0x85, 0xE4, 0xD0, 0xE8, 0xA6,
  0xE8, 0xA9, 0xCA, 0x20, 0xDD, 0x13, 0x20, 0x77, 0x13, 0x20, 0xC8, 0x13,
  0xA9, 0x60, 0x4C, 0x30, 0x13, 0xC6, 0xDF, 0xA0, 0xED, 0xA9, 0x24, 0x91,
  0xDE, 0xA0, 0xFE, 0xA9, 0xEA, 0x91, 0xDE, 0xC8, 0xA9, 0x4C, 0x91, 0xDE,
  0xC8, 0xE6, 0xDF, 0xA9, 0x00, 0x91, 0xDE, 0xC8, 0xA5, 0xDF, 0x18, 0x69,
  0x02, 0x91, 0xDE, 0x85, 0xDF, 0xA0, 0x00, 0x84, 0xDE, 0x4C, 0x3B, 0x11,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xA9, 0xFF, 0x15, 0x00, 0x14, 0xE0, 0x11, 0xDC, 0x11, 0xE8, 0x00, 0xC9,
  0xFF, 0x16, 0x00, 0x15, 0xE8, 0x11, 0xDC, 0x11, 0xF0, 0x3B, 0x3D, 0x3F,
  0x39, 0x18, 0x60, 0x68, 0x70, 0x98, 0xA8, 0xB0, 0xB8, 0x78, 0x80, 0x88,
  0x90, 0xC8, 0xD0, 0xD8, 0xE0, 0x2C, 0x07, 0xFF, 0x70, 0x03, 0xA9, 0xFC,
  0x2C, 0xA9, 0xE3, 0xCD, 0x1D, 0xFF, 0xD0, 0xFB, 0x60, 0x48, 0x8A, 0x48,
  0x98, 0x48, 0xAE, 0x1C, 0xFF, 0xAC, 0x1D, 0xFF, 0xCC, 0x1D, 0xFF, 0xF0,
  0xFB, 0xAD, 0x1E, 0xFF, 0x29, 0x0E, 0x4A, 0x8D, 0x1A, 0x12, 0x10, 0x00,
  0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA5, 0xEA, 0x98, 0x18, 0x69, 0x17,
  0xA8, 0x8A, 0x69, 0x00, 0x8C, 0x1D, 0xFF, 0x8D, 0x1C, 0xFF, 0xA2, 0x2D,
  0xCA, 0xD0, 0xFD, 0xAD, 0x1F, 0xFF, 0xA0, 0x18, 0xA2, 0x00, 0x8C, 0x1B,
  0xFF, 0x8E, 0x1A, 0xFF, 0x29, 0xFE, 0x8D, 0x1F, 0xFF, 0x09, 0x07, 0xEA,
  0xEA, 0xA2, 0x7F, 0xA0, 0xD1, 0x8E, 0x1E, 0xFF, 0xEA, 0xEA, 0xEA, 0xEA,
  0x8C, 0x1E, 0xFF, 0xA2, 0x03, 0xA0, 0x00, 0xCA, 0xD0, 0xFB, 0x8D, 0x1F,
  0xFF, 0xA0, 0x51, 0x8C, 0x1E, 0xFF, 0xA2, 0x07, 0xCA, 0xD0, 0xFD, 0xA9,
  0x00, 0xA9, 0x00, 0xEA, 0xA2, 0xC8, 0x8A, 0x0A, 0x0A, 0x69, 0x88, 0x8D,
  0x7F, 0x12, 0x20, 0x00, 0xA9, 0xAD, 0x74, 0x12, 0x29, 0x18, 0x49, 0xD8,
  0x8D, 0x74, 0x12, 0x29, 0x10, 0xD0, 0x03, 0xA2, 0x00, 0x2C, 0xA2, 0x04,
  0xBD, 0xC8, 0x12, 0x8D, 0x0A, 0xFF, 0xBD, 0xC9, 0x12, 0x8D, 0x0B, 0xFF,
  0xBD, 0xCA, 0x12, 0x8D, 0xFE, 0xFF, 0xBD, 0xCB, 0x12, 0x8D, 0xFF, 0xFF,
  0xA9, 0xCE, 0xCD, 0x1D, 0xFF, 0xD0, 0xFB, 0xA9, 0xE8, 0x8D, 0x1D, 0xFF,
  0xA9, 0xFF, 0x8D, 0x09, 0xFF, 0x68, 0xA8, 0x68, 0xAA, 0x68, 0x40, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xA3, 0x1F, 0x00, 0x12, 0xA2, 0xF9, 0xD0,
  0x12, 0x48, 0x8A, 0x48, 0x98, 0x48, 0xA2, 0x6D, 0xAD, 0x1D, 0xFF, 0xCD,
  0x1D, 0xFF, 0xF0, 0xFB, 0xAD, 0x1E, 0xFF, 0x29, 0x0E, 0x4A, 0x8D, 0xE9,
  0x12, 0x10, 0x00, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA5, 0xEA, 0x8E,
  0x1E, 0xFF, 0xA2, 0x64, 0xCA, 0xD0, 0xFD, 0x24, 0xEA, 0x24, 0xEA, 0xEA,
  0xA2, 0x00, 0xBD, 0xC8, 0x12, 0x9D, 0x0A, 0xFF, 0xBD, 0xCA, 0x12, 0x9D,
  0xFE, 0xFF, 0xE8, 0xE0, 0x02, 0xD0, 0xEF, 0xA9, 0xAD, 0x8D, 0x1E, 0xFF,
  0xA2, 0x05, 0xAD, 0x1D, 0xFF, 0xCD, 0x1D, 0xFF, 0xF0, 0xFB, 0xCA, 0xD0,
  0xF5, 0xCE, 0x1D, 0xFF, 0x4C, 0xB7, 0x12, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0x91, 0xDE, 0xE6, 0xDE, 0xD0, 0x02, 0xE6, 0xDF, 0x60, 0x48, 0xA9,
  0xA9, 0x20, 0x30, 0x13, 0x68, 0x4C, 0x30, 0x13, 0x48, 0xA9, 0xA2, 0x4C,
  0x3C, 0x13, 0x48, 0xA9, 0x8D, 0x20, 0x30, 0x13, 0x68, 0x20, 0x30, 0x13,
  0xA9, 0xFF, 0x4C, 0x30, 0x13, 0x48, 0xA9, 0x8E, 0x4C, 0x4C, 0x13, 0x20,
  0x39, 0x13, 0x8A, 0x4C, 0x49, 0x13, 0xB1, 0xE0, 0xE6, 0xE0, 0xD0, 0x02,
  0xE6, 0xE1, 0x60, 0xB1, 0xE2, 0xE6, 0xE2, 0xD0, 0x02, 0xE6, 0xE3, 0x60,
  0xB1, 0xE6, 0xA2, 0x06, 0x20, 0x5E, 0x13, 0xA5, 0xE6, 0x29, 0x03, 0xA8,
  0xB1, 0xE4, 0xA0, 0x00, 0xA2, 0x14, 0x20, 0x5E, 0x13, 0xA5, 0xE6, 0x18,
  0x69, 0x01, 0x2C, 0x81, 0x13, 0xD0, 0x03, 0x38, 0xE9, 0x04, 0x85, 0xE6,
  0x20, 0x65, 0x13, 0xA2, 0x07, 0x4C, 0x5E, 0x13, 0xEA, 0xEA, 0x20, 0x6E,
  0x13, 0xA2, 0x15, 0x20, 0x5E, 0x13, 0x20, 0x6E, 0x13, 0xA2, 0x16, 0x20,
  0x5E, 0x13, 0x4C, 0x9B, 0x13, 0x20, 0x77, 0x13, 0xA9, 0xEA, 0x20, 0x30,
  0x13, 0xA9, 0xEA, 0x20, 0x30, 0x13, 0x20, 0xA5, 0x13, 0xA9, 0xEA, 0x20,
  0x30, 0x13, 0xA9, 0xEA, 0x4C, 0x30, 0x13, 0x20, 0x77, 0x13, 0xA9, 0x12,
  0x20, 0x58, 0x13, 0x4C, 0xC5, 0x13, 0x48, 0x8A, 0x48, 0x20, 0x77, 0x13,
  0xA9, 0xA2, 0x20, 0x30, 0x13, 0x68, 0x20, 0x30, 0x13, 0xA9, 0xA0, 0x20,
  0x30, 0x13, 0x68, 0x20, 0x30, 0x13, 0x20, 0xA5, 0x13, 0xA9, 0x1D, 0x48,
  0xA9, 0x8C, 0x4C, 0x4C, 0x13
};

PRGData::PRGData()
  : buf((unsigned char *) 0),
    luminanceCodeTable((int *) 0),
    colorCodeTable((int *) 0),
    bitmapTable((bool *) 0),
    prgHeader(&(prgHeader_320x464[0])),
    nLines(464)
{
  try {
    buf = new unsigned char[0xD501];
    luminanceCodeTable = new int[40 * 496];
    colorCodeTable = new int[40 * 496];
    bitmapTable = new bool[320 * 496];
    this->clear();
  }
  catch (...) {
    if (buf)
      delete[] buf;
    if (luminanceCodeTable)
      delete[] luminanceCodeTable;
    if (colorCodeTable)
      delete[] colorCodeTable;
    if (bitmapTable)
      delete[] bitmapTable;
    throw;
  }
}

PRGData::~PRGData()
{
  delete[] buf;
  delete[] luminanceCodeTable;
  delete[] colorCodeTable;
  delete[] bitmapTable;
}

void PRGData::clear()
{
  for (size_t i = 0x0000; i < 0x0401; i++)
    buf[i] = prgHeader[i];
  for (size_t i = 0x0401; i < 0xD501; i++)
    buf[i] = 0x00;
  for (size_t i = 0; i < (40 * 496); i++) {
    luminanceCodeTable[i] = 0;
    colorCodeTable[i] = 0;
  }
  for (size_t i = 0; i < (320 * 496); i++)
    bitmapTable[i] = false;
}

void PRGData::convertImageData()
{
  for (size_t i = 0x0801; i < 0xD501; i++)
    buf[i] = 0x00;
  int     offs = (nLines > 400 ? 24 : 0);
  for (int yc = 0; yc < 496; yc++) {
    if (yc & 2)
      continue;
    for (int xc = 0; xc < 320; xc += 8) {
      int     l0_ = this->l0(xc, yc);
      int     l1_ = this->l1(xc, yc);
      int     c0_ = this->c0(xc, yc);
      int     c1_ = this->c1(xc, yc);
      if (l0_ == 0)
        c0_ = 0;
      else
        l0_--;
      if (l1_ == 0)
        c1_ = 0;
      else
        l1_--;
      unsigned char lCode = (unsigned char) (((l0_ & 7) << 4) | (l1_ & 7));
      unsigned char cCode = (unsigned char) ((c0_ & 15) | ((c1_ & 15) << 4));
      int     addr = ((yc >> 4) * 40) + (xc >> 3) + offs;
      if (addr >= 0x0400)
        addr = (addr - 0x0400) + 0x4000;
      if (yc & 1)
        addr = addr + 0x2000;
      addr = addr + ((yc & 12) << 9);
      if (addr < 0x0800)
        addr = addr + 0x1800;
      else if (addr < 0x4800)
        addr = addr + 0x5800;
      else if (addr < 0x6000)
        addr = addr + 0x6000;
      else
        addr = addr + 0x6800;
      addr = addr - 0x0FFF;
      buf[addr] = lCode;
      buf[addr + 0x0400] = cCode;
    }
  }
  for (int yc = 0; yc < 496; yc++) {
    for (int xc = 0; xc < 320; xc++) {
      bool    b = this->getPixel(xc, yc);
      int     addr = ((((yc >> 4) * 40) + (xc >> 3) + offs) << 3)
                     + ((yc & 14) >> 1);
      if (addr >= 0x2000)
        addr = (addr - 0x2000) + 0x4000;
      if (yc & 1)
        addr = addr + 0x2000;
      if (addr < 0x4000)
        addr = addr + 0x2000;
      else
        addr = addr + 0x6000;
      addr = addr - 0x0FFF;
      buf[addr] = buf[addr] | (unsigned char) (int(b) << (7 - (xc & 7)));
    }
  }
}

void PRGData::setVerticalSize(int n)
{
  if (n < 400) {
    n = n << 1;
    interlaceDisabled() = 0x01;
  }
  else
    interlaceDisabled() = 0x00;
  if (n <= 400) {
    prgHeader = &(prgHeader_320x400[0]);
    nLines = 400;
  }
  else if (n <= 456) {
    prgHeader = &(prgHeader_320x456[0]);
    nLines = 456;
  }
  else if (n <= 464) {
    prgHeader = &(prgHeader_320x464[0]);
    nLines = 464;
  }
  else {
    prgHeader = &(prgHeader_320x496[0]);
    nLines = 496;
  }
  for (size_t i = 0x0000; i < 0x0401; i++)
    buf[i] = prgHeader[i];
}

// ----------------------------------------------------------------------------

class Line320 {
 private:
  float   *buf;
  int     xShift;
  bool    multiColorFlag;
 public:
  Line320();
  Line320(const Line320& r);
  virtual ~Line320();
  Line320& operator=(const Line320& r);
  void clear();
  void setBorderColor(float c);
  inline float& operator[](long n)
  {
    return buf[n + 16L];
  }
  inline float& pixel(long x)
  {
    return buf[x + 16L];
  }
  inline float& pixelShifted(long x)
  {
    return buf[x + 16L + xShift];
  }
  inline float getPixel(long x) const
  {
    return buf[x + 16L];
  }
  inline float getPixelShifted(long x) const
  {
    return buf[x + 16L + xShift];
  }
  inline void setPixel(long x, float n)
  {
    if (x >= 0L && x < 320L)
      buf[x + 16L] = n;
  }
  inline void setPixelShifted(long x, float n)
  {
    long    x_ = x + xShift;
    if (x_ >= 0L && x_ < 320L)
      buf[x_ + 16L] = n;
  }
  inline int getXShift() const
  {
    return xShift;
  }
  inline void setXShift(int n)
  {
    xShift = n & 7;
  }
  inline bool getMultiColorFlag() const
  {
    return multiColorFlag;
  }
  inline void setMultiColorFlag(bool n)
  {
    multiColorFlag = n;
  }
};

Line320::Line320()
  : xShift(0),
    multiColorFlag(false)
{
  buf = new float[352];
  for (size_t i = 0; i < 352; i++)
    buf[i] = 0.0f;
}

Line320::Line320(const Line320& r)
  : xShift(r.xShift),
    multiColorFlag(r.multiColorFlag)
{
  buf = new float[352];
  for (size_t i = 0; i < 352; i++)
    buf[i] = r.buf[i];
}

Line320::~Line320()
{
  delete[] buf;
}

Line320& Line320::operator=(const Line320& r)
{
  xShift = r.xShift;
  multiColorFlag = r.multiColorFlag;
  for (size_t i = 0; i < 352; i++)
    buf[i] = r.buf[i];
  return (*this);
}

void Line320::clear()
{
  for (size_t i = 16; i < 336; i++)
    buf[i] = 0.0f;
}

void Line320::setBorderColor(float c)
{
  for (size_t i = 0; i < 16; i++) {
    buf[i] = c;
    buf[i + 336] = c;
  }
}

// ----------------------------------------------------------------------------

class Image320x496 {
 private:
  Line320 *buf;
 public:
  Image320x496();
  Image320x496(const Image320x496& r);
  virtual ~Image320x496();
  Image320x496& operator=(const Image320x496& r);
  inline Line320& operator[](long n)
  {
    return buf[n];
  }
};

Image320x496::Image320x496()
{
  buf = new Line320[496];
}

Image320x496::Image320x496(const Image320x496& r)
{
  buf = new Line320[496];
  for (size_t i = 0; i < 496; i++)
    buf[i] = r.buf[i];
}

Image320x496& Image320x496::operator=(const Image320x496& r)
{
  for (size_t i = 0; i < 496; i++)
    buf[i] = r.buf[i];
  return (*this);
}

Image320x496::~Image320x496()
{
  delete[] buf;
}

// ----------------------------------------------------------------------------

class YUVImage320x496 {
 private:
  Image320x496  imageY;
  Image320x496  imageU;
  Image320x496  imageV;
 public:
  YUVImage320x496();
  YUVImage320x496(const YUVImage320x496& r);
  virtual ~YUVImage320x496();
  YUVImage320x496& operator=(const YUVImage320x496& r);
  inline Image320x496& y()
  {
    return imageY;
  }
  inline Image320x496& u()
  {
    return imageU;
  }
  inline Image320x496& v()
  {
    return imageV;
  }
};

YUVImage320x496::YUVImage320x496()
{
}

YUVImage320x496::YUVImage320x496(const YUVImage320x496& r)
  : imageY(r.imageY),
    imageU(r.imageU),
    imageV(r.imageV)
{
}

YUVImage320x496::~YUVImage320x496()
{
}

YUVImage320x496& YUVImage320x496::operator=(const YUVImage320x496& r)
{
  imageY = r.imageY;
  imageU = r.imageU;
  imageV = r.imageV;
  return (*this);
}

// ----------------------------------------------------------------------------

class Plus4FLIConverter {
 public:
  double  scaleX;
  double  scaleY;
  double  offsetX;
  double  offsetY;
  double  yMin;
  double  yMax;
  double  colorSaturationMult;
  double  colorSaturationPow;
  double  gammaCorrection;
  double  monitorGamma;
  double  ditherLimit;
  double  ditherScale;
  int     ditherMode;
  int     luminanceSearchMode;
  double  luminanceSearchModeParam;
  int     xShift0;
  int     xShift1;
  int     borderColor;
  int     nLines;
  int     colorInterlaceMode;
  bool    disablePAL;
  bool    disableInterlace;
  bool    luminance1BitMode;
  bool    noFLIDisplayCode;
  bool    noLuminanceInterlace;
 private:
  struct UVTableEntry {
    int     c0;
    int     c1;
    float   u;
    float   v;
    double  err;
  };
  static const float  yTableSrc[9];
  static const float  colorPhaseTablePAL[16];
  float               yTable[9];
  UVTableEntry        uvTable[43];
  PRGData             prgData;
  YUVImage320x496     resizedImage;
  Image320x496        ditherErrorImage;
  Line320 prvLineU;
  Line320 prvLineV;
  Line320 line0U;
  Line320 line0V;
  Line320 line1U;
  Line320 line1V;
  // ----------------
  static void pixelStoreCallback(void *, int, int, float, float, float);
  void colorToUV(int c, float& u, float& v);
  void createYTable();
  void createUVTables();
  void checkParameters();
  void ditherPixel(long xc, long yc);
  inline double calculateLuminanceError(float n, int l0, int l1);
  double findLuminanceCodes(long xc, long yc);
  void generateBitmaps();
  void findColorCodes(long xc, long yc, int dir_);
 public:
  Plus4FLIConverter();
  virtual ~Plus4FLIConverter();
  int processImage(const char *infileName, const char *outfileName);
};

const float Plus4FLIConverter::yTableSrc[9] = {
  2.00f,  2.40f,  2.55f,  2.70f,  2.90f,  3.30f,  3.60f,  4.10f,  4.80f
};

const float Plus4FLIConverter::colorPhaseTablePAL[16] = {
    0.0f,    0.0f,  103.0f,  283.0f,   53.0f,  241.0f,  347.0f,  167.0f,
  129.0f,  148.0f,  195.0f,   83.0f,  265.0f,  323.0f,    3.0f,  213.0f
};

Plus4FLIConverter::Plus4FLIConverter()
  : scaleX(1.0),
    scaleY(1.0),
    offsetX(0.0),
    offsetY(0.0),
    yMin(0.0),
    yMax(1.0),
    colorSaturationMult(1.0),
    colorSaturationPow(0.6),
    gammaCorrection(1.0),
    monitorGamma(1.33),
    ditherLimit(0.125),
    ditherScale(0.5),
    ditherMode(0),
    luminanceSearchMode(2),
    luminanceSearchModeParam(4.0),
    xShift0(-1),
    xShift1(-1),
    borderColor(0x00),
    nLines(464),
    colorInterlaceMode(1),
    disablePAL(false),
    disableInterlace(false),
    luminance1BitMode(false),
    noFLIDisplayCode(false),
    noLuminanceInterlace(false)
{
  createYTable();
  createUVTables();
}

Plus4FLIConverter::~Plus4FLIConverter()
{
}

void Plus4FLIConverter::pixelStoreCallback(void *userData, int xc, int yc,
                                           float y, float u, float v)
{
  Plus4FLIConverter&  this_ =
      *(reinterpret_cast<Plus4FLIConverter *>(userData));
  this_.resizedImage.y()[yc][xc >> 1] += (y * 0.5f);
  this_.resizedImage.u()[yc][xc >> 1] += (u * 0.5f);
  this_.resizedImage.v()[yc][xc >> 1] += (v * 0.5f);
}

void Plus4FLIConverter::colorToUV(int c, float& u, float& v)
{
  u = 0.0f;
  v = 0.0f;
  c = c & 15;
  if (c < 2)
    return;
  u = float(std::cos(colorPhaseTablePAL[c] * 3.14159265 / 180.0) * 0.19);
  v = float(std::sin(colorPhaseTablePAL[c] * 3.14159265 / 180.0) * 0.19);
}

void Plus4FLIConverter::createYTable()
{
  for (int i = 0; i < 9; i++) {
    double  tmp = yTableSrc[i];
    tmp = (tmp - yTableSrc[0]) / (yTableSrc[8] - yTableSrc[0]);
    tmp = (tmp > 0.0 ? (tmp < 1.0 ? tmp : 1.0) : 0.0);
    tmp = std::pow(tmp, monitorGamma);
    yTable[i] = float(tmp);
  }
}

void Plus4FLIConverter::createUVTables()
{
  static const unsigned char  colorIndexTable[86] = {
     1,  1,   2,  2,  12, 12,   7,  7,   6,  6,  15, 15,   4,  4,   8,  8,
     3,  3,  10, 10,  14, 14,   9,  9,  13, 13,   5,  5,  11, 11,   2,  8,
     3, 12,  10,  7,   6, 14,   5, 15,   4, 11,   9,  8,   3, 13,  10, 15,
     4, 14,   9,  7,   6, 13,   5, 12,   2, 11,   1,  2,  12,  1,   7,  1,
     1,  6,  15,  1,   1,  4,   8,  1,   1,  3,   1, 10,  14,  1,   1,  9,
    13,  1,   1,  5,  11,  1
  };
  for (int i = 0; i < 43; i++) {
    int     c0 = colorIndexTable[i << 1];
    int     c1 = colorIndexTable[(i << 1) + 1];
    uvTable[i].c0 = c0;
    uvTable[i].c1 = c1;
    float   u0 = 0.0f;
    float   v0 = 0.0f;
    float   u1 = 0.0f;
    float   v1 = 0.0f;
    colorToUV(c0, u0, v0);
    colorToUV(c1, u1, v1);
    uvTable[i].u = (u0 + u1) * 0.5f;
    uvTable[i].v = (v0 + v1) * 0.5f;
    uvTable[i].err = (calculateErrorSqr(u0, u1) + calculateErrorSqr(v0, v1))
                     / 20.0;
  }
}

void Plus4FLIConverter::checkParameters()
{
  limitValue(scaleX, 0.1, 10.0);
  limitValue(scaleY, 0.1, 10.0);
  limitValue(offsetX, -10000.0, 10000.0);
  limitValue(offsetY, -10000.0, 10000.0);
  limitValue(yMin, -0.5, 1.0);
  limitValue(yMax, 0.0, 2.0);
  limitValue(colorSaturationMult, 0.0, 8.0);
  limitValue(colorSaturationPow, 0.1, 2.0);
  limitValue(gammaCorrection, 0.25, 4.0);
  limitValue(monitorGamma, 0.25, 4.0);
  limitValue(ditherLimit, 0.0, 2.0);
  limitValue(ditherScale, 0.0, 1.0);
  limitValue(ditherMode, 0, 1);
  limitValue(luminanceSearchMode, 0, 5);
  switch (luminanceSearchMode) {
  case 2:
    limitValue(luminanceSearchModeParam, 1.0, 16.0);
    break;
  case 4:
    limitValue(luminanceSearchModeParam, 0.0, 0.5);
    break;
  case 5:
    limitValue(luminanceSearchModeParam, 0.0, 0.25);
    break;
  default:
    limitValue(luminanceSearchModeParam, 0.0, 1.0);
    break;
  }
  limitValue(xShift0, -2, 7);
  limitValue(xShift1, -2, 7);
  borderColor = (borderColor & 0x7F) | 0x80;
  nLines = (nLines <= 456 ? (nLines <= 400 ? 400 : 456)
                            : (nLines <= 464 ? 464 : 496));
  limitValue(colorInterlaceMode, 0, 2);
}

void Plus4FLIConverter::ditherPixel(long xc, long yc)
{
  if (xc < 0L || xc >= 320L || yc < 0L || yc >= 496L)
    return;
  long    xcShifted = xc - resizedImage.y()[yc].getXShift();
  if (xcShifted < 0L)
    return;
  int     l0 = prgData.l0(xcShifted, yc);
  int     l1 = prgData.l1(xcShifted, yc);
  float   pixelValueOriginal = resizedImage.y()[yc].getPixel(xc);
  float   ditherError = ditherErrorImage[yc].getPixel(xc);
  float   pixelValueDithered = pixelValueOriginal + ditherError;
  float   pixelValue0 = yTable[l0];
  float   pixelValue1 = yTable[l1];
  bool    bitValue = false;
  if (ditherMode == 0 && pixelValue1 > pixelValue0) {
    // ordered dithering
    float   tmp = pixelValueOriginal;
    if (tmp < pixelValue0)
      tmp = pixelValue0;
    if (tmp > pixelValue1)
      tmp = pixelValue1;
    tmp = (tmp - pixelValue0) / (pixelValue1 - pixelValue0);
    if (ditherPixelValue(xc, yc, tmp))
      pixelValueDithered = pixelValue1;
    else
      pixelValueDithered = pixelValue0;
  }
  if (calculateError(calculateError(pixelValue1, pixelValueOriginal),
                     calculateError(pixelValue0, pixelValueOriginal))
      >= ditherLimit) {
    bitValue = (calculateError(pixelValue1, pixelValueOriginal)
                < calculateError(pixelValue0, pixelValueOriginal));
  }
  else {
    bitValue = (calculateError(pixelValue1, pixelValueDithered)
                < calculateError(pixelValue0, pixelValueDithered));
  }
  prgData.setPixel(xcShifted, yc, bitValue);
  if (ditherMode == 0)
    return;
  // diffuse error
  float   newPixelValue = (bitValue ? pixelValue1 : pixelValue0);
  pixelValueDithered = pixelValueOriginal
                       + ((pixelValueDithered - pixelValueOriginal)
                          * float(ditherScale));
  if (pixelValueDithered < pixelValue0)
    pixelValueDithered = pixelValue0;
  if (pixelValueDithered > pixelValue1)
    pixelValueDithered = pixelValue1;
  double  err = double(pixelValueDithered) - double(newPixelValue);
  for (int i = 0; i < 3; i++) {
    long    yc_ = yc + i;
    if (yc_ >= 496L)
      break;
    for (int j = (i == 0 ? 1 : -2); j < 3; j++) {
      long    xc_ = j;
      if (yc & 1L)
        xc_ = -xc_;
      xc_ += xc;
      int     tmp = 16 >> (i + (j >= 0 ? j : (-j)));
      ditherErrorImage[yc_].setPixel(xc_, ditherErrorImage[yc_].getPixel(xc_)
                                          + float(err * (double(tmp) / 42.0)));
    }
  }
}

inline double Plus4FLIConverter::calculateLuminanceError(
    float n, int l0, int l1)
{
  float   l_0 = yTable[l0];
  float   l_1 = yTable[l1];
  double  err0 = calculateErrorSqr(l_0, n);
  double  err1 = calculateErrorSqr(l_1, n);
  double  err = (err0 < err1 ? err0 : err1);
  if (luminanceSearchMode == 2 && (n < l_0 || n > l_1))
    err *= luminanceSearchModeParam;
  if (luminanceSearchMode == 4) {
    double  tmp = 0.5 + luminanceSearchModeParam;
    double  l_0_ = (double(l_0) * tmp) + (double(l_1) * (1.0 - tmp));
    double  l_1_ = (double(l_0) * (1.0 - tmp)) + (double(l_1) * tmp);
    double  err0_ = calculateErrorSqr(l_0_, n);
    double  err1_ = calculateErrorSqr(l_1_, n);
    double  err_ = (err0_ > err1_ ? err0_ : err1_);
    err = (err_ < err ? err_ : err);
  }
  return err;
}

double Plus4FLIConverter::findLuminanceCodes(long xc, long yc)
{
  int     l0 = 0;
  int     l1 = 8;
  xc = xc & (~(long(7)));
  yc = yc & (~(long(noLuminanceInterlace ? 3 : 2)));
  float   tmpBuf[32];
  int     nPixels = (noLuminanceInterlace ? 32 : 16);
  for (int i = 0; i < nPixels; i++) {
    long    x_ = xc | long(i & 7);
    long    y_ = yc | long((i & 8) >> 2) | long(i >> 4);
    tmpBuf[i] = resizedImage.y()[y_].getPixelShifted(x_);
  }
  if (!luminance1BitMode) {
    // find the best pair of luminance values, depending on the search mode
    int     l0min = 8;
    int     l1max = 0;
    if (luminanceSearchMode >= 2 && luminanceSearchMode <= 4) {
      for (int i = 0; i < nPixels; i++) {
        while (l0min > 0 && tmpBuf[i] < yTable[l0min])
          l0min--;
        while (l1max < 8 && tmpBuf[i] > yTable[l1max])
          l1max++;
      }
      if (l0min == l1max) {
        if (l1max < 8)
          l1max++;
        else
          l0min--;
      }
    }
    else {
      float   minVal = 1.0f;
      float   maxVal = 0.0f;
      for (int i = 0; i < nPixels; i++) {
        if (tmpBuf[i] < minVal)
          minVal = tmpBuf[i];
        if (tmpBuf[i] > maxVal)
          maxVal = tmpBuf[i];
      }
      double  minErr0 = 1000000.0;
      double  minErr1 = 1000000.0;
      for (int i = 0; i < 9; i++) {
        double  err = calculateError(yTable[i], minVal);
        if (err < minErr0) {
          l0min = i;
          minErr0 = err;
        }
        err = calculateError(yTable[i], maxVal);
        if (err < minErr1) {
          l1max = i;
          minErr1 = err;
        }
      }
      if (l0min == l1max) {
        if (minErr0 < minErr1) {
          if (l1max < 8)
            l1max++;
          else
            l0min--;
        }
        else {
          if (l0min > 0)
            l0min--;
          else
            l1max++;
        }
      }
    }
    if (luminanceSearchMode == 1 || luminanceSearchMode == 3) {
      l0 = l0min;
      l1 = l1max;
    }
    else {
      double  minErr = 1000000.0f;
      for (int l0tmp = l0min; l0tmp < l1max; l0tmp++) {
        for (int l1tmp = l0tmp + 1; l1tmp <= l1max; l1tmp++) {
          float   minVal = yTable[l0tmp];
          float   maxVal = yTable[l1tmp];
          double  err = 0.0;
          for (int i = 0; i < nPixels; i++) {
            err += calculateLuminanceError(tmpBuf[i], l0tmp, l1tmp);
            err += (calculateErrorSqr(tmpBuf[i], (minVal + maxVal) * 0.5f)
                    * 0.00001);
          }
          if (err < minErr) {
            minErr = err;
            l0 = l0tmp;
            l1 = l1tmp;
          }
        }
      }
      if (luminanceSearchMode == 5) {
        bool    l0DecFlag;
        bool    l1IncFlag;
        do {
          l0DecFlag = false;
          l1IncFlag = false;
          if (l1 < l1max) {
            l1++;
            double  err = 0.0;
            for (int i = 0; i < nPixels; i++)
              err += calculateLuminanceError(tmpBuf[i], l0, l1);
            if ((err - minErr) < (double(nPixels) * luminanceSearchModeParam))
              l1IncFlag = true;
            else
              l1--;
          }
          if (l0 > l0min) {
            l0--;
            double  err = 0.0;
            for (int i = 0; i < nPixels; i++)
              err += calculateLuminanceError(tmpBuf[i], l0, l1);
            if ((err - minErr) < (double(nPixels) * luminanceSearchModeParam))
              l0DecFlag = true;
            else
              l0++;
          }
        } while (l0DecFlag || l1IncFlag);
      }
    }
  }
  // store luminance codes
  prgData.l0(xc, yc) = l0;
  prgData.l1(xc, yc) = l1;
  if (noLuminanceInterlace) {
    prgData.l0(xc, yc + 1L) = l0;
    prgData.l1(xc, yc + 1L) = l1;
  }
  // return the total amount of error (used when optimizing horizontal shifts)
  double  err = 0.0;
  for (int i = 0; i < nPixels; i++) {
    long    y_ = yc | long((i & 8) >> 2) | long(i >> 4);
    long    x_ = (xc | long(i & 7)) + resizedImage.y()[y_].getXShift();
    if (x_ >= 8L && x_ < 312L)  // ignore pixels that are not visible
      err += calculateLuminanceError(tmpBuf[i], l0, l1);
  }
  return err;
}

void Plus4FLIConverter::generateBitmaps()
{
  for (int yc = 0; yc < 496; yc += 2) {
    for (int xc = 0; xc < 320; xc++)
      ditherPixel(xc, yc);
    for (int xc = 319; xc >= 0; xc--)
      ditherPixel(xc, yc + 1);
  }
  for (int yc = 0; yc < 496; yc++) {
    if (yc & 2)
      continue;
    for (int xc = 0; xc < 320; xc += 8) {
      // if all bits are 0 or 1, replace the bitmaps with
      // a dither pattern to improve color conversion
      int     b0 = 0;
      int     b1 = 1;
      for (int i = 0; i < 16; i++) {
        bool    tmp = prgData.getPixel(xc | (i & 7), yc | ((i & 8) >> 2));
        b0 = b0 | int(tmp);
        b1 = b1 & int(tmp);
      }
      int&    l0 = prgData.l0(xc, yc);
      int&    l1 = prgData.l1(xc, yc);
      if ((b0 == 0 && l0 != 0) || (b1 == 1 && l1 != 0)) {
        if (b0 == 0)
          l1 = l0;
        else
          l0 = l1;
        for (int i = 0; i < 16; i++) {
          int     tmpY = yc | ((i & 8) >> 2);
          int     tmpX = (xc | (i & 7)) + resizedImage.y()[tmpY].getXShift();
          prgData.setPixel(xc | (i & 7), tmpY,
                           ditherPixelValue(tmpX, tmpY, 0.66667f));
        }
      }
    }
  }
}

void Plus4FLIConverter::findColorCodes(long xc, long yc, int dir_)
{
  bool    oddField = bool(yc & 1L);
  float   savedU0[9];
  float   savedV0[9];
  float   savedU1[9];
  float   savedV1[9];
  for (int i = 0; i < 9; i++) {
    savedU0[i] = line0U.getPixelShifted(xc + (i * dir_));
    savedV0[i] = line0V.getPixelShifted(xc + (i * dir_));
    savedU1[i] = line1U.getPixelShifted(xc + (i * dir_));
    savedV1[i] = line1V.getPixelShifted(xc + (i * dir_));
  }
  // find the pair of colors that gives the least amount of error
  int     c0 = 0;
  int     c1 = 0;
  int     l0 = prgData.l0(xc, yc);
  int     l1 = prgData.l1(xc, yc);
  double  minColorErr = 1000000.0;
  int     colorCnt =
      (colorInterlaceMode == 0 ? 15 : (colorInterlaceMode == 2 ? 43 : 29));
  for (int i0 = 0; i0 < colorCnt; i0++) {
    for (int i1 = 0; i1 < colorCnt; i1++) {
      int     c0tmp = 0;
      int     c1tmp = 0;
      double  err = 0.0;
      {
        float   u0 = 0.0f;
        float   v0 = 0.0f;
        float   u1 = 0.0f;
        float   v1 = 0.0f;
        double  err0 = 0.0;
        double  err1 = 0.0;
        if (l0 > 0) {
          c0tmp = (oddField ? uvTable[i0].c1 : uvTable[i0].c0);
          u0 = uvTable[i0].u;
          v0 = uvTable[i0].v;
          err0 = uvTable[i0].err;
        }
        if (l1 > 0) {
          c1tmp = (oddField ? uvTable[i1].c1 : uvTable[i1].c0);
          u1 = uvTable[i1].u;
          v1 = uvTable[i1].v;
          err1 = uvTable[i1].err;
        }
        for (int x = 0; x < 9; x++) {
          bool    b = prgData.getPixel(xc + ((x <= 7 ? x : 7) * dir_), yc);
          float   u_ = (b ? u1 : u0);
          float   v_ = (b ? v1 : v0);
          if (x < 8)
            err += (b ? err1 : err0);
          line0U.setPixelShifted(xc + (x * dir_), u_);
          line0V.setPixelShifted(xc + (x * dir_), v_);
          b = prgData.getPixel(xc + ((x <= 7 ? x : 7) * dir_), yc + 2L);
          u_ = (b ? u1 : u0);
          v_ = (b ? v1 : v0);
          if (x < 8)
            err += (b ? err1 : err0);
          line1U.setPixelShifted(xc + (x * dir_), u_);
          line1V.setPixelShifted(xc + (x * dir_), v_);
        }
      }
      for (int j = 0; j < 16; j++) {
        int     x = j & 7;
        Line320 *l0U = (j < 8 ? (&line0U) : (&line1U));
        Line320 *l0V = (j < 8 ? (&line0V) : (&line1V));
        float   u_ = l0U->getPixelShifted(xc + (x * dir_));
        float   v_ = l0V->getPixelShifted(xc + (x * dir_));
        if (!disablePAL) {
          // assume PAL filtering if requested
          Line320 *lm1U = (j < 8 ? (&prvLineU) : (&line0U));
          Line320 *lm1V = (j < 8 ? (&prvLineV) : (&line0V));
          u_ += lm1U->getPixelShifted(xc + (x * dir_));
          v_ += lm1V->getPixelShifted(xc + (x * dir_));
          u_ *= 0.96f;
          v_ *= 0.96f;
          u_ += (l0U->getPixelShifted(xc + ((x - 1) * dir_)) * 0.52f);
          v_ += (l0V->getPixelShifted(xc + ((x - 1) * dir_)) * 0.52f);
          u_ += (l0U->getPixelShifted(xc + ((x + 1) * dir_)) * 0.52f);
          v_ += (l0V->getPixelShifted(xc + ((x + 1) * dir_)) * 0.52f);
          u_ += (lm1U->getPixelShifted(xc + ((x - 1) * dir_)) * 0.52f);
          v_ += (lm1V->getPixelShifted(xc + ((x - 1) * dir_)) * 0.52f);
          u_ += (lm1U->getPixelShifted(xc + ((x + 1) * dir_)) * 0.52f);
          v_ += (lm1V->getPixelShifted(xc + ((x + 1) * dir_)) * 0.52f);
          u_ *= 0.25f;
          v_ *= 0.25f;
        }
        double  errU =
            double(u_)
            - double(resizedImage.u()[yc + ((j & 8) >> 2)].getPixelShifted(
                         xc + (x * dir_)));
        double  errV =
            double(v_)
            - double(resizedImage.v()[yc + ((j & 8) >> 2)].getPixelShifted(
                         xc + (x * dir_)));
        err = err + (errU * errU) + (errV * errV);
        if (err > (minColorErr * 1.000001))
          break;
      }
      if (err < minColorErr) {
        c0 = c0tmp;
        c1 = c1tmp;
        minColorErr = err;
      }
      else {
        for (int i = 0; i < 9; i++) {
          line0U.setPixelShifted(xc + (i * dir_), savedU0[i]);
          line0V.setPixelShifted(xc + (i * dir_), savedV0[i]);
          line1U.setPixelShifted(xc + (i * dir_), savedU1[i]);
          line1V.setPixelShifted(xc + (i * dir_), savedV1[i]);
        }
      }
    }
  }
  // store color codes
  prgData.c0(xc, yc) = c0;
  prgData.c1(xc, yc) = c1;
}

int Plus4FLIConverter::processImage(const char *infileName,
                                    const char *outfileName)
{
  std::FILE *f = (std::FILE *) 0;
  try {
    checkParameters();
    createYTable();
    float   borderY = yTable[((borderColor & 0x0F) != 0 ?
                              (((borderColor & 0x70) >> 4) + 1) : 0)];
    float   borderU = 0.0f;
    float   borderV = 0.0f;
    colorToUV(borderColor & 0x0F, borderU, borderV);
    prgData.clear();
    prgData.borderColor() = (unsigned char) borderColor;
    prgData.setVerticalSize(nLines);
    prgData.interlaceDisabled() = (unsigned char) disableInterlace;
    for (int yc = 0; yc < 496; yc++) {
      resizedImage.y()[yc].clear();
      resizedImage.y()[yc].setBorderColor(borderY);
      resizedImage.u()[yc].clear();
      resizedImage.u()[yc].setBorderColor(borderU);
      resizedImage.v()[yc].clear();
      resizedImage.v()[yc].setBorderColor(borderV);
      ditherErrorImage[yc].clear();
    }
    prvLineU.setBorderColor(borderU);
    prvLineV.setBorderColor(borderV);
    line0U.setBorderColor(borderU);
    line0V.setBorderColor(borderV);
    line1U.setBorderColor(borderU);
    line1V.setBorderColor(borderV);
    {
      Plus4FLIConv::YUVImageConverter imgConv;
      imgConv.setImageSize(640, nLines);
      imgConv.setPixelAspectRatio(1.0f);
      imgConv.setXYScaleAndOffset(float(scaleX), float(scaleY),
                                  float(offsetX), float(offsetY));
      imgConv.setYGamma(float(monitorGamma / gammaCorrection));
      imgConv.setLuminanceRange(float(yMin), float(yMax));
      imgConv.setColorSaturation(float(colorSaturationMult),
                                 float(colorSaturationPow));
      imgConv.setBorderColor(borderY, borderU, borderV);
      imgConv.setPixelStoreCallback(&pixelStoreCallback, (void *) this);
      imgConv.convertImageFile(infileName);
    }
    for (int yc = 0; yc < 496; yc += 2) {
      for (int xc = 0; xc < 320; xc++) {
        if (disableInterlace) {
          float   y0 = resizedImage.y()[yc].getPixel(xc);
          float   y1 = resizedImage.y()[yc + 1].getPixel(xc);
          resizedImage.y()[yc].setPixel(xc, (y0 + y1) * 0.5f);
          resizedImage.y()[yc + 1].setPixel(xc, (y0 + y1) * 0.5f);
        }
        float   u0 = resizedImage.u()[yc].getPixel(xc);
        float   u1 = resizedImage.u()[yc + 1].getPixel(xc);
        float   v0 = resizedImage.v()[yc].getPixel(xc);
        float   v1 = resizedImage.v()[yc + 1].getPixel(xc);
        resizedImage.u()[yc].setPixel(xc, (u0 + u1) * 0.5f);
        resizedImage.u()[yc + 1].setPixel(xc, (u0 + u1) * 0.5f);
        resizedImage.v()[yc].setPixel(xc, (v0 + v1) * 0.5f);
        resizedImage.v()[yc + 1].setPixel(xc, (v0 + v1) * 0.5f);
      }
    }
    for (int yc = 0; yc < 496; yc++) {
      int     xShift_ = (!(yc & 1) ? xShift0 : xShift1);
      if (xShift_ == -2)
        xShift_ = int(std::rand() & 0x7000) >> 12;
      else if (xShift_ == -1)
        xShift_ = 0;
      resizedImage.y()[yc].setXShift(xShift_);
      resizedImage.u()[yc].setXShift(xShift_);
      resizedImage.v()[yc].setXShift(xShift_);
    }
    if (!(xShift0 == 0 && xShift1 == 0)) {
      for (int yc = 0; yc < 496; yc++) {
        for (int i = 0; i < 8; i++) {
          resizedImage.y()[yc][i] = resizedImage.y()[yc][15 - i];
          resizedImage.y()[yc][312 + i] = resizedImage.y()[yc][311 - i];
          resizedImage.u()[yc][i] = resizedImage.u()[yc][15 - i];
          resizedImage.u()[yc][312 + i] = resizedImage.u()[yc][311 - i];
          resizedImage.v()[yc][i] = resizedImage.v()[yc][15 - i];
          resizedImage.v()[yc][312 + i] = resizedImage.v()[yc][311 - i];
        }
      }
    }
    for (int yc = 0; yc < nLines; yc++) {
      if ((yc & (noLuminanceInterlace ? 3 : 2)) != 0)
        continue;
      std::fprintf(stderr, "\r  %3d%%  ", int((yc * 33) / nLines));
      if (!(xShift0 == -1 || xShift1 == -1)) {
        for (int xc = 0; xc < 320; xc += 8)
          findLuminanceCodes(xc, yc);
      }
      else if (!(yc & 3)) {
        // find optimal horizontal shifts
        double  minErr = 1000000.0;
        int     bestXShift[4];
        int     xs[4];
        for (int i = 0; i < 4; i++) {
          bestXShift[i] = 0;
          xs[i] = 0;
        }
        do {
          for (int i = 0; i < 4; i++) {
            xs[i] = xs[i] & 7;
            resizedImage.y()[yc + i].setXShift(xs[i]);
            resizedImage.u()[yc + i].setXShift(xs[i]);
            resizedImage.v()[yc + i].setXShift(xs[i]);
          }
          bool    skipFlag = false;
          for (int i = 0; i < 4; i++) {
            // do not allow stepping by more than one pixel at once
            if ((yc + i) > 0) {
              int     d = resizedImage.y()[yc + i].getXShift()
                          - resizedImage.y()[yc + i - 1].getXShift();
              if (!(d == 0 || d == 1 || d == -1 || d == 7 || d == -7)) {
                skipFlag = true;
                break;
              }
            }
          }
          if (!skipFlag) {
            // calculate the total error for four lines
            double  err = 0.0;
            for (int xc = 0; xc < 320; xc += 8)
              err += findLuminanceCodes(xc, yc);
            if (!noLuminanceInterlace) {
              for (int xc = 0; xc < 320; xc += 8)
                err += findLuminanceCodes(xc, yc + 1);
            }
            if (err < minErr) {
              for (int i = 0; i < 4; i++)
                bestXShift[i] = xs[i];
              minErr = err;
            }
          }
          for (int i = 0; i < 4; i++) {
            xs[i] = xs[i] + 1;
            if (xs[i] < 8)
              break;
          }
        } while (xs[3] < 8);
        // use the best horizontal shift that was found
        for (int i = 0; i < 4; i++) {
          resizedImage.y()[yc + i].setXShift(bestXShift[i]);
          resizedImage.u()[yc + i].setXShift(bestXShift[i]);
          resizedImage.v()[yc + i].setXShift(bestXShift[i]);
        }
        for (int xc = 0; xc < 320; xc += 8)
          findLuminanceCodes(xc, yc);
        if (!noLuminanceInterlace) {
          for (int xc = 0; xc < 320; xc += 8)
            findLuminanceCodes(xc, yc + 1);
        }
      }
    }
    generateBitmaps();
    // convert color information
    {
      Line320 savedPrvLineU;
      Line320 savedPrvLineV;
      savedPrvLineU.setBorderColor(borderU);
      savedPrvLineV.setBorderColor(borderV);
      for (int xc = 0; xc < 320; xc++) {
        prvLineU[xc] = borderU;
        prvLineV[xc] = borderV;
        savedPrvLineU[xc] = borderU;
        savedPrvLineV[xc] = borderV;
      }
      for (int yc = 0; yc < nLines; yc++) {
        if (yc & 2)
          continue;
        std::fprintf(stderr, "\r  %3d%%  ", int(((yc * 67) / nLines) + 33));
        line0U.clear();
        line0V.clear();
        line1U.clear();
        line1V.clear();
        line0U.setXShift(resizedImage.u()[yc].getXShift());
        line0V.setXShift(resizedImage.v()[yc].getXShift());
        line1U.setXShift(resizedImage.u()[yc + 2].getXShift());
        line1V.setXShift(resizedImage.v()[yc + 2].getXShift());
        if (resizedImage.y()[yc].getXShift()
            >= resizedImage.y()[yc + 2].getXShift()) {
          for (int xc = 0; xc < 320; xc += 8)
            findColorCodes(xc, yc, 1);
        }
        else {
          for (int xc = 319; xc >= 0; xc -= 8)
            findColorCodes(xc, yc, -1);
        }
        for (int xc = 0; xc < 320; xc++) {
          prvLineU[xc] = (line1U[xc] * 0.5f) + (savedPrvLineU[xc] * 0.5f);
          prvLineV[xc] = (line1V[xc] * 0.5f) + (savedPrvLineV[xc] * 0.5f);
        }
        savedPrvLineU = line1U;
        savedPrvLineV = line1V;
      }
    }
    std::fprintf(stderr, "\r  100%%  \n");
    // write PRG file
    f = std::fopen(outfileName, "wb");
    if (!f) {
      std::fprintf(stderr, " *** error opening output file '%s'\n",
                           outfileName);
      return -1;
    }
    for (int yc = 0; yc < 496; yc++)
      prgData.lineXShift(yc) = (unsigned char) resizedImage.y()[yc].getXShift();
    prgData.convertImageData();
    if (noFLIDisplayCode) {
      if (std::fputc(0x00, f) == EOF || std::fputc(0x14, f) == EOF) {
        std::fprintf(stderr, " *** error writing output file\n");
        std::fclose(f);
        return -1;
      }
    }
    for (int i = (noFLIDisplayCode ? 0x0401 : 0x0000);
         i < (nLines <= 400 ? 0x8801 : 0xD501);
         i++) {
      if (std::fputc(int(prgData[i]), f) == EOF) {
        std::fprintf(stderr, " *** error writing output file\n");
        std::fclose(f);
        return -1;
      }
    }
    if (std::fflush(f) != 0) {
      std::fprintf(stderr, " *** error writing output file\n");
      std::fclose(f);
      return -1;
    }
    std::fclose(f);
  }
  catch (std::exception& e) {
    std::fprintf(stderr, " *** %s\n", e.what());
    if (f)
      std::fclose(f);
    return -1;
  }
  return 0;
}

int main(int argc, char **argv)
{
  fl_register_images();
  Plus4FLIConverter fliConv;
  const char  *infileName = (char *) 0;
  const char  *outfileName = (char *) 0;
  bool      invalidOption = false;
  bool      printUsageFlag = false;
  for (int i = 1; i < argc; i++) {
    if (std::strcmp(argv[i], "-ymin") == 0) {
      if (++i >= argc) {
        std::fprintf(stderr, " *** missing argument for '%s'\n", argv[i - 1]);
        return -1;
      }
      fliConv.yMin = std::atof(argv[i]);
    }
    else if (std::strcmp(argv[i], "-ymax") == 0) {
      if (++i >= argc) {
        std::fprintf(stderr, " *** missing argument for '%s'\n", argv[i - 1]);
        return -1;
      }
      fliConv.yMax = std::atof(argv[i]);
    }
    else if (std::strcmp(argv[i], "-scale") == 0) {
      if ((i + 2) >= argc) {
        std::fprintf(stderr, " *** missing arguments for '%s'\n", argv[i]);
        return -1;
      }
      fliConv.scaleX = std::atof(argv[i + 1]);
      fliConv.scaleY = std::atof(argv[i + 2]);
      i = i + 2;
    }
    else if (std::strcmp(argv[i], "-offset") == 0) {
      if ((i + 2) >= argc) {
        std::fprintf(stderr, " *** missing arguments for '%s'\n", argv[i]);
        return -1;
      }
      fliConv.offsetX = std::atof(argv[i + 1]);
      fliConv.offsetY = std::atof(argv[i + 2]);
      i = i + 2;
    }
    else if (std::strcmp(argv[i], "-saturation") == 0) {
      if ((i + 2) >= argc) {
        std::fprintf(stderr, " *** missing arguments for '%s'\n", argv[i]);
        return -1;
      }
      fliConv.colorSaturationMult = std::atof(argv[i + 1]);
      fliConv.colorSaturationPow = std::atof(argv[i + 2]);
      i = i + 2;
    }
    else if (std::strcmp(argv[i], "-gamma") == 0) {
      if ((i + 2) >= argc) {
        std::fprintf(stderr, " *** missing arguments for '%s'\n", argv[i]);
        return -1;
      }
      fliConv.gammaCorrection = std::atof(argv[i + 1]);
      fliConv.monitorGamma = std::atof(argv[i + 2]);
      i = i + 2;
    }
    else if (std::strcmp(argv[i], "-dither") == 0) {
      if ((i + 3) >= argc) {
        std::fprintf(stderr, " *** missing arguments for '%s'\n", argv[i]);
        return -1;
      }
      fliConv.ditherMode = std::atoi(argv[i + 1]);
      fliConv.ditherLimit = std::atof(argv[i + 2]);
      fliConv.ditherScale = std::atof(argv[i + 3]);
      i = i + 3;
    }
    else if (std::strcmp(argv[i], "-pal") == 0) {
      if (++i >= argc) {
        std::fprintf(stderr, " *** missing argument for '%s'\n", argv[i - 1]);
        return -1;
      }
      fliConv.disablePAL = !(std::atoi(argv[i]));
    }
    else if (std::strcmp(argv[i], "-xshift") == 0) {
      if ((i + 2) >= argc) {
        std::fprintf(stderr, " *** missing arguments for '%s'\n", argv[i]);
        return -1;
      }
      fliConv.xShift0 = std::atoi(argv[i + 1]);
      fliConv.xShift1 = std::atoi(argv[i + 2]);
      i = i + 2;
    }
    else if (std::strcmp(argv[i], "-border") == 0) {
      if (++i >= argc) {
        std::fprintf(stderr, " *** missing argument for '%s'\n", argv[i - 1]);
        return -1;
      }
      fliConv.borderColor = std::atoi(argv[i]);
    }
    else if (std::strcmp(argv[i], "-nointerlace") == 0) {
      if (++i >= argc) {
        std::fprintf(stderr, " *** missing argument for '%s'\n", argv[i - 1]);
        return -1;
      }
      fliConv.disableInterlace = bool(std::atoi(argv[i]));
    }
    else if (std::strcmp(argv[i], "-size") == 0) {
      if (++i >= argc) {
        std::fprintf(stderr, " *** missing argument for '%s'\n", argv[i - 1]);
        return -1;
      }
      fliConv.nLines = std::atoi(argv[i]);
      if (fliConv.nLines < 400) {
        fliConv.disableInterlace = true;
        fliConv.nLines = fliConv.nLines << 1;
      }
      else
        fliConv.disableInterlace = false;
    }
    else if (std::strcmp(argv[i], "-y1bit") == 0) {
      if (++i >= argc) {
        std::fprintf(stderr, " *** missing argument for '%s'\n", argv[i - 1]);
        return -1;
      }
      fliConv.luminance1BitMode = bool(std::atoi(argv[i]));
    }
    else if (std::strcmp(argv[i], "-no_li") == 0) {
      if (++i >= argc) {
        std::fprintf(stderr, " *** missing argument for '%s'\n", argv[i - 1]);
        return -1;
      }
      fliConv.noLuminanceInterlace = bool(std::atoi(argv[i]));
    }
    else if (std::strcmp(argv[i], "-ci") == 0) {
      if (++i >= argc) {
        std::fprintf(stderr, " *** missing argument for '%s'\n", argv[i - 1]);
        return -1;
      }
      fliConv.colorInterlaceMode = std::atoi(argv[i]);
    }
    else if (std::strcmp(argv[i], "-searchmode") == 0) {
      if ((i + 2) >= argc) {
        std::fprintf(stderr, " *** missing arguments for '%s'\n", argv[i]);
        return -1;
      }
      fliConv.luminanceSearchMode = std::atoi(argv[i + 1]);
      fliConv.luminanceSearchModeParam = std::atof(argv[i + 2]);
      i = i + 2;
    }
    else if (std::strcmp(argv[i], "-raw") == 0) {
      if (++i >= argc) {
        std::fprintf(stderr, " *** missing argument for '%s'\n", argv[i - 1]);
        return -1;
      }
      fliConv.noFLIDisplayCode = bool(std::atoi(argv[i]));
    }
    else if (std::strcmp(argv[i], "-h") == 0 ||
             std::strcmp(argv[i], "-help") == 0 ||
             std::strcmp(argv[i], "--help") == 0) {
      printUsageFlag = true;
    }
    else if (argv[i][0] == '-' || outfileName != (char *) 0) {
      std::fprintf(stderr, " *** invalid option '%s'\n", argv[i]);
      invalidOption = true;
      break;
    }
    else {
      if (!infileName)
        infileName = argv[i];
      else
        outfileName = argv[i];
    }
  }
  if (invalidOption || printUsageFlag || outfileName == (char *) 0) {
    std::fprintf(stderr, "Usage: %s [OPTIONS...] infile.jpg outfile.prg\n",
                         argv[0]);
    std::fprintf(stderr, "Options:\n");
    std::fprintf(stderr, "    -ymin <MIN>         (default: 0.0)\n");
    std::fprintf(stderr, "    -ymax <MAX>         (default: 1.0)\n");
    std::fprintf(stderr, "        scale luminance range from 0..1 to "
                         "MIN..MAX\n");
    std::fprintf(stderr, "    -scale <X> <Y>      (defaults: 1.0, 1.0)\n");
    std::fprintf(stderr, "        scale image size\n");
    std::fprintf(stderr, "    -offset <X> <Y>     (defaults: 0.0, 0.0)\n");
    std::fprintf(stderr, "        set image position offset\n");
    std::fprintf(stderr, "    -saturation <M> <P> (defaults: 1.0, 0.6)\n");
    std::fprintf(stderr, "        color saturation scale and power\n");
    std::fprintf(stderr, "    -gamma <G> <M>      (defaults: 1.0, 1.33)\n");
    std::fprintf(stderr, "        set gamma correction (G) and assumed "
                         "monitor gamma (M)\n");
    std::fprintf(stderr, "    -dither <M> <L> <S> (defaults: 0, 0.125, 0.5)\n");
    std::fprintf(stderr, "        dither mode (0: ordered, 1: diffuse), "
                         "limit, and error diffusion\n        factor\n");
    std::fprintf(stderr, "    -pal <N>            (0 or 1, default: 1)\n");
    std::fprintf(stderr, "        assume PAL chrominance filtering "
                         "if set to 1\n");
    std::fprintf(stderr, "    -xshift <S0> <S1>   "
                         "(-2 to 7, defaults: -1, -1)\n");
    std::fprintf(stderr, "        set horizontal shift for each field (-2 is "
                         "random, -1 finds\n        optimal values)\n");
    std::fprintf(stderr, "    -border <N>         (0 to 255, default: 0)\n");
    std::fprintf(stderr, "        set border color\n");
    std::fprintf(stderr, "    -nointerlace <N>    (0 or 1, default: 0)\n");
    std::fprintf(stderr, "        do not use double vertical resolution\n");
    std::fprintf(stderr, "    -size <N>           "
                         "(200 to 496, default: 464)\n");
    std::fprintf(stderr, "        set vertical resolution (< 400 implies "
                         "no interlace)\n");
    std::fprintf(stderr, "    -y1bit <N>          (0 or 1, default: 0)\n");
    std::fprintf(stderr, "        use 1 bit (black and white) luminance\n");
    std::fprintf(stderr, "    -no_li <N>          (0 or 1, default: 0)\n");
    std::fprintf(stderr, "        do not interlace luminance attributes\n");
    std::fprintf(stderr, "    -ci <N>             (0 to 2, default: 1)\n");
    std::fprintf(stderr, "        color interlace mode (0: none, 1: hue only, "
                         "2: hue and\n        saturation)\n");
    std::fprintf(stderr, "    -searchmode <M> <P> (defaults: 2, 4.0)\n");
    std::fprintf(stderr, "        select luminance search algorithm (0 to 5), "
                         "and parameter for\n        modes 2, 4, and 5\n");
    std::fprintf(stderr, "    -raw <N>            (0 or 1, default: 0)\n");
    std::fprintf(stderr, "        write the image data only\n");
    return (printUsageFlag ? 0 : -1);
  }
  return fliConv.processImage(infileName, outfileName);
}

