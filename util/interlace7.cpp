
// interlace7.cpp: simple high resolution interlaced FLI converter utility
// Copyright (C) 2007-2008 Istvan Varga <istvanv@users.sourceforge.net>
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>

static const int ditherTable[4096] = {
  3958, 1538,    1, 3691, 1863, 2352,  626, 3333,  305, 2638,  743, 2803,
   468, 1740, 3146, 1273, 2764, 1058, 2968, 1941,  897, 2101, 3649,  730,
  2183, 3746, 1193, 2735,  990, 2911, 1854, 2351,  695, 3807,  948, 2321,
  3620, 1652,    3, 3523, 1287, 2452, 1530, 2935, 1233,   49, 1767, 4046,
  1447, 3331, 1156, 1987, 3770, 1534, 3272,  273, 2308, 3675, 1580,   42,
  2785, 1022, 3575, 1991,  527, 2237, 3346, 1439,  357, 3867, 1683, 2167,
  3950, 1161, 3608, 1398, 2359, 4039,   86, 3521, 1424, 3739,  703, 2562,
  3814, 1436,  202, 3381, 1637,  478, 3235, 2018, 3528,  451, 3880, 1280,
  2784, 1456, 2984,  229, 1378, 3198, 2206,  673, 2031, 3638,  742, 1843,
  3837, 1981, 3244,  356, 2438,  659, 3913,  471, 2458,  632, 2165, 4086,
  1413,  485, 2138, 3883,  828, 2559,  206, 2982, 1933, 2831,  866, 2422,
  3111, 1114, 2874,  947, 1925, 2521,  173, 3090,  619, 2005, 3004,  796,
  2297,  298, 3201, 1566,  443, 2244, 3029, 1153, 2453, 4054, 1392,  116,
  1718, 2596,  799, 3354,   67, 3454, 1074, 4024, 2489,  817, 3851, 1731,
  2800,  159, 3174, 2360,  420, 2680,  812, 2971, 1693, 2706, 1266, 3115,
  1062, 3520, 1702,  889, 2954, 1828, 2732, 1174, 2893, 1448, 3372, 1152,
  3728,  283, 4007, 1753,  589, 3463,  103, 3657,  552, 3279, 2119, 1513,
  3704, 1038, 2414, 1634, 3960, 1986, 1084, 3581, 1804, 3912,  625, 2772,
   339, 2117, 3051, 1928, 3156, 1342, 2973, 1179, 2433, 1768, 2277,  567,
  1873, 2731,  378, 3371, 1028, 4069, 2100,  885, 3490, 1496, 3754,  995,
  3457,  105, 3627, 1883, 2870,  209, 2581, 3407,  115, 3816,  647, 3447,
   381, 4036,  596, 2148, 1085, 2546, 1254, 2958, 1905, 2283, 1559, 2574,
  2046, 1320, 3796,  422, 1957, 3375,  224, 2748,  532, 3105, 2467,  134,
  2839,  867, 3283, 1948, 3693, 1263,  691, 3615,  557, 3972,  282, 1984,
  3571,  400, 3714, 1591, 3320, 1088, 2956, 1505, 2540,  537, 1613, 2882,
  1298, 2608,  223, 2333, 1407, 2833, 1609,  399, 2184, 3949, 1217, 1972,
  2334, 1384, 3125, 2060, 1662, 2354, 1795, 3251, 2722,  669, 3296,  195,
  3595,  769, 3906,  327, 3217,  849, 2448, 1721, 2819,  717, 3154, 1458,
  3628,  965, 1855, 3362, 1229, 2644, 1499,   50, 1669, 2919, 2226, 1552,
  2480, 1042, 2174, 3223, 1001, 2809,  844, 3088,  124, 3918, 2185,  261,
  3744, 2012, 3536,   85, 3944,  702, 3415, 1133, 4006,  748, 2499, 3794,
  1460,  666, 3231,  458, 3710,  795, 2471,  157, 3639,  735, 3028,   77,
  1506, 3541, 1672, 2455, 1416, 2708, 1127, 2943, 1650, 4061,   19, 3419,
  1188, 3848, 1815,  832, 2249, 2948,  408, 2200, 4032,  521, 3549, 2048,
  3946,  492, 3428,  179, 3735, 1752, 2709,  711, 4041, 1842, 2343, 1430,
  2565, 1950,  968, 3123,  761, 1364, 2240, 3079, 1103, 2468, 1657, 2653,
   438, 3147, 2074,  878, 3318, 2390, 1107, 2927, 1734, 2689, 1524, 3219,
  1072, 2633, 1371, 3852, 2324,  367, 2863,  714, 3810,  448, 3388, 2155,
   991, 2245, 2899,  802, 2651,  344, 2506, 3983,   62, 2040, 3802, 1132,
  1967, 2494,  920, 2873, 1323, 2572, 1147, 2828,  822, 3258,   27, 2992,
  1531,  215, 3765,  653, 3468,  483, 3576, 1579, 2282, 3352,  389, 1760,
  2781,  302, 3274,  856, 3602, 1745,  180, 2898, 1849,   59, 3614, 2103,
   292, 3997,  555, 1886, 3920,  332, 3323,  803, 1166, 4074, 1054, 3084,
  1339, 2607, 1870,  146, 3555,  575, 1369, 3679, 1887, 3472, 1050, 2107,
  3214, 1374,  687, 3013,  166, 3185, 1884,  278, 3393,  667, 3857, 1796,
  2368, 1450, 3826,  907, 2087, 3193, 1128, 3036, 2110, 1336, 2623,   37,
  4015, 1215, 2144, 3708,  781, 3849, 1316, 2865, 1183, 2303, 3471,  986,
  4059, 1570, 2529,  765, 3182, 1428, 2202, 2852, 1247, 2492, 1629, 2808,
  3210, 1920, 2384,   47, 3451,  893, 3974, 1476, 2782, 1835, 3119, 2204,
   183, 1525, 2988,  515, 1663, 3573, 2235, 1574, 3749,  976, 3499, 2331,
  1097, 2941, 2156,  371, 3585,  617, 2214, 2650, 3507,  545, 1917, 2416,
   307, 3952, 2022, 3003, 1929,  565, 2686, 1415, 3131, 1834, 2254,   18,
  3925,  574, 1945, 2634,  372, 3064, 1343, 3762, 2029,  909, 3567,   24,
  3434,  705, 3698,  177, 1746,  498, 3664, 1585, 2090, 2666,  316, 2488,
   746, 3766,  395, 1222, 4020, 2554,  914, 3726, 2445,  263, 3096,  577,
  1845, 2758,  428, 2008, 4005,  104, 1598, 3071, 1366, 3179, 1720,  345,
  1307, 2511, 3868,  952, 3330, 1641,  620, 1150, 3662, 1682, 3299,  151,
  2348,  508, 3542, 1791, 2402, 1545, 3724, 1210, 3397, 1913,  588, 2594,
   216, 3092, 1707, 2418, 1124, 2932, 1435, 2655, 3348, 2171, 1271, 3238,
   613, 3709, 1632, 3264, 2038, 1404, 2699, 3342, 1737,  453, 3307, 2025,
  1317, 2810, 1121, 4079, 2380, 1218, 3612, 1352, 2659, 1827, 3676,  879,
  2745,  204, 4090, 1976, 3656, 1603,   74, 2891, 1197, 2719, 1862, 3153,
   335, 2485,  956, 3891, 1244, 2979, 1002, 3212,  756, 3042,  255, 2712,
   845, 2322, 3480, 1039, 3842, 2220,  479, 4048, 1996,  409, 3806,  655,
  1000, 3875,  266, 2756, 2000, 1177, 2340,  538, 3935,   70, 2239,  622,
  2128, 3075, 1583,   98, 3903,  854, 3385, 1715,    4, 2885,  871, 3126,
   723, 2439,  449, 3230, 1205, 2536, 1018, 2701,  509, 2963, 2208,  789,
  3596,  185, 3776, 2247, 1495, 3437, 2077,  608, 2582, 1587, 4082,  362,
  2753, 1068, 3305, 1666, 3979,  130, 1489, 2907, 1639,  786, 2816,  971,
  3158, 2295, 1297, 2576, 3070, 1773, 2437, 1390, 4026,  168, 3503, 1304,
  2567, 1784, 3604, 1438, 3825, 1014, 2396, 3433, 1201, 2694,  383, 2168,
  3268, 1486, 3886,  222, 1989, 3812, 1510, 2142, 3928,  583, 3475, 1437,
  3361,  928, 3999, 1777, 2125, 2843, 1325,  579, 4050,   95, 2775, 1770,
  3689,  196, 1896, 2545, 1426, 3822, 1880,  543, 2510, 1858, 3683,  432,
  2096, 3291, 1260, 3631,  240, 1832, 3406,   99, 2193,  814, 3593,  563,
  2104, 3143, 1705, 2983,  794, 3197,  902, 2892,  218, 2736,  732, 2079,
  3141,  679, 1952, 3788,  757, 2600, 1079, 2294, 3344,  827, 3000,   43,
  1660, 2934, 1946,  137, 2016, 2614,  290, 3170,  641, 1539, 3367, 2172,
  1112, 2945, 1351, 3189,  911, 2190, 3392,  833, 2876,   82, 2285, 3560,
   935, 3234, 1145, 2461, 3961,   69, 1968, 2369, 1541, 2999,  922, 3993,
   376, 2834, 1487, 2937,  962, 2473,  425, 2053, 3752,  336, 2373, 1881,
  3485, 1289, 3995,  314, 1678, 3634, 2475, 1245, 2788,  300, 3449, 1747,
   475, 2767, 1267, 3432, 2353,  978, 3603, 1742, 3805, 1073, 3532, 1230,
  2399, 3910,  375, 3052, 1960,  661, 3589,  348, 1983, 3018,  455, 3787,
  1333, 3262, 1235, 2051, 2805,  275, 3005,  629, 1443, 2620, 3465,  610,
  3900,  505, 2739, 1955, 3730, 1094, 3358,   12, 3859, 1445, 3546, 1139,
  2292, 1554, 4087,  501, 1615, 2859,  969, 2211, 2924, 1423,  142, 3324,
   994, 3083, 1344, 4049, 2508, 1029, 3738, 2067,  648, 2820,  326, 2673,
   727, 2502, 1470, 3024,   10, 1736, 2692,  943, 3420, 2520, 1011, 2376,
  3984, 1165, 2631, 1622, 2417,  733, 4029,  473, 1595, 3873, 2231, 1822,
  3584,  862, 1651, 2696, 1203, 3202, 2127, 1349,  741, 2628, 1676, 2363,
  1236, 2676,  763, 3181,  119, 3061, 1077, 2544, 3295,   33, 1963, 3537,
   550, 3866, 2124, 1793, 3953,  643, 2273,  113, 1888, 3134,  355, 1617,
  3280, 1237, 4021, 1564, 3236,  424, 2737,  840, 3684, 2269, 1269, 3845,
   211, 1689, 3751, 1528,   45, 3338,  650, 3610,  232, 2986, 1035, 2561,
  3424, 1367,  698, 3137,  186, 2175, 3254,  299, 3672, 1739,  148, 2974,
  3488,  289, 4056,  640, 3440,  259, 3784, 1890, 2580,  671, 3527, 2003,
   932, 3809, 2407, 1329, 2754, 1108, 3048,  415, 2424, 1653, 2977, 1285,
  3646,  775, 2412, 3861,  169, 3058, 2217,  959, 2130, 3942, 1162, 3310,
  1820,  470, 3228,  778, 2307, 3089,  541, 2747, 2154, 1748, 2912,  977,
  2599, 1482, 3216, 2112,    6, 2014, 3655, 1181, 1937, 4091, 1102, 2583,
   954, 2345, 3838, 1061, 1548, 2495, 1189, 2850, 1910, 2961, 1624,  910,
  3908, 1763, 2266,  272, 3103, 1713,  592, 3176,  205, 2534,  859, 3721,
  1393, 3558,  535, 3304, 1500, 2687, 1973, 1144, 2637, 1850,  560, 3395,
    78, 1895, 2867,  257, 2431, 4076, 1420, 2762, 1801, 1056, 3504, 1240,
  3828,  421, 1908, 3933, 1220, 3509,  392, 1684, 3317, 2487,  496, 2949,
  2442,  414, 3050, 1467, 3531,  683, 1846, 2768, 3297,  800, 3640, 2166,
   513, 1318, 3386, 2413,  406, 3032,  852, 3971, 1115, 2313, 3654, 1206,
  4066, 1535, 3246, 1902,   55, 2570, 1812, 2329,  230, 3986,  486, 3456,
   886, 3669, 1521, 2289, 3769,  998, 2229, 3621, 1573,  675, 2960,  109,
  3195, 2054,  297, 2835,  873, 3113, 2296,  132, 2703,  806, 2350, 3855,
  1310,  829, 3943, 2092, 1007, 3737,  749, 2792,   39, 3161, 2275,  442,
  1401, 3077,   91, 1726, 3965, 2595,  158, 2064, 3600, 1291, 2647, 1508,
  2904,  379, 1839, 2822,  785, 2668,  493, 2299, 3497,  917, 3922,  987,
  3200, 2120, 1417, 2259, 2916,  386, 2812,  819, 2044, 3044,  627, 1321,
  3124, 2094, 1200, 3727,  930, 4003, 2356, 1396, 3645, 1712,  768, 3302,
  1409, 3732, 1809,  249, 2588, 3038, 1607,  117, 3401, 1709, 2309, 1231,
  4013, 1782,  992, 3929, 2609,  937, 2383, 3265,  868, 1571, 3706, 1432,
   715, 3256,   64, 3715,  772, 3508, 2250,  127, 3462, 1355, 3831, 1159,
  2072, 2908,  318, 2741, 1706,  614, 3578,   21, 1761, 4063, 1387, 3327,
   276, 1640, 3895, 2004,  163, 3565, 2454,  403, 2654, 1619,  586, 3359,
   174, 2641, 4067, 1024, 3009,  459, 2143, 3130, 1503,  571, 3513, 1899,
  2539,  320, 3332, 2062,  581, 2182, 2910,  207, 1515, 3742, 2033,  350,
  2880, 2134,  568, 2224, 2842, 1597, 2484, 1379, 2723, 1751, 1069, 3152,
  1628, 2472,  254, 2998,  600, 1776, 3423, 1135, 3797, 2242, 1584, 2151,
  3106,  744, 2542, 1046, 3718, 2466,  494, 3378, 2598, 1701,  808, 3452,
  1283, 3247, 1868, 2481, 1262, 2105,  512, 2010, 2434, 1582, 3580,  981,
  4040, 2264,  918, 2881, 1096, 3081,  890, 3777, 1498, 3500, 1276, 3410,
  2980,  481, 1802, 3373, 1157, 3844, 1788, 3482,  303, 4051,  611, 3366,
   236, 3894, 2435,  460, 4010,  820, 3347, 1449, 3686, 2382,  697, 2629,
   154, 3259,  804, 3840, 1093, 2726,  147, 3150, 2089, 1130, 2952, 1464,
   602, 3951, 2284, 1031, 2905,   28, 3881,  692, 3544, 2743, 1361, 3800,
    61, 3370,  670, 2797,  164, 1769, 3696,  401, 3911, 1556, 2425,  143,
  2829,  388, 2517,  693, 1322, 2323, 4071,  810, 2725,   26, 2987,  973,
  2617, 1225, 2939, 1006, 2335, 2013,  939, 2920, 1264, 2590, 1020, 2796,
    93, 1311, 4028, 1555, 3022, 1256, 2603,  341, 3436, 1949, 3931, 1675,
   594, 3484,   52, 2339, 3072, 1406,  243, 3792, 1744, 2327, 1433, 3055,
  1924,  270, 3209, 1655, 2900, 1083, 2618, 1301, 3276, 2411, 1224, 2773,
  1856,  558, 3188, 2030, 1692, 3618, 1122, 3890, 2681, 1661,  245, 3155,
  1474, 2525, 1251, 3233,  529, 3644, 2176, 1656, 3775,  681, 3592, 1698,
  3418,  325, 3733, 2203, 1837, 3066, 2042,  510, 1980, 3747, 1009, 2966,
  1772,  548, 1368, 2857, 2215, 1560, 4043, 1934,  894, 3335, 2027, 2720,
   634, 3594,  436, 2194,  857, 3687, 2126,  553, 2037, 3957,  315, 3635,
  1985,  758, 3110,   31, 2330, 3564, 1027, 3973,  946, 2216, 2887,   66,
   926, 3091, 2068, 1034, 3583,  726, 3981, 1618, 2457, 1951,  112, 3020,
   419, 2691, 1943,    8, 1997, 2861, 1543,  729, 3884,  393, 3563, 1733,
  3355,  265, 2428, 1332, 3288, 2021, 3624,  306, 3411,  721, 2523,  412,
  3705, 2389,  782, 1511, 3173, 1168, 2690, 4025, 1472, 2555, 1118, 3097,
  1324, 2385, 1754, 2281,  429, 3834, 1520, 3376, 1170, 2108, 2711,  256,
  3016,  616, 1940, 3322, 3700,  518, 3461, 2394,  373, 2671, 1859,  189,
  3524,  905, 3941, 1480, 3445, 1101, 3315, 1375, 3959,  582, 2139, 2953,
  1363, 2679, 1192, 2878,  936, 2713,  777, 3870,   83, 2551,  966, 2661,
  1175, 2897, 1252, 3187, 1816,  128, 2159, 3982,  288, 2503, 1900,  106,
  3289,  605, 3904,  193, 3522,  779, 3245, 1138, 2837, 1345, 2682,  836,
  4078,  466, 1833, 3425, 1418, 3795, 1265, 2161, 1757, 2806, 1185, 1930,
  3758, 1081, 3394, 2241, 1408, 2118, 2717,  790, 1798, 2611,  720, 3033,
  2260, 1239, 3389,  175, 3248,  665, 2504,   36, 4073, 1281, 3183, 1481,
  2778,  737, 3964, 1966, 3556,  182, 3778, 2207,  944, 2791, 3384, 1089,
  2099, 3511,  957, 2807, 2066, 1604, 2243, 2853, 1003, 2721,   89, 4016,
   642, 3493,  203, 1970, 2447, 1631, 2926,  895, 2558,  423, 2779,  219,
  2314,  674, 3936,  129, 2145, 2933,  464, 2825,  637, 3175,  285, 2055,
  3830,  199, 3650, 1874,  349, 3607, 1589, 2370, 1891, 3782,  997, 3464,
  1806, 2320,  358, 3677, 1075, 3095, 1664,  476, 1494, 2624, 1841,  506,
  3916, 1995,  445, 1783, 3011,  533, 1836, 3740,  385, 3470,  699, 1778,
  3819, 1454, 2519, 1253, 2989, 1679, 2228, 3312,  660, 3651,  108, 3863,
  1992, 3479, 1134, 4037, 1593, 3203, 1346, 3045, 1562,  874, 3659, 1818,
  4033, 1167, 3548, 2501,  888, 2888, 2233, 1043, 2082, 2547,  847, 4000,
   446, 1459, 3112, 2163,  531, 3014, 1694, 2091, 2397,  228, 3321, 2050,
  2994,  984, 3117, 1590, 2477, 1063, 3665, 2584,  913, 3858, 2361, 1216,
  2658, 1397, 2970, 2132,  364, 3345,  870, 3678, 1876,  503, 3761,  996,
  2766, 1395, 3171, 1567,  573, 1775, 3122,  831, 3574,  281, 2749,  591,
  3823, 2469, 1446,   48, 2093, 3062,  504, 1575, 3292, 1425,  472, 4083,
  2705,   68, 2975, 1129, 2838, 2221,  214, 1608, 3340, 1155, 3534,  657,
  4012, 1922,  843, 3643,    0, 4094,  682, 3519,  235, 3241, 1914,   58,
  3133, 1969,  208, 3271,  753, 4085,   14, 3626, 1292, 2201, 2917,  252,
  2693, 2121, 1504, 3074,  353, 2493,  858, 2677, 2047, 2896,    2, 2419,
  1982, 2272, 1685, 3416, 2002,  331, 2665, 3339,  759, 2379, 1853, 3898,
    97, 2036, 3213, 1670,  773, 3745, 1958, 3369,  631, 3663, 1857, 3927,
   908, 2793,  120, 2646, 1295, 2845, 2238, 1441, 2760, 1341, 2432, 1158,
  2847, 2232,  877, 4034, 2187, 1149, 3599, 1565, 2470, 1111, 2755, 1944,
  3194,  598, 1646, 3442, 1048, 3879,   54, 2180, 3947, 1160, 3529,  312,
  4004, 1040, 3736, 1388,  490, 3874,  798, 2341, 1148, 3118, 1723, 1012,
  3779, 1268, 2965, 1066, 2444, 3719,  982, 2357, 3128, 1468,  404, 1704,
  2577, 1212, 2728,  377, 2528, 1400, 3820, 1021, 3422,  322, 3756,  542,
  1861, 3404,  346, 3843, 1717,  559, 3426, 1546,  461, 2946,  680, 2786,
   337, 3148, 1703,  522, 1478, 3989, 2429,  813, 2860, 1383, 3286, 1803,
   621, 2826, 1953, 3211, 1296, 2465,  770, 3379, 2621, 1327, 3240,   88,
  4092,  823, 3570, 2325,  212, 2688,  384, 3408, 1533,  572, 3053,  251,
  1299, 3450, 2017, 3878,  136, 3505,  872, 3253,  713, 3087, 1898, 2342,
   752, 3139, 1577, 2147, 2922, 1082, 2669, 1275, 3285, 2063, 1019, 3049,
  2514, 1331, 3773, 1243, 3439,  916, 3872, 2257, 3025,  138, 1964, 3720,
   413, 2593,  728, 2403, 3622, 1462,  153, 1674, 2730,  360, 2947, 1209,
   194, 2848, 1519, 2597, 1278, 2814,  441, 1926, 3226, 1805, 4008,  921,
  2771, 2192, 1814, 3938, 2535,  525, 2818,  904, 3142, 1527, 2362, 1939,
  3992, 1248,  269, 3611, 1755, 2518,  919, 3905,  197, 3540,  644, 3023,
   114, 2605, 3699,  280, 1797, 3164,   92, 2291, 1771, 2564,  241, 2015,
   980, 3550, 1213, 2146, 3225, 1142, 4062, 1610,  457, 3351, 2019, 3817,
   963, 3690, 1732, 3270, 3991,  975, 3711,  710, 3466, 2170, 1551, 3865,
  1360,  585, 2150, 3001,  156, 3671,  649, 1391, 2086, 3586, 1116, 2640,
  1872,  561, 3701,   17, 1620, 2871, 2197, 1370, 3229,   73, 2976, 1228,
  2318, 1645, 2496, 1901, 3955,  787, 1680, 2271, 3888,  898, 1988, 3978,
   580, 3517, 1348, 3753, 2500,  708, 3300,  309, 1792, 2672,  123, 3107,
  2300, 1255, 2929,  718, 3140, 2153,  662, 2223, 1885, 2516,  416, 2993,
  1741,  149, 3076,  690, 2566, 3380, 1030, 1626, 3309, 1196, 2286, 3243,
    41, 1642, 2944,  301, 4060, 2278, 1335, 2589, 3455,  465, 3786,  595,
  2080, 4057,  689, 2034, 3629,  851, 3798,  439, 1522, 2405, 3492, 1358,
   526, 3356, 2615, 1059, 2886, 1576, 3094,  491, 1724, 2841, 1421, 2377,
  3781,  880, 3568, 2069, 1008, 3902,  271, 2552, 1867,   72, 3590, 1091,
   277, 3533, 1977, 1053, 3914, 2478, 1104, 3601, 2059,   16, 3815, 2507,
   454, 1979, 4042,  958, 2177, 3847,  755, 3282, 1727,  815, 3067, 1041,
  2001, 2440, 1536, 3030,  989, 2388, 1728, 3206,  380, 3057, 1412, 2213,
  3390, 1190,  178, 2991, 2451, 1601,  369, 3647, 2084,  152, 2355, 1906,
  3383,   38, 4031,  656, 1517, 3006, 1697,  516, 2877,  791, 2710, 1313,
  4047, 1469, 2645, 2073, 2374,  912, 2906, 2188,  556, 1892, 3166,  363,
  1452, 2955, 1764,  837, 3530, 2685,  291, 1897, 2901, 1164, 2602, 1259,
  2408, 3551,  242, 3896,  652, 3316,  145, 1848, 3667,  295, 3510,  891,
  2776, 1875,   44, 3177,  694, 2635, 4052, 2075,  993, 3104, 1866, 2312,
   736, 3319, 1036, 3915, 1163, 2626, 1326, 3167, 2276,  221, 2533, 3481,
  1365, 3668, 1060, 3414,  444, 3010,  842, 3306, 1658, 3954,   34, 3365,
  1605, 3666, 1202, 2387, 3977,  615, 2317, 3093, 1497,  734, 2218, 3613,
   514, 3438,  165, 3755,  484, 1912, 2854, 1414, 2761, 1186, 3975, 2302,
  1146, 2714, 1512, 2532, 1125, 3996, 2129, 1621, 3682, 1974, 1386,  628,
  3760,   23, 3429,  950, 4072, 1484, 2769,  328, 2978,  760, 3609,  452,
  1831, 3846, 1105, 1990, 2347,   20, 3196, 1824, 2400, 1623, 3850,  536,
  2950, 1261, 2575, 1381, 2660,  248, 2862,  855, 2106, 3222, 1309,  237,
  3764, 1826, 3186, 1057, 2765, 1544, 3163, 2205, 1485, 3101,  931, 2622,
   351, 3151, 2097,  517, 3391,  719, 3864,  160, 3431,  624, 2964,  482,
  2337,  246, 3257, 2541, 1471, 2652, 1238, 2734,  267, 2553,  839, 3702,
  1810, 2391, 1667, 2123, 3069,  635, 3363,  391, 3985, 1756, 2246,  587,
  3100,  172, 2261, 1921,  321, 3703,  751, 3483,  960, 4053, 1695, 3557,
   135, 1871, 3889, 2450,  896, 2849,   84, 3966, 2133,  861, 2011,  604,
  4019,   71, 3496, 1677, 3811,  901, 1738, 2884, 1457, 2426, 1319, 2913,
  1765, 2674, 1434, 3832,  945, 3543, 1825,  396, 3477,  704, 3813, 1735,
  3242, 1207, 3082, 2189,  607, 3446,  191, 3967,  983, 2801, 1490, 2667,
  1226, 3034,  940, 3790, 1171, 3617, 1372, 3398, 2757, 1099, 2423,  394,
  3015, 1904,  520, 2537, 1523, 2802,  546, 1714, 3448, 1340, 2579, 1860,
   410, 3692, 2718, 1394, 2486, 1800, 2262,  672, 2349, 1931, 3713,   32,
  3566,  427, 3277,  762, 2328,  284, 3157, 1249, 2750, 1338, 3002, 2280,
  1126, 2909, 2164,  502, 1919, 3862,   76, 1616, 3199, 1405, 2697, 1246,
  2456,   87, 3252,  686, 3545,  239, 2513, 1588, 2830,  724, 2625,  988,
  1492, 3266, 1766, 3803, 1303, 2290, 3337, 1037, 3047,  933, 3630, 2274,
   323, 3135,  663, 3514, 1636, 2301,  225, 3329,  792, 3636, 1119, 3255,
   210, 2928,  805, 2550, 1356, 2657, 1659, 4035, 1204, 3716,  824, 2464,
    81, 3921,  544, 1710, 4002,  140, 1557, 3674, 2436, 1087, 2815, 2045,
   407, 3763,  776, 3512, 1563, 3725, 1154, 2006, 2270, 1716, 3923,  343,
  1947, 3474,  102, 4070, 2306,  188, 2684,  633, 2890,   75, 2007, 3723,
   370, 3278, 1994, 1182, 4081, 1483, 2787, 1208, 3059,  949, 3924, 1708,
  2951,  333, 2795, 1568, 4088, 1385, 3467, 1052, 3939,  578, 3040,  122,
  2727, 1502, 3413, 1649, 3215, 1098, 2057, 3136,  925, 2522, 3334, 1362,
   340, 3554,  860, 4023, 2326, 1290, 2586,  294, 2942,  807, 2642, 4089,
   477, 3129,  876, 2332, 3172, 1279, 2548,  797, 1687, 3885, 1403, 3405,
  1187, 3932,  767, 2253, 1780, 2364,   46, 2925,  747, 2462,  181, 3799,
   495, 2613, 2023, 1045, 2212, 3835,  985, 2571,  750, 2449,  368, 3120,
  2227, 1549, 2160, 3350, 1004, 2560,  324, 2832,  590, 3661, 2420,  304,
  3495, 1794,  570, 2780, 2135, 1758, 3178,  551, 1889, 3041,  955, 3377,
  1786, 2316,  161, 1529, 2872, 1308, 3632, 1879,  528, 3757, 1051, 3353,
  2636,  688, 2393,  310, 2733, 1665, 3205, 1350, 3998, 1110, 3430, 1612,
  3707, 1140, 3360, 2157, 1553, 3237,    5, 3572,  549, 1877, 3298,  107,
  3400, 1473, 2744, 1903,  233, 3789,  864, 1894, 3588,  706, 3970, 1065,
  2298, 1936, 1293, 2855, 1169, 2263, 3899,  883, 3054,  167, 2476, 1547,
  3502,    7, 3893, 2173, 1070, 3801, 1923, 3343,  929, 2578,   53, 2799,
  1540, 2136, 2914,  431, 1315, 3458, 1594, 3652,  811, 2490,  231, 2783,
   469, 2648,  696, 2557,  347, 2678, 1749,  597, 4011, 1330, 2088, 2526,
  1586, 2700, 1306, 2866, 1214, 3887,  882, 3616, 1284, 2102, 2981,  405,
  2024, 3108, 1722, 2078, 3073,  200, 4080,  668, 3625,   51, 1978, 3263,
  1455, 3956,  964, 2869, 1198, 2729, 1730,  426, 3273,  645, 2763,  354,
  3836, 1851, 3435,  835, 4018,  213, 1774, 3688, 2997,    9, 2823,  999,
  2959, 1272, 3780, 1080, 3501, 1444, 3841, 1234, 3227,  924, 3037, 1918,
  2371,  387, 3459,  701, 3697,  286, 3980,  623, 2288,  456, 3017, 1596,
  3224,  638, 2255, 3731, 1195, 2401,   11, 3771,  801, 3325, 1422, 2568,
  1592, 2936,  788, 2372,  447, 2052, 3311,  365, 3680,  618, 2116, 2969,
  1440, 2527, 1354, 3149, 1648,  599, 2234, 3056, 1199, 3249, 2344,  906,
  2065, 1431, 2219, 4030,  411, 3284, 1882, 2415,  639, 3085,  162, 2258,
  1869, 3948,  100, 3642,  841, 2740, 1429, 2903, 1143, 3127, 2140, 1668,
  3180, 1808, 2378,   60, 1852, 4064, 1493,  176, 3204,  974, 2879, 1465,
  2491, 1032, 2789,  467, 3294, 1221, 3793, 1644, 3539, 1136, 2279, 1819,
  2409, 1581, 4038, 1017, 3591,  110, 3994,  745, 2109, 3670, 1453,  402,
  2656, 1909,  566, 3963,  334, 3582,  654, 1787, 2675, 1516,  111, 3368,
  2020, 1569, 2746, 3597,  530, 1654, 2836, 1402, 3326, 1071, 3772,  144,
  2404, 1962,  875, 3516,  198, 3808,  809, 3547, 2505,  497, 2804, 2210,
  1686, 3907,  678, 3469,  374, 3579, 1998, 3827,  903, 2446,  227, 2664,
   712, 2915,   96, 3854,  738, 3162,  217, 2704,  816, 2923, 1173, 2365,
  3012,  184, 2028, 3876, 1086, 3525, 1630, 2474, 3314, 1550, 2162, 3232,
  1025, 3860, 2111,  869, 4058,  437, 2076, 1334, 2191, 3486, 1123, 2497,
   313, 2962, 2181, 1700, 3877,  430, 2824, 1270, 2592, 1172, 2875, 2049,
  1131, 3063, 1337, 3658,  434, 1865, 2604, 1376, 2738, 1633,  118, 1811,
  3027, 1507, 3441, 1382, 4055, 1300, 3364, 1055, 2612, 1274, 3460, 2196,
  1627, 2056, 3538,  487, 1419, 3287, 2509,  664, 2742,  121, 3116,  853,
  1838,  534, 3768,  171, 2563,  569, 3109, 2336, 1191, 2587, 3741,  818,
  2940,  244, 2695,  722, 4068, 1935,  564, 3165,  826, 3374, 1625, 4045,
   709, 3443, 1781,  274, 3869,  754, 3387,  953, 2085, 3007,  220, 3239,
   612, 4027, 2178, 3220,  329, 2616,  646, 2846,  382, 2338, 1911, 3121,
   308, 2827, 1779,  539, 3750,  317, 2591, 1864, 3945,  884, 1699, 3412,
  1257, 3734, 1141, 2883, 3909, 2531, 1211, 2985, 1411, 3637, 1696,  279,
  3553, 1643,   25, 3303, 1817, 3917, 1016, 3275, 2265,  961, 3660, 1514,
  2058, 2512,   35, 2195, 2972,  474, 2305, 3308, 1442, 2610,   94, 2392,
  4001, 1277, 3562, 1113, 1975, 2556, 1314,  834, 3934, 1013, 3606, 2115,
  1789, 3729,  562, 1671, 3641, 1109, 3919, 2252, 1399, 3328,  850, 3086,
    29, 2811, 2149,  293, 2443, 1750, 2319,  260,  951, 1938, 3515,  740,
  2774,  941, 2039, 3008, 1100, 3138, 1907, 2358,  609, 1466, 2895, 1847,
    65, 2113, 2569,  262, 3046, 1294, 3623, 1033, 1711, 3722, 1509,  887,
  2759, 1064, 3218, 1927,  519, 2707,  821, 2293, 3402,  418, 3695, 2367,
  1427, 2894, 1681,   30, 2995, 1178, 2770, 2141,  700, 2498,   63, 3043,
   915, 2009, 2463, 1475, 3783, 1047, 3569, 1526, 4077,  507, 3444, 1999,
  3261,   56, 2225, 3192,  366, 2381, 3987,  783, 2752,  500, 3882,  972,
  3518, 2098,  417, 3791, 1602, 3427, 1241, 3990,  739, 3290,  524, 2032,
  2777,  139, 2459, 4017,  342, 3633, 2169, 1180, 3336, 1614, 3743,   57,
  1532, 2967, 1785,  170, 3498,  499, 2199, 3871,  848, 3396,  187, 3824,
  1461, 3281, 2035, 1542, 4065,  201, 3494,  584, 1813, 2715,  716, 2990,
  1357, 2858, 1067, 2606, 1463, 4044, 1611,  881, 3681, 1844,   90, 3221,
  1288, 2482, 1501, 2630,  190, 3160, 2410, 1302, 2670,  488, 2921, 1010,
  2798, 1380, 2427, 3937,  967, 3267, 1762,  684, 2889, 1830,  601, 3839,
   247, 2632, 1219, 2479, 3897,  731, 2267, 3145, 1120, 1961, 3260, 1250,
  2483, 1572, 2601,  970, 2902,  435, 3598,  677, 2222, 2844, 1117, 3184,
  2395,  338, 3341, 2122,   80, 2248, 3821,  390, 2918,  593, 2071, 3080,
  1223, 2868, 1451, 2179, 3804,  268, 3403, 1232, 4022, 1691,  766, 3577,
   934, 3853, 1729, 2315,  155, 3759, 1790,  319, 3019, 1353, 3535, 2070,
  1092, 3114, 1561, 2236, 3035,  892, 3269,  554, 1821, 2864, 1410,  630,
  4093, 2573,  764, 2751,  397, 4009,  603, 3526, 1743, 2375, 1078, 3098,
  1688,  523, 3717, 2083, 1194, 3969, 1638, 1005, 3648, 1829,  774, 2186,
   979, 3619, 2662,  226, 3926,  707, 3453,  462, 1759, 2683,  825, 2856,
   540, 2043, 2996,  125, 3190, 1893,  361, 3491, 1993, 1076, 3132, 2268,
   784, 2639,  258, 2366, 3767,   22, 3473,  463, 1956, 3940, 1488, 2137,
  3487,  264, 3653, 2421, 1725,  101, 3712, 1479, 3039, 1095, 3159, 2158,
   126, 3976, 1965,  287, 3856, 2627, 1840,  131, 3021,  780, 2538, 2938,
   547, 3144, 1558, 3489, 2460, 1823, 1049, 1959, 2311, 1578, 2515, 1916,
  3250, 1137, 3748, 1373, 2304, 3673, 1026, 2649, 1176, 2346, 3065,  830,
  2543, 3559,  636, 1673, 3409, 1258, 3968,  942, 1942, 2698, 1305, 2840,
   771, 2441,  133, 2930, 1044, 2724, 1606,  440, 3313, 2131,  900, 3421,
   234, 2406, 1932, 1328, 2794, 1227, 3191, 2524, 1347,  838, 3357, 1491,
  2256, 3605,  238, 1954, 4014, 1282, 2619,  141, 3382,  433, 3829, 2702,
   511, 3561,  150, 4095,  676, 2430,   40, 2957, 1807,  330, 3349, 1537,
  3930,  651, 1647, 4084, 1477,  398, 2398, 3892,   79, 2817, 1518, 3207,
   658, 2198, 4075, 1023, 3587, 1690, 3417, 1242, 3988,  793, 2061, 3818,
  1151, 2821, 1799, 2310, 1389, 3785,  489, 3476,  865, 3694,  725, 1635,
  3552, 2209,  450, 3901,  938, 1878, 3208,  899, 2386,  352, 3774, 2114,
  1312, 2931, 2095,  927, 3169, 1184, 2790, 1359, 3031, 1599, 3478, 1090,
  3833, 2251,  863, 2585,  253, 3399, 2152,   13, 3301, 2716, 1106, 1915,
  3078,  846, 2530,  311, 3685, 1600,  192, 3168, 2081,  359, 2663, 1971,
   480, 3099, 2549,  923, 3060,  296, 3962,  576, 3293, 2041, 2851, 1015,
  2643,  250, 2287, 3026,   15, 2813, 1286, 2026, 3068,  606, 2230, 3506,
  1377, 3102, 1719,  685
};

static inline double calculateError(double a, double b)
{
  return std::fabs(a - b);
}

static inline double calculateErrorSqr(double a, double b)
{
  return ((a - b) * (a - b));
}

static inline void limitValue(double& x, double min_, double max_)
{
  if (!(x >= min_ && x <= max_)) {
    if (x < min_)
      x = min_;
    else if (x > max_)
      x = max_;
    else
      x = (min_ + max_) * 0.5;
  }
}

static bool ditherPixelValue(long xc, long yc, double n)
{
  return (n >= ((double(ditherTable[((yc & 63L) << 6)
                                    | (xc & 63L)]) + 0.5) / 4096.0));
}

// ----------------------------------------------------------------------------

class PRGData {
 private:
  static const unsigned char prgHeader[0x0401];
  static const int bitmapOffsetTable[16];
  static const int lumOffsetTable[16];
  static const int clrOffsetTable[16];
  unsigned char   *buf;
 public:
  PRGData();
  virtual ~PRGData();
  inline unsigned char& operator[](long n)
  {
    return buf[n];
  }
  inline unsigned char& bitmap(long n)
  {
    return buf[n + 0x1001L];
  }
  inline unsigned char& bitmap(long xc, long yc)
  {
    return buf[((yc >> 4) * 320L) + (xc & (~(long(7))))
               + bitmapOffsetTable[yc & 15L] - 0x0FFFL];
  }
  inline unsigned char& bitmap0(long xc, long yc)
  {
    return bitmap(xc, yc & (~(long(2))));
  }
  inline unsigned char& bitmap1(long xc, long yc)
  {
    return bitmap(xc, yc | 2L);
  }
  inline unsigned char& luminance(long xc, long yc)
  {
    return buf[((yc >> 4) * 40L) + (xc >> 3)
               + lumOffsetTable[yc & 15L] - 0x0FFFL];
  }
  inline unsigned char& color(long xc, long yc)
  {
    return buf[((yc >> 4) * 40L) + (xc >> 3)
               + clrOffsetTable[yc & 15L] - 0x0FFFL];
  }
  inline unsigned char& borderColor()
  {
    return buf[0x0500L];
  }
  inline unsigned char& interlaceDisabled()
  {
    return buf[0x0800L];
  }
  inline unsigned char& lineColor0(long yc)
  {
    return buf[(0x0400L | ((yc & 1L) << 8) | ((yc & (~(long(3)))) >> 1)) + 1L];
  }
  inline unsigned char& lineColor1(long yc)
  {
    return buf[(0x0400L | ((yc & 1L) << 8) | ((yc & (~(long(3)))) >> 1)) + 2L];
  }
  inline unsigned char& lineXShift(long yc)
  {
    return buf[(0x0600L | ((yc & 1L) << 8) | (yc >> 1)) + 1L];
  }
  inline bool getPixel(long xc, long yc)
  {
    unsigned char   mask_ = (unsigned char) (1 << (7 - int(xc & 7L)));
    unsigned char&  b = this->bitmap(xc, yc);
    return bool(b & mask_);
  }
  inline void setPixel(long xc, long yc, bool n)
  {
    unsigned char   mask_ = (unsigned char) (1 << (7 - int(xc & 7L)));
    unsigned char&  b = this->bitmap(xc, yc);
    if (n)
      b |= mask_;
    else
      b &= (~mask_);
  }
};

const unsigned char PRGData::prgHeader[0x0401] = {
  0x01, 0x10, 0x0C, 0x10, 0x0A, 0x00, 0x9E, 0x20, 0x34, 0x31, 0x31, 0x32,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0xD8, 0xA2, 0xFF, 0x9A, 0x20, 0x80,
  0x11, 0xA9, 0x00, 0x8D, 0x15, 0xFF, 0x8D, 0x16, 0xFF, 0xA9, 0xF0, 0x8D,
  0xFC, 0xFF, 0xA9, 0x10, 0x8D, 0xFD, 0xFF, 0xA9, 0x00, 0x8D, 0xFE, 0xFF,
  0xA9, 0x11, 0x8D, 0xFF, 0xFF, 0xA9, 0x36, 0x8D, 0x0B, 0xFF, 0xA9, 0xA3,
  0x8D, 0x0A, 0xFF, 0xA9, 0xFF, 0x8D, 0x09, 0xFF, 0x8D, 0x3F, 0xFF, 0x58,
  0xA2, 0xFF, 0xA0, 0xFF, 0xA9, 0xD8, 0xCD, 0x1D, 0xFF, 0xD0, 0xFB, 0x98,
  0xAA, 0xA9, 0x7F, 0x8D, 0x30, 0xFD, 0x8D, 0x08, 0xFF, 0xAD, 0x08, 0xFF,
  0x29, 0x10, 0xA8, 0xE0, 0x10, 0xD0, 0xE5, 0xC0, 0x00, 0xD0, 0xE1, 0x78,
  0x8D, 0x3E, 0xFF, 0x6C, 0xFE, 0x10, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0x2C, 0x07, 0xFF,
  0x70, 0x03, 0xA9, 0xFF, 0x2C, 0xA9, 0xE6, 0xCD, 0x1D, 0xFF, 0xD0, 0xFB,
  0x20, 0x84, 0xFF, 0xAD, 0xFF, 0x14, 0x8D, 0x19, 0xFF, 0x2C, 0x07, 0xFF,
  0x70, 0x15, 0xA9, 0x36, 0x8D, 0x35, 0x10, 0x8D, 0x35, 0x12, 0x8D, 0x56,
  0x13, 0xA2, 0xF9, 0x8E, 0x35, 0x11, 0xE8, 0x8E, 0x08, 0x13, 0x60, 0xA9,
  0x04, 0x8D, 0x35, 0x10, 0x8D, 0x35, 0x12, 0x8D, 0x56, 0x13, 0xA2, 0xE0,
  0x8E, 0x35, 0x11, 0xE8, 0x8E, 0x08, 0x13, 0x60, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0x78, 0x8D, 0x3E, 0xFF, 0x6C, 0xFC, 0xFF, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0x10, 0x10, 0x48, 0x8A, 0x48, 0x98, 0x48, 0xA9, 0xC8,
  0x8D, 0x12, 0xFF, 0xA9, 0x02, 0xCD, 0x1D, 0xFF, 0xD0, 0xFB, 0xEA, 0xEA,
  0xAD, 0x1E, 0xFF, 0x29, 0x1C, 0x4A, 0x4A, 0x8D, 0x1E, 0x11, 0x10, 0x00,
  0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA5, 0xEA, 0xA2, 0x01, 0xCA, 0xD0,
  0xFD, 0xA9, 0x00, 0xA9, 0x00, 0xEA, 0x20, 0x00, 0x98, 0xA9, 0xF9, 0x8D,
  0x0B, 0xFF, 0xA9, 0xA2, 0x8D, 0x0A, 0xFF, 0xA9, 0xFF, 0x8D, 0x09, 0xFF,
  0xA9, 0x00, 0x8D, 0xFE, 0xFF, 0xA9, 0x13, 0x8D, 0xFF, 0xFF, 0x68, 0xA8,
  0x68, 0xAA, 0x68, 0x40, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xA9, 0xE0, 0xCD, 0x1D, 0xFF, 0xD0, 0xFB, 0x20, 0x80, 0x10, 0xA9,
  0x0B, 0x8D, 0x06, 0xFF, 0xAD, 0x07, 0xFF, 0x29, 0x40, 0x85, 0xE0, 0xA9,
  0x00, 0xAA, 0x1D, 0x00, 0x16, 0x1D, 0x00, 0x17, 0xE8, 0xE0, 0xC8, 0xD0,
  0xF5, 0x29, 0x07, 0xC9, 0x01, 0xA9, 0xFF, 0x69, 0x00, 0x29, 0x08, 0x05,
  0xE0, 0x85, 0xE0, 0xA2, 0x00, 0xBD, 0xFF, 0x15, 0x29, 0x17, 0x05, 0xE0,
  0x9D, 0xFF, 0x15, 0xBD, 0xFF, 0x16, 0x29, 0x07, 0x05, 0xE0, 0x9D, 0xFF,
  0x16, 0xE8, 0xD0, 0xE9, 0xA2, 0x00, 0x20, 0x70, 0x13, 0xA2, 0x01, 0x20,
  0x70, 0x13, 0xAD, 0xFF, 0x17, 0xD0, 0x08, 0xA9, 0x8E, 0xA2, 0x8D, 0xA0,
  0xCE, 0xD0, 0x04, 0xA9, 0x2C, 0xAA, 0xA8, 0x8D, 0x21, 0x13, 0x8E, 0x3A,
  0x13, 0x8C, 0x52, 0x13, 0xA9, 0xE0, 0xCD, 0x1D, 0xFF, 0xD0, 0xFB, 0xA9,
  0x3B, 0x8D, 0x06, 0xFF, 0x60, 0xEA, 0xEA, 0xEA, 0xEA, 0x48, 0x8A, 0x48,
  0x98, 0x48, 0xA9, 0xD0, 0x8D, 0x12, 0xFF, 0xA9, 0x02, 0xCD, 0x1D, 0xFF,
  0xD0, 0xFB, 0xEA, 0xEA, 0xAD, 0x1E, 0xFF, 0x29, 0x1C, 0x4A, 0x4A, 0x8D,
  0x1E, 0x12, 0x10, 0x00, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA5, 0xEA,
  0xA2, 0x01, 0xCA, 0xD0, 0xFD, 0xA9, 0x00, 0xA9, 0x00, 0xEA, 0x20, 0x00,
  0xA6, 0xA9, 0x36, 0x8D, 0x0B, 0xFF, 0xA9, 0xA3, 0x8D, 0x0A, 0xFF, 0xA9,
  0xFF, 0x8D, 0x09, 0xFF, 0xA9, 0x00, 0x8D, 0xFE, 0xFF, 0xA9, 0x11, 0x8D,
  0xFF, 0xFF, 0x68, 0xA8, 0x68, 0xAA, 0x68, 0x40, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xA5, 0xDC, 0x29, 0x03, 0x0A, 0xA8, 0xB1,
  0xE0, 0xAA, 0xC8, 0xB1, 0xE0, 0x48, 0x8A, 0xA0, 0x00, 0xA2, 0x06, 0x20,
  0xC5, 0x13, 0x68, 0xA2, 0x14, 0x20, 0xC5, 0x13, 0xA5, 0xDC, 0x0A, 0xA8,
  0xB1, 0xD8, 0xA0, 0x00, 0xA2, 0x07, 0x20, 0xC5, 0x13, 0x20, 0xBA, 0x13,
  0x60, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xA5, 0xDC, 0x0A,
  0xA8, 0xB1, 0xDA, 0xAA, 0xC8, 0xB1, 0xD8, 0x48, 0xB1, 0xDA, 0x48, 0x8A,
  0xA0, 0x00, 0xA2, 0x15, 0x20, 0xC5, 0x13, 0x68, 0xA2, 0x16, 0x20, 0xC5,
  0x13, 0x68, 0xA2, 0x07, 0x20, 0xC5, 0x13, 0x20, 0xBA, 0x13, 0x60, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0x48, 0x8A, 0x48, 0x98, 0x48, 0xA2, 0x6F, 0xA9, 0xFA, 0xCD, 0x1D,
  0xFF, 0xD0, 0xFB, 0xAD, 0x1E, 0xFF, 0x4A, 0x29, 0x07, 0x8D, 0x18, 0x13,
  0x10, 0x00, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0x24, 0xEA, 0x2C, 0x1E,
  0xFF, 0xA0, 0x05, 0xD0, 0x01, 0xEA, 0xA2, 0x14, 0xCA, 0xD0, 0xFD, 0xEA,
  0xEA, 0x88, 0xD0, 0xF6, 0xA9, 0xAF, 0xA2, 0x00, 0x8E, 0xFE, 0xFF, 0x2C,
  0x1E, 0xFF, 0xCE, 0x09, 0xFF, 0xA9, 0x12, 0x8D, 0xFF, 0xFF, 0xA2, 0x05,
  0xAD, 0x1D, 0xFF, 0xCD, 0x1D, 0xFF, 0xF0, 0xFB, 0xCA, 0xD0, 0xF5, 0x2C,
  0x1D, 0xFF, 0xA9, 0x36, 0x8D, 0x0B, 0xFF, 0xA9, 0xA3, 0x8D, 0x0A, 0xFF,
  0x68, 0xA8, 0x68, 0xAA, 0x68, 0x40, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
  0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0x8A, 0x09, 0x16, 0x85, 0xD9, 0x09, 0x14,
  0x85, 0xDB, 0xA0, 0x00, 0x84, 0xD8, 0x84, 0xDA, 0x8A, 0x49, 0xFF, 0x18,
  0x69, 0x01, 0x29, 0x0E, 0x18, 0x69, 0x98, 0x85, 0xDF, 0x84, 0xDE, 0xA9,
  0x00, 0x85, 0xDC, 0x8A, 0x0A, 0x0A, 0x0A, 0x09, 0xF0, 0x85, 0xE0, 0xA9,
  0x13, 0x85, 0xE1, 0xC6, 0xD8, 0xC6, 0xD9, 0x20, 0x80, 0x12, 0x20, 0xC0,
  0x12, 0xE6, 0xDC, 0xA5, 0xDC, 0xC9, 0x64, 0xD0, 0xF2, 0x20, 0x80, 0x12,
  0xA9, 0x60, 0x20, 0xE7, 0x13, 0x60, 0xEA, 0xA9, 0xEA, 0x20, 0xE7, 0x13,
  0xA9, 0xEA, 0x20, 0xE7, 0x13, 0x60, 0x48, 0xA9, 0xA9, 0x20, 0xE7, 0x13,
  0x68, 0x20, 0xE7, 0x13, 0xA9, 0x8D, 0x20, 0xE7, 0x13, 0x8A, 0x20, 0xE7,
  0x13, 0xA9, 0xFF, 0x20, 0xE7, 0x13, 0x60, 0xA1, 0x00, 0xF6, 0x00, 0xD0,
  0x02, 0xF6, 0x01, 0x60, 0x91, 0xDE, 0xE6, 0xDE, 0xD0, 0x02, 0xE6, 0xDF,
  0x60, 0x3B, 0x18, 0x3D, 0x60, 0x3F, 0x68, 0x39, 0x70, 0x3B, 0x78, 0x3D,
  0x80, 0x3F, 0x88, 0x39, 0x90
};

const int PRGData::bitmapOffsetTable[16] = {
  0x2000, 0x4000, 0x2001, 0x4001, 0x2002, 0x4002, 0x2003, 0x4003,
  0x2004, 0x4004, 0x2005, 0x4005, 0x2006, 0x4006, 0x2007, 0x4007
};

const int PRGData::lumOffsetTable[16] = {
  0x1800, 0x7800, 0x1800, 0x7800, 0x6000, 0x8000, 0x6000, 0x8000,
  0x6800, 0x8800, 0x6800, 0x8800, 0x7000, 0x9000, 0x7000, 0x9000
};

const int PRGData::clrOffsetTable[16] = {
  0x1C00, 0x7C00, 0x1C00, 0x7C00, 0x6400, 0x8400, 0x6400, 0x8400,
  0x6C00, 0x8C00, 0x6C00, 0x8C00, 0x7400, 0x9400, 0x7400, 0x9400
};

PRGData::PRGData()
{
  buf = new unsigned char[0x8801];
  for (size_t i = 0x0000; i < 0x0401; i++)
    buf[i] = prgHeader[i];
  for (size_t i = 0x0401; i < 0x8801; i++)
    buf[i] = 0x00;
}

PRGData::~PRGData()
{
  delete[] buf;
}

// ----------------------------------------------------------------------------

class LuminanceCodeTable {
 private:
  int     *buf;
 public:
  LuminanceCodeTable();
  virtual ~LuminanceCodeTable();
  inline int& l0(long xc, long yc)
  {
    return buf[((((yc & (~(long(3)))) >> 1) | (yc & 1L)) * 80L)
               + ((xc >> 3) << 1) + 0L];
  }
  inline int& l1(long xc, long yc)
  {
    return buf[((((yc & (~(long(3)))) >> 1) | (yc & 1L)) * 80L)
               + ((xc >> 3) << 1) + 1L];
  }
  inline unsigned char luminanceCode(long xc, long yc)
  {
    int     l0_ = this->l0(xc, yc);
    int     l1_ = this->l1(xc, yc);
    if (l0_ > 0)
      l0_--;
    if (l1_ > 0)
      l1_--;
    return (unsigned char) ((l0_ << 4) | l1_);
  }
};

LuminanceCodeTable::LuminanceCodeTable()
{
  buf = new int[40 * 200 * 2];
  for (int i = 0; i < (40 * 200 * 2); i++)
    buf[i] = 0;
}

LuminanceCodeTable::~LuminanceCodeTable()
{
  delete[] buf;
}

// ----------------------------------------------------------------------------

class RGB24Image640x400 {
 private:
  unsigned char *buf;
 public:
  RGB24Image640x400();
  RGB24Image640x400(const RGB24Image640x400& r);
  virtual ~RGB24Image640x400();
  RGB24Image640x400& operator=(const RGB24Image640x400& r);
  inline unsigned char& operator[](long n)
  {
    return buf[n];
  }
  inline unsigned char& pixelR(long x, long y)
  {
    return buf[(((y * 640L) + x) * 3L) + 0L];
  }
  inline unsigned char& pixelG(long x, long y)
  {
    return buf[(((y * 640L) + x) * 3L) + 1L];
  }
  inline unsigned char& pixelB(long x, long y)
  {
    return buf[(((y * 640L) + x) * 3L) + 2L];
  }
};

RGB24Image640x400::RGB24Image640x400()
{
  buf = new unsigned char[640 * 400 * 3];
  for (size_t i = 0; i < (640 * 400 * 3); i++)
    buf[i] = 0x00;
}

RGB24Image640x400::RGB24Image640x400(const RGB24Image640x400& r)
{
  buf = new unsigned char[640 * 400 * 3];
  for (size_t i = 0; i < (640 * 400 * 3); i++)
    buf[i] = r.buf[i];
}

RGB24Image640x400& RGB24Image640x400::operator=(const RGB24Image640x400& r)
{
  for (size_t i = 0; i < (640 * 400 * 3); i++)
    buf[i] = r.buf[i];
  return (*this);
}

RGB24Image640x400::~RGB24Image640x400()
{
  delete[] buf;
}

// ----------------------------------------------------------------------------

class Line320 {
 private:
  float   *buf;
  int     xShift;
  bool    multiColorFlag;
 public:
  Line320();
  Line320(const Line320& r);
  virtual ~Line320();
  Line320& operator=(const Line320& r);
  void clear();
  inline float& operator[](long n)
  {
    return buf[n];
  }
  inline float& pixel(long x)
  {
    return buf[x];
  }
  inline float& pixelShifted(long x)
  {
    return buf[x + xShift];
  }
  inline float getPixel(long x) const
  {
    if (x < 0L || x >= 320L)
      return 0.0f;
    return buf[x];
  }
  inline float getPixelShifted(long x) const
  {
    long    x_ = x + xShift;
    if (x_ < 0L || x_ >= 320L)
      return 0.0f;
    return buf[x_];
  }
  inline void setPixel(long x, float n)
  {
    if (x >= 0L && x < 320L)
      buf[x] = n;
  }
  inline void setPixelShifted(long x, float n)
  {
    long    x_ = x + xShift;
    if (x_ >= 0L && x_ < 320L)
      buf[x_] = n;
  }
  inline int getXShift() const
  {
    return xShift;
  }
  inline void setXShift(int n)
  {
    xShift = n & 7;
  }
  inline bool getMultiColorFlag() const
  {
    return multiColorFlag;
  }
  inline void setMultiColorFlag(bool n)
  {
    multiColorFlag = n;
  }
};

Line320::Line320()
  : xShift(0),
    multiColorFlag(false)
{
  buf = new float[320];
  for (size_t i = 0; i < 320; i++)
    buf[i] = 0.0f;
}

Line320::Line320(const Line320& r)
  : xShift(r.xShift),
    multiColorFlag(r.multiColorFlag)
{
  buf = new float[320];
  for (size_t i = 0; i < 320; i++)
    buf[i] = r.buf[i];
}

Line320& Line320::operator=(const Line320& r)
{
  xShift = r.xShift;
  multiColorFlag = r.multiColorFlag;
  for (size_t i = 0; i < 320; i++)
    buf[i] = r.buf[i];
  return (*this);
}

void Line320::clear()
{
  for (size_t i = 0; i < 320; i++)
    buf[i] = 0.0f;
}

Line320::~Line320()
{
  delete[] buf;
}

// ----------------------------------------------------------------------------

class Image320x400 {
 private:
  Line320 *buf;
 public:
  Image320x400();
  Image320x400(const Image320x400& r);
  virtual ~Image320x400();
  Image320x400& operator=(const Image320x400& r);
  inline Line320& operator[](long n)
  {
    return buf[n];
  }
};

Image320x400::Image320x400()
{
  buf = new Line320[400];
}

Image320x400::Image320x400(const Image320x400& r)
{
  buf = new Line320[400];
  for (size_t i = 0; i < 400; i++)
    buf[i] = r.buf[i];
}

Image320x400& Image320x400::operator=(const Image320x400& r)
{
  for (size_t i = 0; i < 400; i++)
    buf[i] = r.buf[i];
  return (*this);
}

Image320x400::~Image320x400()
{
  delete[] buf;
}

// ----------------------------------------------------------------------------

class YUVImage320x400 {
 private:
  Image320x400  imageY;
  Image320x400  imageU;
  Image320x400  imageV;
 public:
  YUVImage320x400();
  YUVImage320x400(const YUVImage320x400& r);
  virtual ~YUVImage320x400();
  YUVImage320x400& operator=(const YUVImage320x400& r);
  inline Image320x400& y()
  {
    return imageY;
  }
  inline Image320x400& u()
  {
    return imageU;
  }
  inline Image320x400& v()
  {
    return imageV;
  }
};

YUVImage320x400::YUVImage320x400()
{
}

YUVImage320x400::YUVImage320x400(const YUVImage320x400& r)
  : imageY(r.imageY),
    imageU(r.imageU),
    imageV(r.imageV)
{
}

YUVImage320x400::~YUVImage320x400()
{
}

YUVImage320x400& YUVImage320x400::operator=(const YUVImage320x400& r)
{
  imageY = r.imageY;
  imageU = r.imageU;
  imageV = r.imageV;
  return (*this);
}

// ----------------------------------------------------------------------------

class Plus4FLIConverter {
 public:
  double  yMin;
  double  yMax;
  double  colorSaturationMult;
  double  colorSaturationPow;
  double  monitorGamma;
  double  ditherLimit;
  double  ditherScale;
  int     ditherMode;
  int     luminanceSearchMode;
  int     xShift0;
  int     xShift1;
  int     borderColor;
  bool    disablePAL;
  bool    disableInterlace;
  bool    luminance1BitMode;
  bool    noFLIDisplayCode;
  bool    noLuminanceInterlace;
 private:
  struct UVTableEntry {
    int     c0;
    int     c1;
    float   u;
    float   v;
  };
  static const float  yTableSrc[9];
  static const float  colorPhaseTablePAL[16];
  float               yTable[9];
  UVTableEntry        uvTable[43];
  PRGData             prgData;
  RGB24Image640x400   inputImage;
  YUVImage320x400     resizedImage;
  Image320x400        ditherErrorImage;
  LuminanceCodeTable  luminanceCodeTable;
  Line320 prvLineU;
  Line320 prvLineV;
  Line320 line0U;
  Line320 line0V;
  Line320 line1U;
  Line320 line1V;
  // ----------------
  void colorToUV(int c, float& u, float& v);
  void createYTable();
  void createUVTables();
  void checkParameters();
  void ditherPixel(long xc, long yc);
  inline double calculateLuminanceError(float n, int l0, int l1);
  double findLuminanceCodes(long xc, long yc);
  void generateBitmaps();
  void findColorCodes(long xc, long yc, int dir_);
 public:
  Plus4FLIConverter();
  virtual ~Plus4FLIConverter();
  int processImage(const char *infileName, const char *outfileName);
};

const float Plus4FLIConverter::yTableSrc[9] = {
  2.00f,  2.40f,  2.55f,  2.70f,  2.90f,  3.30f,  3.60f,  4.10f,  4.80f
};

const float Plus4FLIConverter::colorPhaseTablePAL[16] = {
    0.0f,    0.0f,  103.0f,  283.0f,   53.0f,  241.0f,  347.0f,  167.0f,
  129.0f,  148.0f,  195.0f,   83.0f,  265.0f,  323.0f,    3.0f,  213.0f
};

Plus4FLIConverter::Plus4FLIConverter()
  : yMin(0.0),
    yMax(1.0),
    colorSaturationMult(1.0),
    colorSaturationPow(0.6),
    monitorGamma(1.33),
    ditherLimit(0.125),
    ditherScale(0.5),
    ditherMode(0),
    luminanceSearchMode(4),
    xShift0(-1),
    xShift1(-1),
    borderColor(0x00),
    disablePAL(false),
    disableInterlace(false),
    luminance1BitMode(false),
    noFLIDisplayCode(false),
    noLuminanceInterlace(false)
{
  createYTable();
  createUVTables();
}

Plus4FLIConverter::~Plus4FLIConverter()
{
}

void Plus4FLIConverter::colorToUV(int c, float& u, float& v)
{
  u = 0.0f;
  v = 0.0f;
  c = c & 15;
  if (c < 2)
    return;
  u = float(std::cos(colorPhaseTablePAL[c] * 3.14159265 / 180.0) * 0.19);
  v = float(std::sin(colorPhaseTablePAL[c] * 3.14159265 / 180.0) * 0.19);
}

void Plus4FLIConverter::createYTable()
{
  for (int i = 0; i < 9; i++) {
    double  tmp = yTableSrc[i];
    tmp = (tmp - yTableSrc[0]) / (yTableSrc[8] - yTableSrc[0]);
    tmp = (tmp > 0.0 ? (tmp < 1.0 ? tmp : 1.0) : 0.0);
    tmp = std::pow(tmp, monitorGamma);
    yTable[i] = float(tmp);
  }
}

void Plus4FLIConverter::createUVTables()
{
  for (int i = 0; i < 43; i++) {
    int     c0 = i + 1;
    int     c1 = i + 1;
    float   u0 = 0.0f;
    float   v0 = 0.0f;
    float   u1 = 0.0f;
    float   v1 = 0.0f;
    if (i >= 15) {
      c0 = ((i - 15) % 14) + 2;
      c1 = 1;
      colorToUV(c0, u0, v0);
      if (i < 29) {
        float   bestDiff = 1000.0f;
        for (int j = 2; j < 14; j++) {
          colorToUV(j, u1, v1);
          float   d = calculateErrorSqr(u1, u0) + calculateErrorSqr(v1, v0);
          if (d < bestDiff && j != c0) {
            c1 = j;
            bestDiff = d;
          }
        }
      }
    }
    uvTable[i].c0 = c0;
    uvTable[i].c1 = c1;
    colorToUV(c0, u0, v0);
    colorToUV(c1, u1, v1);
    uvTable[i].u = (u0 + u1) * 0.5f;
    uvTable[i].v = (v0 + v1) * 0.5f;
  }
}

void Plus4FLIConverter::checkParameters()
{
  limitValue(yMin, -0.5, 1.0);
  limitValue(yMax, 0.0, 2.0);
  limitValue(colorSaturationMult, 0.0, 8.0);
  limitValue(colorSaturationPow, 0.1, 2.0);
  limitValue(monitorGamma, 0.25, 4.0);
  limitValue(ditherLimit, 0.0, 2.0);
  limitValue(ditherScale, 0.0, 1.0);
  ditherMode = (ditherMode > 0 ? (ditherMode < 1 ? ditherMode : 1) : 0);
  luminanceSearchMode = (luminanceSearchMode > 0 ?
                         (luminanceSearchMode < 4 ? luminanceSearchMode : 4)
                         : 0);
  xShift0 = (xShift0 > -2 ? (xShift0 < 7 ? xShift0 : 7) : -2);
  xShift1 = (xShift1 > -2 ? (xShift1 < 7 ? xShift1 : 7) : -2);
  borderColor = (borderColor & 0x7F) | 0x80;
}

void Plus4FLIConverter::ditherPixel(long xc, long yc)
{
  if (xc < 0L || xc >= 320L || yc < 0L || yc >= 400L)
    return;
  long    xcShifted = xc - resizedImage.y()[yc].getXShift();
  if (xcShifted < 0L)
    return;
  int     l0 = luminanceCodeTable.l0(xcShifted, yc);
  int     l1 = luminanceCodeTable.l1(xcShifted, yc);
  float   pixelValueOriginal = resizedImage.y()[yc].getPixel(xc);
  float   ditherError = ditherErrorImage[yc].getPixel(xc);
  float   pixelValueDithered = pixelValueOriginal + ditherError;
  float   pixelValue0 = yTable[l0];
  float   pixelValue1 = yTable[l1];
  bool    bitValue = false;
  if (ditherMode == 0 && pixelValue1 > pixelValue0) {
    // ordered dithering
    float   tmp = pixelValueOriginal;
    if (tmp < pixelValue0)
      tmp = pixelValue0;
    if (tmp > pixelValue1)
      tmp = pixelValue1;
    tmp = (tmp - pixelValue0) / (pixelValue1 - pixelValue0);
    if (ditherPixelValue(xc, yc, tmp))
      pixelValueDithered = pixelValue1;
    else
      pixelValueDithered = pixelValue0;
  }
  if (calculateError(calculateError(pixelValue1, pixelValueOriginal),
                     calculateError(pixelValue0, pixelValueOriginal))
      >= ditherLimit) {
    bitValue = (calculateError(pixelValue1, pixelValueOriginal)
                < calculateError(pixelValue0, pixelValueOriginal));
  }
  else {
    bitValue = (calculateError(pixelValue1, pixelValueDithered)
                < calculateError(pixelValue0, pixelValueDithered));
  }
  prgData.setPixel(xcShifted, yc, bitValue);
  if (ditherMode == 0)
    return;
  // diffuse error
  float   newPixelValue = (bitValue ? pixelValue1 : pixelValue0);
  pixelValueDithered = pixelValueOriginal
                       + ((pixelValueDithered - pixelValueOriginal)
                          * float(ditherScale));
  if (pixelValueDithered < pixelValue0)
    pixelValueDithered = pixelValue0;
  if (pixelValueDithered > pixelValue1)
    pixelValueDithered = pixelValue1;
  double  err = double(pixelValueDithered) - double(newPixelValue);
  for (int i = 0; i < 3; i++) {
    long    yc_ = yc + i;
    if (yc_ >= 400L)
      break;
    for (int j = (i == 0 ? 1 : -2); j < 3; j++) {
      long    xc_ = j;
      if (yc & 1L)
        xc_ = -xc_;
      xc_ += xc;
      int     tmp = 16 >> (i + (j >= 0 ? j : (-j)));
      ditherErrorImage[yc_].setPixel(xc_, ditherErrorImage[yc_].getPixel(xc_)
                                          + float(err * (double(tmp) / 42.0)));
    }
  }
}

inline double Plus4FLIConverter::calculateLuminanceError(
    float n, int l0, int l1)
{
  float   l_0 = yTable[l0];
  float   l_1 = yTable[l1];
  double  err0 = calculateErrorSqr(l_0, n);
  double  err1 = calculateErrorSqr(l_1, n);
  double  err = (err0 < err1 ? err0 : err1);
  switch (luminanceSearchMode) {
  case 2:
    return (n < l_0 || n > l_1 ? (err * 6.0) : err);
  case 4:
    {
      float   l_037 = (l_0 * 0.63f) + (l_1 * 0.37f);
      float   l_063 = (l_0 * 0.37f) + (l_1 * 0.63f);
      double  err_037 = calculateErrorSqr(l_037, n);
      double  err_063 = calculateErrorSqr(l_063, n);
      double  err_ = (err_037 > err_063 ? err_037 : err_063);
      return (err_ < err ? err_ : err);
    }
  }
  return err;
}

double Plus4FLIConverter::findLuminanceCodes(long xc, long yc)
{
  int     l0 = 0;
  int     l1 = 8;
  xc = xc & (~(long(7)));
  yc = yc & (~(long(noLuminanceInterlace ? 3 : 2)));
  float   tmpBuf[32];
  int     nPixels = (noLuminanceInterlace ? 32 : 16);
  for (int i = 0; i < nPixels; i++) {
    long    x_ = xc | long(i & 7);
    long    y_ = yc | long((i & 8) >> 2) | long(i >> 4);
    tmpBuf[i] = resizedImage.y()[y_].getPixelShifted(x_);
  }
  if (!luminance1BitMode) {
    // find the best pair of luminance values, depending on the search mode
    if (luminanceSearchMode == 1) {
      float   minVal = 1.0f;
      float   maxVal = 0.0f;
      for (int i = 0; i < nPixels; i++) {
        if (tmpBuf[i] < minVal)
          minVal = tmpBuf[i];
        if (tmpBuf[i] > maxVal)
          maxVal = tmpBuf[i];
      }
      double  minErr0 = 1000000.0;
      double  minErr1 = 1000000.0;
      for (int i = 0; i < 9; i++) {
        double  err = calculateError(yTable[i], minVal);
        if (err < minErr0) {
          l0 = i;
          minErr0 = err;
        }
        err = calculateError(yTable[i], maxVal);
        if (err < minErr1) {
          l1 = i;
          minErr1 = err;
        }
      }
      if (l0 == l1) {
        if (minErr0 < minErr1) {
          if (l1 < 8)
            l1++;
          else
            l0--;
        }
        else {
          if (l0 > 0)
            l0--;
          else
            l1++;
        }
      }
    }
    else if (luminanceSearchMode == 3) {
      l0 = 8;
      l1 = 0;
      for (int i = 0; i < nPixels; i++) {
        while (l0 > 0 && tmpBuf[i] < yTable[l0])
          l0--;
        while (l1 < 8 && tmpBuf[i] > yTable[l1])
          l1++;
      }
    }
    else {
      double  minErr = 1000000.0f;
      for (int l0tmp = 0; l0tmp < 8; l0tmp++) {
        for (int l1tmp = l0tmp + 1; l1tmp < 9; l1tmp++) {
          float   minVal = yTable[l0tmp];
          float   maxVal = yTable[l1tmp];
          double  err = 0.0;
          for (int i = 0; i < nPixels; i++) {
            err += calculateLuminanceError(tmpBuf[i], l0tmp, l1tmp);
            err += (calculateErrorSqr(tmpBuf[i], (minVal + maxVal) * 0.5f)
                    * 0.00001);
          }
          if (err < minErr) {
            minErr = err;
            l0 = l0tmp;
            l1 = l1tmp;
          }
        }
      }
    }
  }
  // store luminance codes
  luminanceCodeTable.l0(xc, yc) = l0;
  luminanceCodeTable.l1(xc, yc) = l1;
  prgData.luminance(xc, yc) = luminanceCodeTable.luminanceCode(xc, yc);
  if (noLuminanceInterlace) {
    luminanceCodeTable.l0(xc, yc + 1L) = l0;
    luminanceCodeTable.l1(xc, yc + 1L) = l1;
    prgData.luminance(xc, yc + 1L) =
        luminanceCodeTable.luminanceCode(xc, yc + 1L);
  }
  // return the total amount of error (used when optimizing horizontal shifts)
  double  err = 0.0;
  for (int i = 0; i < nPixels; i++) {
    long    y_ = yc | long((i & 8) >> 2) | long(i >> 4);
    long    x_ = (xc | long(i & 7)) + resizedImage.y()[y_].getXShift();
    if (x_ >= 8L && x_ < 312L)  // ignore pixels that are not visible
      err += calculateLuminanceError(tmpBuf[i], l0, l1);
  }
  return err;
}

void Plus4FLIConverter::generateBitmaps()
{
  for (int yc = 0; yc < 400; yc += 2) {
    for (int xc = 0; xc < 320; xc++)
      ditherPixel(xc, yc);
    for (int xc = 319; xc >= 0; xc--)
      ditherPixel(xc, yc + 1);
  }
  for (int yc = 0; yc < 400; yc++) {
    if (yc & 2)
      continue;
    for (int xc = 0; xc < 320; xc += 8) {
      // if all bits are 0 or 1, replace the bitmaps with
      // a dither pattern to improve color conversion
      unsigned char&  b0 = prgData.bitmap0(xc, yc);
      unsigned char&  b1 = prgData.bitmap1(xc, yc);
      int&    l0 = luminanceCodeTable.l0(xc, yc);
      int&    l1 = luminanceCodeTable.l1(xc, yc);
      if (b0 == b1 && ((b0 == 0x00 && l0 != 0) || (b0 == 0xFF && l1 != 0))) {
        if (b0 == 0x00)
          l1 = l0;
        else
          l0 = l1;
        prgData.luminance(xc, yc) = luminanceCodeTable.luminanceCode(xc, yc);
        b0 = 0x00;
        b1 = 0x00;
        for (int i = 0; i < 16; i++) {
          int     tmpY = yc | ((i & 8) >> 2);
          int     tmpX = (xc | (i & 7)) + resizedImage.y()[tmpY].getXShift();
          if (ditherPixelValue(tmpX, tmpY, 0.63212f))
            prgData.setPixel(xc | (i & 7), tmpY, true);
        }
      }
    }
  }
}

void Plus4FLIConverter::findColorCodes(long xc, long yc, int dir_)
{
  bool    oddField = bool(yc & 1L);
  float   savedU0[9];
  float   savedV0[9];
  float   savedU1[9];
  float   savedV1[9];
  for (int i = 0; i < 9; i++) {
    savedU0[i] = line0U.getPixelShifted(xc + (i * dir_));
    savedV0[i] = line0V.getPixelShifted(xc + (i * dir_));
    savedU1[i] = line1U.getPixelShifted(xc + (i * dir_));
    savedV1[i] = line1V.getPixelShifted(xc + (i * dir_));
  }
  // find the pair of colors that gives the least amount of error
  int     c0 = 0;
  int     c1 = 0;
  int     l0 = luminanceCodeTable.l0(xc, yc);
  int     l1 = luminanceCodeTable.l1(xc, yc);
  double  minColorErr = 1000000.0;
  int     colorCnt = 29;        // could be 43 to interlace colors with grey
  for (int i0 = 0; i0 < colorCnt; i0++) {
    for (int i1 = 0; i1 < colorCnt; i1++) {
      float   u0 = 0.0f;
      float   v0 = 0.0f;
      float   u1 = 0.0f;
      float   v1 = 0.0f;
      int     c0tmp = 0;
      int     c1tmp = 0;
      if (l0 > 0) {
        u0 = uvTable[i0].u;
        v0 = uvTable[i0].v;
        c0tmp = (oddField ? uvTable[i0].c1 : uvTable[i0].c0);
      }
      if (l1 > 0) {
        u1 = uvTable[i1].u;
        v1 = uvTable[i1].v;
        c1tmp = (oddField ? uvTable[i1].c1 : uvTable[i1].c0);
      }
      for (int x = 0; x < 9; x++) {
        bool    b = prgData.getPixel(xc + ((x <= 7 ? x : 7) * dir_), yc);
        float   u_ = (b ? u1 : u0);
        float   v_ = (b ? v1 : v0);
        line0U.setPixelShifted(xc + (x * dir_), u_);
        line0V.setPixelShifted(xc + (x * dir_), v_);
      }
      for (int x = 0; x < 9; x++) {
        bool    b = prgData.getPixel(xc + ((x <= 7 ? x : 7) * dir_), yc + 2L);
        float   u_ = (b ? u1 : u0);
        float   v_ = (b ? v1 : v0);
        line1U.setPixelShifted(xc + (x * dir_), u_);
        line1V.setPixelShifted(xc + (x * dir_), v_);
      }
      double  err = 0.0;
      for (int j = 0; j < 16; j++) {
        int     x = j & 7;
        Line320 *l0U = (j < 8 ? (&line0U) : (&line1U));
        Line320 *l0V = (j < 8 ? (&line0V) : (&line1V));
        float   u_ = l0U->getPixelShifted(xc + (x * dir_));
        float   v_ = l0V->getPixelShifted(xc + (x * dir_));
        if (!disablePAL) {
          // assume PAL filtering if requested
          Line320 *lm1U = (j < 8 ? (&prvLineU) : (&line0U));
          Line320 *lm1V = (j < 8 ? (&prvLineV) : (&line0V));
          u_ += lm1U->getPixelShifted(xc + (x * dir_));
          v_ += lm1V->getPixelShifted(xc + (x * dir_));
          u_ *= 0.96f;
          v_ *= 0.96f;
          u_ += (l0U->getPixelShifted(xc + ((x - 1) * dir_)) * 0.52f);
          v_ += (l0V->getPixelShifted(xc + ((x - 1) * dir_)) * 0.52f);
          u_ += (l0U->getPixelShifted(xc + ((x + 1) * dir_)) * 0.52f);
          v_ += (l0V->getPixelShifted(xc + ((x + 1) * dir_)) * 0.52f);
          u_ += (lm1U->getPixelShifted(xc + ((x - 1) * dir_)) * 0.52f);
          v_ += (lm1V->getPixelShifted(xc + ((x - 1) * dir_)) * 0.52f);
          u_ += (lm1U->getPixelShifted(xc + ((x + 1) * dir_)) * 0.52f);
          v_ += (lm1V->getPixelShifted(xc + ((x + 1) * dir_)) * 0.52f);
          u_ *= 0.25f;
          v_ *= 0.25f;
        }
        double  errU =
            double(u_)
            - double(resizedImage.u()[yc + ((j & 8) >> 2)].getPixelShifted(
                         xc + (x * dir_)));
        double  errV =
            double(v_)
            - double(resizedImage.v()[yc + ((j & 8) >> 2)].getPixelShifted(
                         xc + (x * dir_)));
        err = err + (errU * errU) + (errV * errV);
      }
      if (err < minColorErr) {
        c0 = c0tmp;
        c1 = c1tmp;
        minColorErr = err;
      }
      else {
        for (int i = 0; i < 9; i++) {
          line0U.setPixelShifted(xc + (i * dir_), savedU0[i]);
          line0V.setPixelShifted(xc + (i * dir_), savedV0[i]);
          line1U.setPixelShifted(xc + (i * dir_), savedU1[i]);
          line1V.setPixelShifted(xc + (i * dir_), savedV1[i]);
        }
      }
    }
  }
  // store color code
  prgData.color(xc, yc) = (unsigned char) ((c1 << 4) | c0);
}

int Plus4FLIConverter::processImage(const char *infileName,
                                    const char *outfileName)
{
  std::FILE *f = (std::FILE *) 0;
  try {
    checkParameters();
    for (size_t i = 0x0401; i < 0x8801; i++)
      prgData[i] = 0x00;
    prgData.borderColor() = (unsigned char) borderColor;
    prgData.interlaceDisabled() = (unsigned char) disableInterlace;
    f = std::fopen(infileName, "rb");
    if (!f) {
      std::fprintf(stderr, " *** error opening input file '%s'\n", infileName);
      return -1;
    }
    for (size_t i = 0; i < (640 * 400 * 3); i++) {
      int     c = std::fgetc(f);
      if (c == EOF) {
        std::fprintf(stderr, " *** unexpected end of input data\n");
        std::fclose(f);
        return -1;
      }
      inputImage[i] = (unsigned char) (c & 0xFF);
    }
    if (std::fgetc(f) != EOF) {
      std::fprintf(stderr, " *** more input data than expected\n");
      std::fclose(f);
      return -1;
    }
    std::fclose(f);
    f = (std::FILE *) 0;
    for (int yc = 0; yc < 400; yc++) {
      double  tmp = 0.0;
      double  tmpU = 0.0;
      double  tmpV = 0.0;
      for (int xc = 0; xc < 640; xc++) {
        double  r = double(inputImage.pixelR(xc, yc));
        double  g = double(inputImage.pixelG(xc, yc));
        double  b = double(inputImage.pixelB(xc, yc));
        r = (r * (yMax - yMin) / 255.0) + yMin;
        g = (g * (yMax - yMin) / 255.0) + yMin;
        b = (b * (yMax - yMin) / 255.0) + yMin;
        double  y = (r * 0.299) + (g * 0.587) + (b * 0.114);
        double  u = (b - y) * 0.492 * colorSaturationMult;
        double  v = (r - y) * 0.877 * colorSaturationMult;
        double  c = std::sqrt((u * u) + (v * v));
        if (c > 0.000001) {
          // reduce saturation range
          c = std::pow((c / 0.19), colorSaturationPow) * (0.19 / c);
          u = u * c;
          v = v * c;
        }
        tmp += y;
        tmpU += u;
        tmpV += v;
        if ((xc & 1) == 1) {
          tmp = tmp * 0.5;
          tmp = (tmp > 0.0 ? (tmp < 1.0 ? tmp : 1.0) : 0.0);
          tmp = std::pow(tmp, monitorGamma);
          resizedImage.y()[yc].setPixel(xc >> 1, float(tmp));
          resizedImage.u()[yc].setPixel(xc >> 1, float(tmpU * 0.5));
          resizedImage.v()[yc].setPixel(xc >> 1, float(tmpV * 0.5));
          tmp = 0.0;
          tmpU = 0.0;
          tmpV = 0.0;
        }
      }
    }
    for (int yc = 0; yc < 400; yc += 2) {
      for (int xc = 0; xc < 320; xc++) {
        if (disableInterlace) {
          float   y0 = resizedImage.y()[yc].getPixel(xc);
          float   y1 = resizedImage.y()[yc + 1].getPixel(xc);
          resizedImage.y()[yc].setPixel(xc, (y0 + y1) * 0.5f);
          resizedImage.y()[yc + 1].setPixel(xc, (y0 + y1) * 0.5f);
        }
        float   u0 = resizedImage.u()[yc].getPixel(xc);
        float   u1 = resizedImage.u()[yc + 1].getPixel(xc);
        float   v0 = resizedImage.v()[yc].getPixel(xc);
        float   v1 = resizedImage.v()[yc + 1].getPixel(xc);
        resizedImage.u()[yc].setPixel(xc, (u0 + u1) * 0.5f);
        resizedImage.u()[yc + 1].setPixel(xc, (u0 + u1) * 0.5f);
        resizedImage.v()[yc].setPixel(xc, (v0 + v1) * 0.5f);
        resizedImage.v()[yc + 1].setPixel(xc, (v0 + v1) * 0.5f);
      }
    }
    for (int yc = 0; yc < 400; yc++) {
      int     xShift_ = (!(yc & 1) ? xShift0 : xShift1);
      if (xShift_ == -2)
        xShift_ = int(std::rand() & 0x7000) >> 12;
      else if (xShift_ == -1)
        xShift_ = 0;
      resizedImage.y()[yc].setXShift(xShift_);
      resizedImage.u()[yc].setXShift(xShift_);
      resizedImage.v()[yc].setXShift(xShift_);
    }
    for (int yc = 0; yc < 400; yc++) {
      if ((yc & (noLuminanceInterlace ? 3 : 2)) != 0)
        continue;
      std::fprintf(stderr, "\r  %3d%%  ", int((yc * 33) / 400));
      if (!(xShift0 == -1 || xShift1 == -1)) {
        for (int xc = 0; xc < 320; xc += 8)
          findLuminanceCodes(xc, yc);
      }
      else if (!(yc & 3)) {
        // find optimal horizontal shifts
        double  minErr = 1000000.0;
        int     bestXShift[4];
        int     xs[4];
        for (int i = 0; i < 4; i++) {
          bestXShift[i] = 0;
          xs[i] = 0;
        }
        do {
          for (int i = 0; i < 4; i++) {
            xs[i] = xs[i] & 7;
            resizedImage.y()[yc + i].setXShift(xs[i]);
            resizedImage.u()[yc + i].setXShift(xs[i]);
            resizedImage.v()[yc + i].setXShift(xs[i]);
          }
          bool    skipFlag = false;
          for (int i = 0; i < 4; i++) {
            // do not allow stepping by more than one pixel at once
            if ((yc + i) > 0) {
              int     d = resizedImage.y()[yc + i].getXShift()
                          - resizedImage.y()[yc + i - 1].getXShift();
              if (!(d == 0 || d == 1 || d == -1 || d == 7 || d == -7)) {
                skipFlag = true;
                break;
              }
            }
          }
          if (!skipFlag) {
            // calculate the total error for four lines
            double  err = 0.0;
            for (int xc = 0; xc < 320; xc += 8)
              err += findLuminanceCodes(xc, yc);
            if (!noLuminanceInterlace) {
              for (int xc = 0; xc < 320; xc += 8)
                err += findLuminanceCodes(xc, yc + 1);
            }
            if (err < minErr) {
              for (int i = 0; i < 4; i++)
                bestXShift[i] = xs[i];
              minErr = err;
            }
          }
          for (int i = 0; i < 4; i++) {
            xs[i] = xs[i] + 1;
            if (xs[i] < 8)
              break;
          }
        } while (xs[3] < 8);
        // use the best horizontal shift that was found
        for (int i = 0; i < 4; i++) {
          resizedImage.y()[yc + i].setXShift(bestXShift[i]);
          resizedImage.u()[yc + i].setXShift(bestXShift[i]);
          resizedImage.v()[yc + i].setXShift(bestXShift[i]);
        }
        for (int xc = 0; xc < 320; xc += 8)
          findLuminanceCodes(xc, yc);
        if (!noLuminanceInterlace) {
          for (int xc = 0; xc < 320; xc += 8)
            findLuminanceCodes(xc, yc + 1);
        }
      }
    }
    generateBitmaps();
    // convert color information
    prvLineU.clear();
    prvLineV.clear();
    for (int yc = 0; yc < 400; yc++) {
      if (yc & 2)
        continue;
      std::fprintf(stderr, "\r  %3d%%  ", int(((yc * 67) / 400) + 33));
      line0U.clear();
      line0V.clear();
      line1U.clear();
      line1V.clear();
      line0U.setXShift(resizedImage.u()[yc].getXShift());
      line0V.setXShift(resizedImage.v()[yc].getXShift());
      line1U.setXShift(resizedImage.u()[yc + 2].getXShift());
      line1V.setXShift(resizedImage.v()[yc + 2].getXShift());
      if (resizedImage.y()[yc].getXShift()
          >= resizedImage.y()[yc + 2].getXShift()) {
        for (int xc = 0; xc < 320; xc += 8)
          findColorCodes(xc, yc, 1);
      }
      else {
        for (int xc = 319; xc >= 0; xc -= 8)
          findColorCodes(xc, yc, -1);
      }
      prvLineU = line1U;
      prvLineV = line1V;
    }
    std::fprintf(stderr, "\r  100%%  \n");
    // write PRG file
    f = std::fopen(outfileName, "wb");
    if (!f) {
      std::fprintf(stderr, " *** error opening output file '%s'\n",
                           outfileName);
      return -1;
    }
    for (int yc = 0; yc < 400; yc++)
      prgData.lineXShift(yc) = (unsigned char) resizedImage.y()[yc].getXShift();
    if (noFLIDisplayCode) {
      if (std::fputc(0x00, f) == EOF || std::fputc(0x14, f) == EOF) {
        std::fprintf(stderr, " *** error writing output file\n");
        std::fclose(f);
        return -1;
      }
    }
    for (int i = (noFLIDisplayCode ? 0x0401 : 0x0000); i < 0x8801; i++) {
      if (std::fputc(int(prgData[i]), f) == EOF) {
        std::fprintf(stderr, " *** error writing output file\n");
        std::fclose(f);
        return -1;
      }
    }
    if (std::fflush(f) != 0) {
      std::fprintf(stderr, " *** error writing output file\n");
      std::fclose(f);
      return -1;
    }
    std::fclose(f);
  }
  catch (...) {
    std::fprintf(stderr, " *** error processing image\n");
    if (f)
      std::fclose(f);
    return -1;
  }
  return 0;
}

int main(int argc, char **argv)
{
  Plus4FLIConverter fliConv;
  const char  *infileName = (char *) 0;
  const char  *outfileName = (char *) 0;
  bool      invalidOption = false;
  bool      printUsageFlag = false;
  for (int i = 1; i < argc; i++) {
    if (std::strcmp(argv[i], "-ymin") == 0) {
      if (++i >= argc) {
        std::fprintf(stderr, " *** missing argument for '%s'\n", argv[i - 1]);
        return -1;
      }
      fliConv.yMin = std::atof(argv[i]);
    }
    else if (std::strcmp(argv[i], "-ymax") == 0) {
      if (++i >= argc) {
        std::fprintf(stderr, " *** missing argument for '%s'\n", argv[i - 1]);
        return -1;
      }
      fliConv.yMax = std::atof(argv[i]);
    }
    else if (std::strcmp(argv[i], "-saturation") == 0) {
      if ((i + 2) >= argc) {
        std::fprintf(stderr, " *** missing arguments for '%s'\n", argv[i]);
        return -1;
      }
      fliConv.colorSaturationMult = std::atof(argv[i + 1]);
      fliConv.colorSaturationPow = std::atof(argv[i + 2]);
      i = i + 2;
    }
    else if (std::strcmp(argv[i], "-mgamma") == 0) {
      if (++i >= argc) {
        std::fprintf(stderr, " *** missing argument for '%s'\n", argv[i - 1]);
        return -1;
      }
      fliConv.monitorGamma = std::atof(argv[i]);
    }
    else if (std::strcmp(argv[i], "-dither") == 0) {
      if ((i + 3) >= argc) {
        std::fprintf(stderr, " *** missing arguments for '%s'\n", argv[i]);
        return -1;
      }
      fliConv.ditherMode = std::atoi(argv[i + 1]);
      fliConv.ditherLimit = std::atof(argv[i + 2]);
      fliConv.ditherScale = std::atof(argv[i + 3]);
      i = i + 3;
    }
    else if (std::strcmp(argv[i], "-pal") == 0) {
      if (++i >= argc) {
        std::fprintf(stderr, " *** missing argument for '%s'\n", argv[i - 1]);
        return -1;
      }
      fliConv.disablePAL = !(std::atoi(argv[i]));
    }
    else if (std::strcmp(argv[i], "-xshift") == 0) {
      if ((i + 2) >= argc) {
        std::fprintf(stderr, " *** missing arguments for '%s'\n", argv[i]);
        return -1;
      }
      fliConv.xShift0 = std::atoi(argv[i + 1]);
      fliConv.xShift1 = std::atoi(argv[i + 2]);
      i = i + 2;
    }
    else if (std::strcmp(argv[i], "-border") == 0) {
      if (++i >= argc) {
        std::fprintf(stderr, " *** missing argument for '%s'\n", argv[i - 1]);
        return -1;
      }
      fliConv.borderColor = std::atoi(argv[i]);
    }
    else if (std::strcmp(argv[i], "-nointerlace") == 0) {
      if (++i >= argc) {
        std::fprintf(stderr, " *** missing argument for '%s'\n", argv[i - 1]);
        return -1;
      }
      fliConv.disableInterlace = bool(std::atoi(argv[i]));
    }
    else if (std::strcmp(argv[i], "-y1bit") == 0) {
      if (++i >= argc) {
        std::fprintf(stderr, " *** missing argument for '%s'\n", argv[i - 1]);
        return -1;
      }
      fliConv.luminance1BitMode = bool(std::atoi(argv[i]));
    }
    else if (std::strcmp(argv[i], "-no_li") == 0) {
      if (++i >= argc) {
        std::fprintf(stderr, " *** missing argument for '%s'\n", argv[i - 1]);
        return -1;
      }
      fliConv.noLuminanceInterlace = bool(std::atoi(argv[i]));
    }
    else if (std::strcmp(argv[i], "-searchmode") == 0) {
      if (++i >= argc) {
        std::fprintf(stderr, " *** missing argument for '%s'\n", argv[i - 1]);
        return -1;
      }
      fliConv.luminanceSearchMode = std::atoi(argv[i]);
    }
    else if (std::strcmp(argv[i], "-raw") == 0) {
      if (++i >= argc) {
        std::fprintf(stderr, " *** missing argument for '%s'\n", argv[i - 1]);
        return -1;
      }
      fliConv.noFLIDisplayCode = bool(std::atoi(argv[i]));
    }
    else if (std::strcmp(argv[i], "-h") == 0 ||
             std::strcmp(argv[i], "-help") == 0 ||
             std::strcmp(argv[i], "--help") == 0) {
      printUsageFlag = true;
    }
    else if (argv[i][0] == '-' || outfileName != (char *) 0) {
      std::fprintf(stderr, " *** invalid option '%s'\n", argv[i]);
      invalidOption = true;
      break;
    }
    else {
      if (!infileName)
        infileName = argv[i];
      else
        outfileName = argv[i];
    }
  }
  if (invalidOption || printUsageFlag || outfileName == (char *) 0) {
    std::fprintf(stderr, "Usage: %s [OPTIONS...] infile.rgb outfile.prg\n",
                         argv[0]);
    std::fprintf(stderr, "Options:\n");
    std::fprintf(stderr, "    -ymin <MIN>         (default: 0.0)\n");
    std::fprintf(stderr, "    -ymax <MAX>         (default: 1.0)\n");
    std::fprintf(stderr, "        scale luminance range from 0..1 to "
                         "MIN..MAX\n");
    std::fprintf(stderr, "    -saturation <M> <P> (defaults: 1.0, 0.6)\n");
    std::fprintf(stderr, "        color saturation scale and power\n");
    std::fprintf(stderr, "    -mgamma <N>         (default: 1.33)\n");
    std::fprintf(stderr, "        assume monitor gamma N\n");
    std::fprintf(stderr, "    -dither <M> <L> <S> (defaults: 0, 0.125, 0.5)\n");
    std::fprintf(stderr, "        dither mode (0: ordered, 1: diffuse), "
                         "limit,\n        and error diffusion factor\n");
    std::fprintf(stderr, "    -pal <N>            (0 or 1, default: 1)\n");
    std::fprintf(stderr, "        assume PAL chrominance filtering "
                         "if set to 1\n");
    std::fprintf(stderr, "    -xshift <S0> <S1>   "
                         "(-2 to 7, defaults: -1, -1)\n");
    std::fprintf(stderr, "        set horizontal shift for each field (-2 is "
                         "random,\n        -1 finds optimal values)\n");
    std::fprintf(stderr, "    -border <N>         (0 to 255, default: 0)\n");
    std::fprintf(stderr, "        set border color\n");
    std::fprintf(stderr, "    -nointerlace <N>    (0 or 1, default: 0)\n");
    std::fprintf(stderr, "        do not use double vertical resolution\n");
    std::fprintf(stderr, "    -y1bit <N>          (0 or 1, default: 0)\n");
    std::fprintf(stderr, "        use 1 bit (black and white) luminance\n");
    std::fprintf(stderr, "    -no_li <N>          (0 or 1, default: 0)\n");
    std::fprintf(stderr, "        do not interlace luminance attributes\n");
    std::fprintf(stderr, "    -searchmode <N>     (0 to 4, default: 4)\n");
    std::fprintf(stderr, "        select luminance search algorithm\n");
    std::fprintf(stderr, "    -raw <N>            (0 or 1, default: 0)\n");
    std::fprintf(stderr, "        write the image data only\n");
    return (printUsageFlag ? 0 : -1);
  }
  return fliConv.processImage(infileName, outfileName);
}

