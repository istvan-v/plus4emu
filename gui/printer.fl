# data file for the Fltk User Interface Designer (fluid)
version 1.0107 
do_not_include_H_from_C 
header_name {.hpp} 
code_name {.cpp}
decl {\#include "gui.hpp"} {selected
} 

decl {\#include <FL/Fl_Box.H>} {} 

decl {\#include <FL/fl_draw.H>} {} 

class Plus4EmuGUI_PrinterDisplay {open : {public Fl_Box}
} {
  decl {Plus4EmuGUI_PrinterWindow *window;} {}
  Function {Plus4EmuGUI_PrinterDisplay(int xx, int yy, int ww, int hh, const char *ll = 0) : Fl_Box(xx, yy, ww, hh, ll), window((Plus4EmuGUI_PrinterWindow *) 0)} {open
  } {
    code {{
}} {}
  }
  Function {~Plus4EmuGUI_PrinterDisplay()} {open return_type virtual
  } {
    code {{
}} {}
  }
  Function {draw()} {open return_type {virtual void}
  } {
    code {{
  if (window)
    window->drawPrinterOutput();
  else
    fl_rectf(this->x(), this->y(), this->w(), this->h(), 0, 0, 0);
}} {}
  }
  Function {setWindow(Plus4EmuGUI_PrinterWindow *window_)} {open return_type void
  } {
    code {{
  window = window_;
}} {}
  }
} 

class Plus4EmuGUI_PrinterWindow {open
} {
  decl {Plus4EmuGUI& gui;} {}
  decl {Plus4Emu::Timer updateTimer;} {}
  decl {int prvHeadPosX;} {}
  decl {int prvHeadPosY;} {}
  decl {uint8_t prvLEDState;} {}
  decl {bool vmLockTimeoutFlag;} {}
  Function {Plus4EmuGUI_PrinterWindow(Plus4EmuGUI& gui_) : gui(gui_), updateTimer(), prvHeadPosX(-2), prvHeadPosY(-2), prvLEDState(0x00), vmLockTimeoutFlag(false)} {open
  } {
    Fl_Window window {
      label Printer
      callback {{
  window->hide();
}} open
      xywh {231 97 745 555} type Double color 48 visible
    } {
      Fl_Scroll printerDisplayScroll {open
        xywh {10 10 725 500} box DOWN_BOX color 47
      } {
        Fl_Box printerDisplay {
          xywh {13 12 700 990} box FLAT_BOX color 47
          class Plus4EmuGUI_PrinterDisplay
        }
      }
      Fl_Box printerLEDDisplay {
        xywh {20 525 15 15} box ROUND_DOWN_BOX color 56
      }
      Fl_Light_Button {} {
        label {Form feed}
        callback {{
  try {
    if (gui.lockVMThread()) {
      try {
        gui.vm.setPrinterFormFeedOn(o->value() != 0);
      }
      catch (...) {
        gui.unlockVMThread();
        throw;
      }
      gui.unlockVMThread();
    }
  }
  catch (std::exception& e) {
    gui.errorMessage(e.what());
  }
}}
        xywh {55 520 100 25} selection_color 3
      }
      Fl_Button {} {
        label {Save to file}
        callback {{
  savePrinterOutput();
}}
        xywh {165 520 100 25} selection_color 50
      }
      Fl_Button {} {
        label Clear
        callback {{
  try {
    if (gui.lockVMThread()) {
      try {
        gui.vm.clearPrinterOutput();
        printerDisplayScroll->position(printerDisplayScroll->xposition(), 0);
        printerDisplayScroll->redraw();
      }
      catch (...) {
        gui.unlockVMThread();
        throw;
      }
      gui.unlockVMThread();
    }
  }
  catch (std::exception& e) {
    gui.errorMessage(e.what());
  }
}}
        xywh {418 520 80 25} selection_color 50
      }
      Fl_Button {} {
        label Close
        callback {{
  window->hide();
}}
        xywh {650 520 80 25} selection_color 50
      }
    }
    code {{
  printerDisplay->setWindow(this);
}} {}
  }
  Function {~Plus4EmuGUI_PrinterWindow()} {open
  } {
    code {{
  delete window;
}} {}
  }
  Function {show()} {open return_type void
  } {
    code {{
  window->show();
}} {}
  }
  Function {hide()} {open return_type void
  } {
    code {{
  window->hide();
}} {}
  }
  Function {shown()} {open return_type bool
  } {
    code {{
  return bool(window->shown());
}} {}
  }
  Function {updateWindow(const Plus4Emu::VMThread::VMThreadStatus& vmThreadStatus)} {open return_type void
  } {
    code {{
  if (vmThreadStatus.printerHeadPositionX == prvHeadPosX &&
      vmThreadStatus.printerHeadPositionY == prvHeadPosY &&
      vmThreadStatus.printerLEDState == prvLEDState &&
      !(vmThreadStatus.printerOutputChanged || vmLockTimeoutFlag))
    return;
  if (updateTimer.getRealTime() < (vmLockTimeoutFlag ? 0.75 : 0.05))
    return;
  updateTimer.reset();
  if (vmThreadStatus.printerLEDState == 0x00)
    printerLEDDisplay->color(FL_BLACK);
  else
    printerLEDDisplay->color(Fl_Color(128));
  printerLEDDisplay->redraw();
  prvLEDState = vmThreadStatus.printerLEDState;
  if (vmThreadStatus.printerOutputChanged ||
      vmThreadStatus.printerHeadPositionX != prvHeadPosX ||
      vmThreadStatus.printerHeadPositionY != prvHeadPosY ||
      vmLockTimeoutFlag) {
    int     scrollPosY = printerDisplayScroll->yposition();
    if ((vmThreadStatus.printerHeadPositionY - scrollPosY) > 488) {
      scrollPosY = vmThreadStatus.printerHeadPositionY - 488;
      if (scrollPosY > 494)
        scrollPosY = 494;
      printerDisplayScroll->position(printerDisplayScroll->xposition(),
                                     scrollPosY);
      printerDisplayScroll->redraw();
    }
    printerDisplay->redraw();
  }
}} {}
  }
  Function {drawPrinterOutput()} {open return_type void
  } {
    code {{
  if (gui.vmThread.lock(vmLockTimeoutFlag ? 75 : 250) == 0) {
    vmLockTimeoutFlag = false;
    try {
      const uint8_t *pageBuf = (uint8_t *) 0;
      int     pageWidth = 0;
      int     pageHeight = 0;
      gui.vm.getPrinterOutput(pageBuf, pageWidth, pageHeight);
      int     headPosX = -1;
      int     headPosY = -1;
      gui.vm.getPrinterHeadPosition(headPosX, headPosY);
      int     x0 = printerDisplay->x();
      int     y0 = 12;
      int     x1 = x0 + printerDisplay->w();
      int     y1 = 508;
      int     y2 = 12 - printerDisplay->y();
      if ((y2 + 496) > pageHeight)
        y1 = y1 - ((y2 + 496) - pageHeight);
      if (y1 < y0)
        y1 = y0;
      if (y1 > y0) {
        fl_draw_image_mono((const unsigned char *) &(pageBuf[y2 * pageWidth]),
                           x0, y0, (x1 - x0), (y1 - y0));
      }
      if (y1 < 508) {
        fl_color(Fl_Color(47));
        fl_rectf(x0, y1, (x1 - x0), (508 - y1));
      }
      if (headPosX >= 0 && headPosX < pageWidth &&
          headPosY >= 0 && headPosY < pageHeight) {
        y0 = headPosY + printerDisplay->y();
        y1 = y0 + 8;
        if (y0 < 12)
          y0 = 12;
        if (y1 > 508)
          y1 = 508;
        if (y1 > y0) {
          fl_color(FL_BLUE);
          fl_line(x0 + headPosX, y0, x0 + headPosX, y1 - 1);
        }
      }
      prvHeadPosX = headPosX;
      prvHeadPosY = headPosY;
      gui.vm.clearPrinterOutputChangedFlag();
    }
    catch (...) {
    }
    gui.vmThread.unlock();
  }
  else {
    vmLockTimeoutFlag = true;
    fl_color(FL_BLACK);
    fl_rectf(printerDisplay->x(), 12, printerDisplay->w(), 496);
  }
}} {}
  }
  Function {savePrinterOutput()} {open private return_type void
  } {
    code {{
  try {
    std::string fName;
    std::FILE   *f = (std::FILE *) 0;
    if (!gui.browseFile(fName, gui.screenshotDirectory, "TGA files\\t*.tga",
                        Fl_Native_File_Chooser::BROWSE_SAVE_FILE,
                        "Save printer output"))
      return;
    if (gui.lockVMThread()) {
      try {
        const uint8_t *buf = (uint8_t *) 0;
        int     w_ = 0;
        int     h_ = 0;
        gui.vm.getPrinterOutput(buf, w_, h_);
        if (buf == (uint8_t *) 0 || w_ <= 0 || h_ <= 0)
          throw Plus4Emu::Exception("printer emulation is not enabled");
        f = std::fopen(fName.c_str(), "wb");
        if (!f)
          throw Plus4Emu::Exception("error opening image file");
        unsigned char tmpBuf[1032];
        tmpBuf[0] = 0;                  // ID length
        tmpBuf[1] = 1;                  // use colormap
        tmpBuf[2] = 9;                  // image type (colormap/RLE)
        tmpBuf[3] = 0;                  // color map specification
        tmpBuf[4] = 0;                  // first entry index = 0
        tmpBuf[5] = 0;
        tmpBuf[6] = 1;                  // length = 256
        tmpBuf[7] = 24;                 // colormap entry size
        tmpBuf[8] = 0;                  // X origin
        tmpBuf[9] = 0;
        tmpBuf[10] = 0;                 // Y origin
        tmpBuf[11] = 0;
        tmpBuf[12] = (unsigned char) (w_ & 0xFF);   // image width
        tmpBuf[13] = (unsigned char) (w_ >> 8);
        tmpBuf[14] = (unsigned char) (h_ & 0xFF);   // image height
        tmpBuf[15] = (unsigned char) (h_ >> 8);
        tmpBuf[16] = 8;                 // bits per pixel
        tmpBuf[17] = 0x20;              // image descriptor (origin: top/left)
        for (int i = 0; i < 256; i++) {
          tmpBuf[i * 3 + 18] = (unsigned char) i;
          tmpBuf[i * 3 + 19] = (unsigned char) i;
          tmpBuf[i * 3 + 20] = (unsigned char) i;
        }
        if (std::fwrite(&(tmpBuf[0]), sizeof(unsigned char), 786, f) != 786)
          throw Plus4Emu::Exception("error writing image file "
                                    "- is the disk full ?");
        for (int yc = 0; yc < h_; yc++) {
          const unsigned char *bufp = &(buf[yc * w_]);
          // RLE encode line
          unsigned char   *p = &(tmpBuf[0]);
          int     xc = 0;
          while (xc < w_) {
            if (xc == (w_ - 1)) {
              *(p++) = 0x00;
              *(p++) = bufp[xc];
              xc++;
            }
            else if (bufp[xc] == bufp[xc + 1]) {
              int     tmp = xc + 2;
              while (tmp < w_ && (tmp - xc) < 128) {
                if (bufp[tmp] != bufp[xc])
                  break;
                tmp++;
              }
              *(p++) = (unsigned char) (((tmp - xc) - 1) | 0x80);
              *(p++) = bufp[xc];
              xc = tmp;
            }
            else {
              int     tmp = xc + 2;
              while (tmp < w_ && (tmp - xc) < 128) {
                if (bufp[tmp] == bufp[tmp - 1]) {
                  tmp--;
                  break;
                }
                tmp++;
              }
              *(p++) = (unsigned char) ((tmp - xc) - 1);
              while (xc < tmp) {
                *(p++) = bufp[xc];
                xc++;
              }
            }
          }
          size_t  nBytes = size_t(p - &(tmpBuf[0]));
          if (std::fwrite(&(tmpBuf[0]), sizeof(unsigned char), nBytes, f)
              != nBytes)
            throw Plus4Emu::Exception("error writing image file "
                                      "- is the disk full ?");
        }
      }
      catch (...) {
        gui.unlockVMThread();
        if (f) {
          std::fclose(f);
          f = (std::FILE *) 0;
          if (fName.length() > 0)
            std::remove(fName.c_str());
        }
        throw;
      }
      gui.unlockVMThread();
    }
    if (f)
      std::fclose(f);
  }
  catch (std::exception& e) {
    gui.errorMessage(e.what());
  }
}} {}
  }
} 
